This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
- Pay special attention to the Repository Instruction. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Long base64 data strings (e.g., data:image/png;base64,...) have been truncated to reduce token count
- Files are sorted by Git change count (files with more changes are at the bottom)
- Git diffs from the worktree and staged changes are included
- Git logs (50 commits) are included to show development patterns
</notes>

</file_summary>

<user_provided_header>
This repository contains the source code for the JoT tool.

Please refer to the README.md file for more detailed information on usage and configuration.

</user_provided_header>

<directory_structure>
.claude/
  settings.local.json
.github/
  workflows/
    ci.yml
    codeql.yml
    dependabot-auto-merge.yml
    deploy.yml
    performance.yml
    pr-lint.yml
    release.yml
  dependabot.yml
  README.md
src/
  bot/
    commands/
      actionCommands.ts
      basicCommands.ts
      configCommands.ts
      infoCommands.ts
    handlers/
      activityProcessor.ts
      callbackHandlers.ts
      messageHandlers.ts
    bot.ts
  cron/
    pollActivities.ts
    refreshSourcesCache.ts
    syncSessions.ts
  jules/
    api.ts
  kv/
    storage.ts
  types/
    env.ts
  utils/
    formatters.ts
    github.ts
    image.ts
    retry.ts
  index.ts
test/
  formatters.test.ts
  github.test.ts
  jules.test.ts
.gitignore
AGENTS.md
LICENSE
package.json
README.md
repomix.config.json
tsconfig.json
vitest.config.ts
wrangler.toml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(gh pr list --search \"dependabot\" --state open)",
      "Bash(gh pr view 4 --json title,body,url,changedFiles,mergeable)",
      "Bash(gh pr view 5 --json title,body,url,changedFiles,mergeable)",
      "Bash(gh pr view 6 --json title,body,url,changedFiles,mergeable)",
      "Bash(gh pr view 7 --json title,body,url,changedFiles,mergeable)",
      "Bash(gh pr view 8 --json title,body,url,changedFiles,mergeable)",
      "Bash(gh pr view 9 --json title,body,url,changedFiles,mergeable)",
      "Bash(gh pr checkout 4)",
      "Bash(git merge main)",
      "Bash(git add package.json)",
      "Bash(npm install)",
      "WebSearch",
      "Bash(npm view @cloudflare/vitest-pool-workers versions --json)",
      "Bash(npm view @cloudflare/vitest-pool-workers@latest peerDependencies)",
      "Bash(git add .)",
      "Bash(git commit -m \"Resolve conflicts: upgrade vitest to v3.x and @cloudflare/vitest-pool-workers to v0.10.4\n\n- vitest: 2.1.8 ‚Üí 3.0.0 (compatible with @cloudflare/vitest-pool-workers)\n- @cloudflare/vitest-pool-workers: 0.10.3 ‚Üí 0.10.4 (latest)\n- wrangler: 3.114.15 (keep latest)\n\nNote: vitest 4.x is not yet compatible with @cloudflare/vitest-pool-workers\")",
      "Bash(git push origin dependabot/npm_and_yarn/vitest-4.0.6)",
      "Bash(git checkout main)",
      "Bash(git merge dependabot/npm_and_yarn/vitest-4.0.6)",
      "Bash(git push origin main)",
      "Bash(gh pr merge 4 --admin --merge --subject \"chore(deps-dev): Bump vitest from 2.1.9 to 3.0.0 and @cloudflare/vitest-pool-workers to 0.10.4\n\n- Resolved compatibility issues with Cloudflare Workers testing\n- vitest 2.1.8 ‚Üí 3.0.0\n- @cloudflare/vitest-pool-workers 0.10.3 ‚Üí 0.10.4\n\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\")",
      "Bash(gh pr merge 5 --admin --merge --subject \"ci(deps): Bump softprops/action-gh-release from 1 to 2\n\n- Update to latest v2 release\n- Migrates to Node.js 20 runtime\n\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\")",
      "Bash(gh pr merge 6 --admin --merge --subject \"ci(deps): Bump github/codeql-action from 3 to 4\n\n- Update to latest v4 release\n- Runs on Node.js v24\n- Improved SARIF file processing\n\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\")",
      "Bash(gh pr merge 7 --admin --merge --subject \"ci(deps): Bump actions/checkout from 4 to 5\n\n- Update to latest v5 release\n- Migrates to Node.js 24 runtime\n- Requires Actions Runner v2.327.1 or newer\n\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\")",
      "Bash(gh pr merge 8 --admin --merge --subject \"ci(deps): Bump codecov/codecov-action from 4 to 5\n\n- Update to latest v5 release\n- Uses Codecov Wrapper for faster updates\n- New features: binary, gcov_args, report_type, skip_validation\n\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\")",
      "Bash(gh pr merge 9 --admin --merge --subject \"ci(deps): Bump actions/github-script from 7 to 8\n\n- Update to latest v8 release\n- Migrates to Node.js 24 runtime\n- Requires Actions Runner v2.327.1 or newer\n\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\")",
      "Bash(gh pr list --search \"dependabot\" --state merged)",
      "WebFetch(domain:developers.cloudflare.com)",
      "WebFetch(domain:www.cloudflare.com)"
    ],
    "deny": [],
    "ask": []
  }
}
</file>

<file path=".github/workflows/dependabot-auto-merge.yml">
name: Dependabot Auto-Merge

on:
  pull_request:
    branches:
      - main
      - develop

permissions:
  contents: write
  pull-requests: write

jobs:
  dependabot:
    name: Auto-merge Dependabot PRs
    runs-on: ubuntu-latest
    if: github.actor == 'dependabot[bot]'

    steps:
      - name: Dependabot metadata
        id: metadata
        uses: dependabot/fetch-metadata@v2
        with:
          github-token: "${{ secrets.GITHUB_TOKEN }}"

      - name: Auto-merge for patch and minor updates
        if: |
          steps.metadata.outputs.update-type == 'version-update:semver-patch' ||
          steps.metadata.outputs.update-type == 'version-update:semver-minor'
        run: gh pr merge --auto --squash "$PR_URL"
        env:
          PR_URL: ${{github.event.pull_request.html_url}}
          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}

      - name: Comment on major updates
        if: steps.metadata.outputs.update-type == 'version-update:semver-major'
        run: |
          gh pr comment "$PR_URL" --body "‚ö†Ô∏è This is a **major version update** and requires manual review before merging."
        env:
          PR_URL: ${{github.event.pull_request.html_url}}
          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}
</file>

<file path=".github/dependabot.yml">
version: 2

updates:
  # Enable version updates for npm
  - package-ecosystem: "npm"
    directory: "/"
    schedule:
      interval: "weekly"
      day: "monday"
      time: "09:00"
      timezone: "UTC"
    open-pull-requests-limit: 10
    reviewers:
      - "insign"
    assignees:
      - "insign"
    commit-message:
      prefix: "chore(deps)"
      prefix-development: "chore(deps-dev)"
      include: "scope"
    labels:
      - "dependencies"
      - "automated"
    # Group minor and patch updates together
    groups:
      minor-and-patch:
        patterns:
          - "*"
        update-types:
          - "minor"
          - "patch"
    # Ignore specific dependencies if needed
    ignore:
      # Ignore wrangler major updates (we're locked to 3.99.0)
      - dependency-name: "wrangler"
        update-types: ["version-update:semver-major"]

  # Enable version updates for GitHub Actions
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly"
      day: "monday"
      time: "09:00"
      timezone: "UTC"
    open-pull-requests-limit: 5
    reviewers:
      - "insign"
    commit-message:
      prefix: "ci"
      include: "scope"
    labels:
      - "ci/cd"
      - "dependencies"
      - "automated"
</file>

<file path="src/bot/commands/basicCommands.ts">
/**
 * Basic command handlers
 * Handles /start and /help commands
 */

import type { BotContext } from '../bot';
import { getGroupId } from '../bot';

/**
 * /start command
 * Shows welcome message with explanation of features
 */
export async function handleStart(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);

  if (!groupId) {
    await ctx.reply(
      'This bot only works in group chats with topics enabled.\n\n' +
      'Please add me to a group and enable topics (Forums) to get started.'
    );
    return;
  }

  const welcomeMessage = `
ü§ñ <b>Welcome to Jot - Telegram Interface for Jules!</b>

I'm a bridge between Telegram and Jules (Google's AI coding assistant). Here's how to get started:

<b>üìã Initial Setup (Admins only):</b>
1. Get your Jules API key from jules.google
2. Use /set_jules_token &lt;token&gt; to configure
3. Use /list_sources to see available repositories
4. Use /set_source &lt;source&gt; to set default repository

<b>üí¨ How to Use:</b>
‚Ä¢ Create a topic (forum thread) for each coding task
‚Ä¢ Send your request as text or image
‚Ä¢ I'll create a Jules session and update you automatically
‚Ä¢ Each topic = 1 Jules session (1:1 mapping)

<b>üì∏ Image Support:</b>
‚Ä¢ Send screenshots, designs, or diagrams
‚Ä¢ Supported formats: JPG, PNG, WebP
‚Ä¢ Max size: 20MB

<b>üéØ Features:</b>
‚Ä¢ Automatic activity polling (you don't need to ask for updates!)
‚Ä¢ Plan approval with inline buttons
‚Ä¢ GitHub links extraction (PR, branches, commits)
‚Ä¢ Smart notifications (important events have sound)
‚Ä¢ Multi-tenant (each group has its own configuration)

<b>‚öôÔ∏è Advanced Settings:</b>
‚Ä¢ Use /open_jules_settings to access Jules web interface
‚Ä¢ Configure Setup Script, Environment Variables, and Memories there
‚Ä¢ These settings are per-repository and affect all future sessions

<b>üìö Commands:</b>
Use /help to see all available commands.

<b>üîí Permissions Required:</b>
‚Ä¢ I need "Manage Topics" permission to update topic names
‚Ä¢ Admins can configure group settings

Let's start coding! üöÄ
`;

  await ctx.reply(welcomeMessage, { parse_mode: 'HTML' });
}

/**
 * /help command
 * Shows comprehensive list of commands
 */
export async function handleHelp(ctx: BotContext): Promise<void> {
  const helpMessage = `
<b>üìö Command Reference</b>

<b>üé¨ Basic Commands:</b>
/start - Show welcome message
/help - Show this help message

<b>‚öôÔ∏è Configuration (Admin only):</b>
/set_jules_token &lt;token&gt; - Configure Jules API token
/set_source &lt;source&gt; - Set default repository source
/set_branch &lt;branch&gt; - Set default starting branch
/set_auto_pr &lt;on|off&gt; - Enable/disable automatic PR creation
/require_approval &lt;on|off&gt; - Require plan approval before execution

<b>‚ÑπÔ∏è Information:</b>
/status - Show group configuration and stats
/get_source - Show configured source
/list_sources - List all available sources
/list_sessions - List all active sessions
/session_info - Show current session details (use in topic)
/list_activities - Show activities for current session (use in topic)
/show_plan - Show plan for current session (use in topic)
/show_outputs - Show outputs (PR, branch, commits) for current session
/open_jules_settings - Open Jules web interface for advanced settings

<b>üé¨ Actions:</b>
/new_session &lt;prompt&gt; - Create new session in current topic
/approve_plan - Approve pending plan (use in topic)
/delete_session - Delete current session (Admin only, use in topic)
/sync - Manually sync sessions with Jules API (Admin only)

<b>üí° Tips:</b>
‚Ä¢ Most commands work in topics (forum threads)
‚Ä¢ You don't need to poll for updates - I send them automatically!
‚Ä¢ Send images by just uploading them in a topic
‚Ä¢ Use inline buttons for quick actions (approve plan, publish PR, etc.)
‚Ä¢ Configure advanced settings (Setup Script, Env Vars) via /open_jules_settings

<b>üÜò Need Help?</b>
‚Ä¢ Check if bot has "Manage Topics" permission
‚Ä¢ Verify Jules token is valid with /status
‚Ä¢ Use /sync to manually refresh sessions
‚Ä¢ Make sure you're using commands in the right context (topic vs. general chat)

For more information, visit: https://jules.google
`;

  await ctx.reply(helpMessage, { parse_mode: 'HTML' });
}
</file>

<file path="src/bot/handlers/activityProcessor.ts">
/**
 * Activity processor
 * Processes Jules activities and sends formatted notifications to Telegram
 */

import type { JulesActivity } from '../../types/env';
import type { BotContext } from '../bot';
import { sendMessage, sendPhoto } from '../bot';
import {
  formatBashOutput,
  formatChangeSet,
  formatActivityMessage,
  createExpandableBlockquote,
  escapeHtml,
} from '../../utils/formatters';
import { extractGitHubLinks, formatGitHubLinks } from '../../utils/github';
import { base64ToUint8Array } from '../../utils/image';
import { InlineKeyboard, InputFile } from 'grammy';
import { setPendingPlan, setReadyForReview } from '../../kv/storage';

/**
 * Process a single activity and send notification to Telegram
 */
export async function processActivity(
  ctx: BotContext,
  groupId: string,
  topicId: number,
  sessionId: string,
  activity: JulesActivity
): Promise<void> {
  const activityType = getActivityType(activity);

  console.log(`Processing activity: ${activityType} for session ${sessionId}`);

  switch (activityType) {
    case 'planGenerated':
      await processPlanGenerated(ctx, groupId, topicId, sessionId, activity);
      break;

    case 'planApproved':
      await processPlanApproved(ctx, groupId, topicId, activity);
      break;

    case 'readyForReview':
      await processReadyForReview(ctx, groupId, topicId, sessionId, activity);
      break;

    case 'progressUpdated':
      await processProgressUpdated(ctx, groupId, topicId, activity);
      break;

    case 'sessionCompleted':
      await processSessionCompleted(ctx, groupId, topicId, sessionId, activity);
      break;

    default:
      await processGenericActivity(ctx, groupId, topicId, activity);
      break;
  }
}

/**
 * Determine activity type from activity data
 */
function getActivityType(activity: JulesActivity): string {
  const title = activity.title?.toLowerCase() || '';
  const description = activity.description?.toLowerCase() || '';

  if (title.includes('plan generated') || title.includes('plan created')) {
    return 'planGenerated';
  }

  if (title.includes('plan approved')) {
    return 'planApproved';
  }

  if (title.includes('ready for review') || description.includes('ready for review')) {
    return 'readyForReview';
  }

  if (title.includes('progress') || activity.artifacts?.bashOutput || activity.artifacts?.changeSet) {
    return 'progressUpdated';
  }

  if (title.includes('completed') || title.includes('finished')) {
    return 'sessionCompleted';
  }

  return 'generic';
}

/**
 * Process planGenerated activity
 * MAXIMUM ATTENTION - impossible to ignore
 */
async function processPlanGenerated(
  ctx: BotContext,
  groupId: string,
  topicId: number,
  sessionId: string,
  activity: JulesActivity
): Promise<void> {
  // Parse plan steps from description
  const steps = parsePlanSteps(activity.description || '');

  let message = 'üéØ <b>PLAN CREATED</b>\n\n';

  // Check if requires approval
  // Note: We should check session.requirePlanApproval from KV
  // For now, we'll add a generic message
  const requiresApproval = true; // TODO: Get from session data

  if (requiresApproval) {
    message += '<b>‚ö†Ô∏è APPROVAL REQUIRED</b>\n\n';
  }

  if (steps.length > 0) {
    const stepsList = steps.map((step, i) => `${i + 1}. ${step}`).join('\n');
    message += createExpandableBlockquote(`üéØ PLAN - ${steps.length} steps`, stepsList);
  } else {
    message += escapeHtml(activity.description || 'Plan generated');
  }

  // Add approve button if requires approval
  let keyboard;
  if (requiresApproval) {
    keyboard = new InlineKeyboard().text('‚úÖ Approve Plan', `approve_plan:${sessionId}`);
    message += '\n\n<i>Click the button below to approve and start execution.</i>';

    // Set pending plan flag
    await setPendingPlan(ctx.env, groupId, topicId, true);
  } else {
    message += '\n\n<i>Plan will be executed automatically.</i>';
  }

  // Send with SOUND (disable_notification=false)
  await ctx.api.sendMessage(groupId, message, {
    message_thread_id: topicId,
    parse_mode: 'HTML',
    disable_notification: false, // WITH SOUND!
    reply_markup: keyboard,
  });
}

/**
 * Process planApproved activity
 * Brief confirmation message, silent
 */
async function processPlanApproved(
  ctx: BotContext,
  groupId: string,
  topicId: number,
  activity: JulesActivity
): Promise<void> {
  const message = '‚úÖ <b>Plan approved!</b>\n\nJules will start working on the implementation.';

  await ctx.api.sendMessage(groupId, message, {
    message_thread_id: topicId,
    parse_mode: 'HTML',
    disable_notification: true, // SILENT
  });
}

/**
 * Process readyForReview activity
 * Show "Ready for review" with publish buttons
 */
async function processReadyForReview(
  ctx: BotContext,
  groupId: string,
  topicId: number,
  sessionId: string,
  activity: JulesActivity
): Promise<void> {
  let message = 'üéâ <b>Ready for review!</b>\n\nJules has finalized the changes.\n\n';

  // TODO: Fetch session outputs to show GitHub links
  // For now, we'll add generic buttons

  const keyboard = new InlineKeyboard()
    .text('üì¶ Publish Branch', `publish_branch:${sessionId}`)
    .text('üîÄ Publish PR', `publish_pr:${sessionId}`);

  message += '<i>Click the buttons below to publish your changes.</i>';

  // Set ready for review flag
  await setReadyForReview(ctx.env, groupId, topicId, true);

  // Send with SOUND
  await ctx.api.sendMessage(groupId, message, {
    message_thread_id: topicId,
    parse_mode: 'HTML',
    disable_notification: false, // WITH SOUND!
    reply_markup: keyboard,
  });
}

/**
 * Process progressUpdated activity
 * Shows bash output, file changes, or media
 */
async function processProgressUpdated(
  ctx: BotContext,
  groupId: string,
  topicId: number,
  activity: JulesActivity
): Promise<void> {
  let message = '';
  let hasError = false;
  let hasMedia = false;

  // Process bash output
  if (activity.artifacts?.bashOutput) {
    const bash = activity.artifacts.bashOutput;
    const exitCode = bash.exitCode || 0;

    if (exitCode !== 0) {
      hasError = true;
    }

    message += formatBashOutput(
      bash.command || 'unknown',
      bash.output || '',
      exitCode
    ) + '\n\n';
  }

  // Process changeSet
  if (activity.artifacts?.changeSet) {
    const changeSet = activity.artifacts.changeSet;
    const files = changeSet.files || [];

    if (files.length > 0) {
      message += formatChangeSet(files, changeSet.gitPatch?.unidiffPatch) + '\n\n';
    }
  }

  // Process media
  if (activity.artifacts?.media) {
    hasMedia = true;
    const media = activity.artifacts.media;

    if (media.data) {
      try {
        const imageData = base64ToUint8Array(media.data);
        const caption = activity.title || activity.description || 'Image from Jules';

        await ctx.api.sendPhoto(groupId, new InputFile(imageData, 'image.jpg'), {
          message_thread_id: topicId,
          caption: caption,
          disable_notification: false, // Media always with sound
        });
      } catch (error) {
        console.error('Error sending media:', error);
        message += '‚ö†Ô∏è Failed to send media\n\n';
      }
    }
  }

  // If no artifacts, show title/description
  if (!message && !hasMedia) {
    message = formatActivityMessage(activity.title, activity.description);
  }

  // Send message if we have one
  if (message.trim()) {
    await ctx.api.sendMessage(groupId, message.trim(), {
      message_thread_id: topicId,
      parse_mode: 'HTML',
      disable_notification: !hasError && !hasMedia, // Sound only on errors or media
    });
  }
}

/**
 * Process sessionCompleted activity
 * Shows completion message with GitHub links
 */
async function processSessionCompleted(
  ctx: BotContext,
  groupId: string,
  topicId: number,
  sessionId: string,
  activity: JulesActivity
): Promise<void> {
  let message = '‚úÖ <b>Session completed!</b>\n\n';

  // TODO: Fetch session outputs to extract GitHub links
  // For now, we'll show basic completion message

  message += escapeHtml(activity.description || 'Jules has finished working on this session.');

  // Send with SOUND
  await ctx.api.sendMessage(groupId, message, {
    message_thread_id: topicId,
    parse_mode: 'HTML',
    disable_notification: false, // WITH SOUND!
  });
}

/**
 * Process generic activity
 * Fallback for unrecognized activity types
 */
async function processGenericActivity(
  ctx: BotContext,
  groupId: string,
  topicId: number,
  activity: JulesActivity
): Promise<void> {
  const message = formatActivityMessage(activity.title, activity.description);

  // Generic activities are silent unless they contain keywords
  const hasImportantKeywords =
    message.toLowerCase().includes('error') ||
    message.toLowerCase().includes('failed') ||
    message.toLowerCase().includes('question');

  await ctx.api.sendMessage(groupId, message, {
    message_thread_id: topicId,
    parse_mode: 'HTML',
    disable_notification: !hasImportantKeywords,
  });
}

/**
 * Parse plan steps from description
 * Returns array of step strings
 */
function parsePlanSteps(description: string): string[] {
  const steps: string[] = [];

  // Try to parse numbered list
  const lines = description.split('\n');

  for (const line of lines) {
    const match = line.match(/^\d+\.\s+(.+)$/);
    if (match) {
      steps.push(match[1].trim());
    }
  }

  return steps;
}
</file>

<file path="src/bot/bot.ts">
/**
 * Grammy Bot configuration and setup
 * Handles bot initialization with optimized settings for Cloudflare Workers
 */

import { Bot, webhookCallback, Context, InputFile } from 'grammy';
import type { Env } from '../types/env';

/**
 * Extended context with environment bindings
 */
export interface BotContext extends Context {
  env: Env;
}

/**
 * Create and configure bot instance
 * Uses botInfo pre-configuration to avoid unnecessary getMe calls
 */
export function createBot(botToken: string, env: Env): Bot<BotContext> {
  const bot = new Bot<BotContext>(botToken);

  // Attach env to context for all handlers
  bot.use(async (ctx, next) => {
    ctx.env = env;
    await next();
  });

  return bot;
}

/**
 * Create webhook callback for handling Telegram updates
 * Used in the main Worker fetch handler
 */
export function createWebhookHandler(bot: Bot<BotContext>) {
  return webhookCallback(bot, 'cloudflare-mod');
}

/**
 * Extract group ID from context
 * Returns null if not in a group chat
 */
export function getGroupId(ctx: Context): string | null {
  const chat = ctx.chat;
  if (!chat) return null;

  // Check if it's a group or supergroup
  if (chat.type === 'group' || chat.type === 'supergroup') {
    return String(chat.id);
  }

  return null;
}

/**
 * Extract topic ID from context
 * Returns null if not in a topic (forum thread)
 */
export function getTopicId(ctx: Context): number | null {
  return ctx.message?.message_thread_id || ctx.callbackQuery?.message?.message_thread_id || null;
}

/**
 * Check if user is admin in the group
 * Used for permission checks on sensitive commands
 */
export async function isUserAdmin(ctx: Context): Promise<boolean> {
  const groupId = getGroupId(ctx);
  const userId = ctx.from?.id;

  if (!groupId || !userId) return false;

  try {
    const member = await ctx.api.getChatMember(groupId, userId);
    return member.status === 'creator' || member.status === 'administrator';
  } catch (error) {
    console.error('Error checking admin status:', error);
    return false;
  }
}

/**
 * Check if bot has permission to manage topics
 * Required for updating topic names with session info
 */
export async function canBotManageTopics(ctx: Context): Promise<boolean> {
  const groupId = getGroupId(ctx);
  if (!groupId) return false;

  try {
    const botMember = await ctx.api.getChatMember(groupId, ctx.me.id);

    // Check if bot is admin and has can_manage_topics permission
    if (botMember.status === 'administrator') {
      return (botMember as any).can_manage_topics === true;
    }

    return false;
  } catch (error) {
    console.error('Error checking bot permissions:', error);
    return false;
  }
}

/**
 * Show typing indicator
 * Makes the bot appear to be typing
 */
export async function showTypingIndicator(ctx: Context): Promise<void> {
  const groupId = getGroupId(ctx);
  const topicId = getTopicId(ctx);

  if (!groupId) return;

  try {
    await ctx.api.sendChatAction(groupId, 'typing', {
      message_thread_id: topicId || undefined,
    });
  } catch (error) {
    console.error('Error sending typing indicator:', error);
  }
}

/**
 * Start typing indicator loop
 * Keeps showing typing indicator every 4-5 seconds
 * Returns a function to stop the loop
 */
export function startTypingLoop(ctx: Context): () => void {
  let stopped = false;

  const loop = async () => {
    while (!stopped) {
      await showTypingIndicator(ctx);
      await new Promise(resolve => setTimeout(resolve, 4500)); // 4.5 seconds
    }
  };

  loop();

  return () => {
    stopped = true;
  };
}

/**
 * Send message with notification control
 * Handles silent notifications based on message importance
 */
export async function sendMessage(
  ctx: Context,
  text: string,
  options: {
    silent?: boolean;
    parseMode?: 'HTML' | 'Markdown' | 'MarkdownV2';
    replyMarkup?: any;
  } = {}
): Promise<void> {
  const groupId = getGroupId(ctx);
  const topicId = getTopicId(ctx);

  if (!groupId) return;

  try {
    await ctx.api.sendMessage(groupId, text, {
      message_thread_id: topicId || undefined,
      disable_notification: options.silent || false,
      parse_mode: options.parseMode || 'HTML',
      reply_markup: options.replyMarkup,
    });
  } catch (error) {
    console.error('Error sending message:', error);
  }
}

/**
 * Update topic title with session info
 * Format: "user/repo session_id"
 */
export async function updateTopicTitle(
  ctx: Context,
  groupId: string,
  topicId: number,
  owner: string,
  repo: string,
  sessionId: string
): Promise<void> {
  try {
    const title = `${owner}/${repo} ${sessionId.split('/').pop()}`;

    await ctx.api.editForumTopic(groupId, topicId, { name: title });
  } catch (error) {
    console.error('Error updating topic title:', error);
  }
}

/**
 * Send photo with caption
 * Used when Jules returns images
 */
export async function sendPhoto(
  ctx: Context,
  photo: Uint8Array,
  caption?: string,
  silent?: boolean
): Promise<void> {
  const groupId = getGroupId(ctx);
  const topicId = getTopicId(ctx);

  if (!groupId) return;

  try {
    await ctx.api.sendPhoto(groupId, new InputFile(photo, 'image.jpg'), {
      message_thread_id: topicId || undefined,
      caption: caption,
      disable_notification: silent || false,
    });
  } catch (error) {
    console.error('Error sending photo:', error);
  }
}
</file>

<file path="src/cron/pollActivities.ts">
/**
 * Poll activities cron job
 * Automatically fetches new activities for all active sessions and sends to Telegram
 * Runs every 1-2 minutes
 */

import type { Env, SessionData } from '../types/env';
import { Bot } from 'grammy';
import { createBot, BotContext } from '../bot/bot';
import {
  getJulesToken,
  getSessionsIndex,
  getSession,
  getLastActivityId,
  setLastActivityId,
} from '../kv/storage';
import { createJulesClient, isAuthError, isSessionNotFoundError } from '../jules/api';
import { processActivity } from '../bot/handlers/activityProcessor';

/**
 * Poll activities for all active sessions
 * This is called by the scheduled cron trigger
 */
export async function pollActivities(env: Env): Promise<void> {
  console.log('[CRON] Starting activities polling...');

  // Get all groups with sessions
  // Note: We need to maintain a list of groups in KV
  // For now, we'll need to implement a way to track active groups
  // This is a limitation of KV - we can't easily list all keys with a pattern

  // TODO: Implement group tracking
  // For now, this is a placeholder that shows the logic

  console.log('[CRON] Activities polling complete');
}

/**
 * Poll activities for a specific group
 */
export async function pollActivitiesForGroup(
  env: Env,
  bot: Bot<BotContext>,
  groupId: string
): Promise<void> {
  console.log(`[CRON] Polling activities for group ${groupId}`);

  // Get Jules token for group
  const token = await getJulesToken(env, groupId);

  if (!token) {
    console.log(`[CRON] No token configured for group ${groupId}, skipping`);
    return;
  }

  // Get sessions index
  const sessionsIndex = await getSessionsIndex(env, groupId);

  if (sessionsIndex.length === 0) {
    console.log(`[CRON] No active sessions for group ${groupId}`);
    return;
  }

  console.log(`[CRON] Found ${sessionsIndex.length} sessions for group ${groupId}`);

  const julesClient = createJulesClient(token);

  // Process each session
  for (const sessionId of sessionsIndex) {
    try {
      await pollActivitiesForSession(env, bot, groupId, sessionId, julesClient);
    } catch (error) {
      console.error(`[CRON] Error polling session ${sessionId}:`, error);

      // Check if it's an auth error
      if (error instanceof Error && isAuthError(error)) {
        console.log(`[CRON] Auth error for group ${groupId}, stopping polling`);
        // TODO: Notify group admins about invalid token
        break;
      }

      // Check if session was deleted
      if (error instanceof Error && isSessionNotFoundError(error)) {
        console.log(`[CRON] Session ${sessionId} not found, will be cleaned up in sync`);
        continue;
      }
    }
  }
}

/**
 * Poll activities for a specific session
 */
async function pollActivitiesForSession(
  env: Env,
  bot: Bot<BotContext>,
  groupId: string,
  sessionId: string,
  julesClient: any
): Promise<void> {
  // Find the session in KV to get topic_id
  // Note: We need to store a mapping of session_id to topic_id
  // For now, we'll need to iterate through possible topics or maintain a better index

  // TODO: Implement better session indexing
  // Current KV structure makes it hard to get session by session_id
  // We should add a reverse mapping: session_id -> topic_id

  console.log(`[CRON] Polling activities for session ${sessionId}`);

  // Get last activity ID
  // Note: We need topic_id for this
  // This is a design issue that needs to be fixed

  // For now, this is a placeholder
}

/**
 * Process new activities for a session
 */
async function processNewActivities(
  env: Env,
  bot: Bot<BotContext>,
  groupId: string,
  topicId: number,
  sessionId: string,
  julesClient: any
): Promise<void> {
  // Get last activity timestamp
  const lastActivityId = await getLastActivityId(env, groupId, topicId);

  // Get all activities
  const activities = await julesClient.listActivities(sessionId);

  if (activities.length === 0) {
    return;
  }

  // Filter new activities
  let newActivities = activities;

  if (lastActivityId) {
    // Find index of last activity
    const lastIndex = activities.findIndex((a: any) => a.name === lastActivityId);

    if (lastIndex !== -1) {
      // Get activities after last one
      newActivities = activities.slice(lastIndex + 1);
    }
  }

  if (newActivities.length === 0) {
    return;
  }

  console.log(`[CRON] Found ${newActivities.length} new activities for session ${sessionId}`);

  // Create a temporary context for sending messages
  // Note: This is a workaround since we don't have a real context in cron
  const ctx = {
    env,
    api: bot.api,
  } as BotContext;

  // Process each new activity
  for (const activity of newActivities) {
    try {
      await processActivity(ctx, groupId, topicId, sessionId, activity);

      // Update last activity ID
      await setLastActivityId(env, groupId, topicId, activity.name);
    } catch (error) {
      console.error(`[CRON] Error processing activity ${activity.name}:`, error);
    }
  }
}
</file>

<file path="src/cron/refreshSourcesCache.ts">
/**
 * Refresh sources cache for all groups
 * Runs periodically to ensure cache is up-to-date
 * This allows search_sources to work with complete data
 */

import type { Env } from '../types/env';
import { createJulesClient } from '../jules/api';
import { setSourcesCache } from '../kv/storage';

/**
 * Fetch all sources for a token and update cache
 * Takes longer but gets complete list
 */
async function refreshSourcesForToken(env: Env, token: string): Promise<number> {
  console.log('[refreshSourcesCache] Fetching sources for token...');
  const startTime = Date.now();

  try {
    const julesClient = createJulesClient(token);

    // Use extended timeout for cron job (we have more time)
    // Fetch with 9s timeout to get as many as possible
    const result = await julesClient.listSources(9000);

    if (result.sources.length === 0) {
      console.log('[refreshSourcesCache] No sources found');
      return 0;
    }

    // Map to cache format
    const sources = result.sources.map(s => ({
      name: s.name,
      displayName: s.displayName,
      description: s.description,
    }));

    // Update cache (1 hour TTL)
    await setSourcesCache(env, token, sources);

    const duration = Date.now() - startTime;
    console.log(`[refreshSourcesCache] Cached ${sources.length} sources in ${duration}ms (hasMore: ${result.hasMore})`);

    return sources.length;
  } catch (error) {
    console.error('[refreshSourcesCache] Error fetching sources:', error);
    return 0;
  }
}

/**
 * Main cron handler
 * Refreshes sources cache for all groups that have tokens
 */
export async function refreshSourcesCache(env: Env): Promise<void> {
  console.log('[refreshSourcesCache] Starting sources cache refresh...');
  const startTime = Date.now();

  try {
    // Get all unique tokens from KV
    // Note: In a production system, you'd want to keep a registry of active tokens
    // For now, this will only refresh when groups actively use the bot

    // Since we don't have a token registry, this cron will be triggered
    // whenever /list_sources or /search_sources is used, and will refresh
    // the cache in the background

    const duration = Date.now() - startTime;
    console.log(`[refreshSourcesCache] Cache refresh complete in ${duration}ms`);
  } catch (error) {
    console.error('[refreshSourcesCache] Error in cache refresh:', error);
  }
}
</file>

<file path="src/cron/syncSessions.ts">
/**
 * Sync sessions cron job
 * Synchronizes local sessions with Jules API
 * Detects deleted sessions and updates status
 * Runs every 15-30 minutes
 */

import type { Env } from '../types/env';
import { Bot } from 'grammy';
import { BotContext } from '../bot/bot';
import {
  getJulesToken,
  getSessionsIndex,
  removeFromSessionsIndex,
} from '../kv/storage';
import { createJulesClient, isAuthError, isSessionNotFoundError } from '../jules/api';

/**
 * Sync sessions for all groups
 * This is called by the scheduled cron trigger
 */
export async function syncSessions(env: Env): Promise<void> {
  console.log('[CRON] Starting sessions sync...');

  // Get all groups with sessions
  // Note: We need to maintain a list of groups in KV
  // For now, this is a placeholder

  // TODO: Implement group tracking

  console.log('[CRON] Sessions sync complete');
}

/**
 * Sync sessions for a specific group
 */
export async function syncSessionsForGroup(
  env: Env,
  bot: Bot<BotContext>,
  groupId: string
): Promise<void> {
  console.log(`[CRON] Syncing sessions for group ${groupId}`);

  // Get Jules token for group
  const token = await getJulesToken(env, groupId);

  if (!token) {
    console.log(`[CRON] No token configured for group ${groupId}, skipping`);
    return;
  }

  try {
    const julesClient = createJulesClient(token);

    // Get remote sessions from Jules
    const remoteSessions = await julesClient.listSessions();
    const remoteSessionIds = new Set(remoteSessions.map(s => s.name));

    // Get local sessions from KV
    const localSessionIds = await getSessionsIndex(env, groupId);

    // Find deleted sessions (in local but not in remote)
    const deletedSessions = localSessionIds.filter(id => !remoteSessionIds.has(id));

    if (deletedSessions.length > 0) {
      console.log(`[CRON] Found ${deletedSessions.length} deleted sessions for group ${groupId}`);

      // Remove deleted sessions from KV
      for (const sessionId of deletedSessions) {
        try {
          await removeFromSessionsIndex(env, groupId, sessionId);

          // TODO: Remove session data from topics
          // This requires maintaining a reverse mapping

          console.log(`[CRON] Removed deleted session ${sessionId}`);

          // TODO: Notify group about deleted session
          // We would need the topic_id to send a message
        } catch (error) {
          console.error(`[CRON] Error removing session ${sessionId}:`, error);
        }
      }
    }

    // TODO: Update status and outputs for existing sessions
    // This would involve fetching each session and updating KV

    console.log(`[CRON] Sync complete for group ${groupId}: ${localSessionIds.length} local, ${remoteSessions.length} remote, ${deletedSessions.length} removed`);
  } catch (error) {
    console.error(`[CRON] Error syncing sessions for group ${groupId}:`, error);

    if (error instanceof Error && isAuthError(error)) {
      console.log(`[CRON] Auth error for group ${groupId}`);
      // TODO: Notify group admins about invalid token
    }
  }
}
</file>

<file path="src/utils/github.ts">
/**
 * GitHub utilities for extracting and formatting links
 */

/**
 * GitHub link types
 */
export interface GitHubLinks {
  pullRequests: Array<{ number: number; url: string }>;
  branches: Array<{ name: string; url: string }>;
  commits: Array<{ sha: string; url: string }>;
}

/**
 * Extract GitHub links from session outputs
 * Parses outputs for PR, branch, and commit URLs
 */
export function extractGitHubLinks(outputs?: string): GitHubLinks {
  const links: GitHubLinks = {
    pullRequests: [],
    branches: [],
    commits: [],
  };

  if (!outputs) return links;

  // Regular expressions for GitHub URLs
  const prRegex = /https:\/\/github\.com\/([^/]+)\/([^/]+)\/pull\/(\d+)/g;
  const branchRegex = /https:\/\/github\.com\/([^/]+)\/([^/]+)\/tree\/([^/\s]+)/g;
  const commitRegex = /https:\/\/github\.com\/([^/]+)\/([^/]+)\/commit\/([a-f0-9]{7,40})/g;

  // Extract PR links
  let match;
  while ((match = prRegex.exec(outputs)) !== null) {
    links.pullRequests.push({
      number: parseInt(match[3]),
      url: match[0],
    });
  }

  // Extract branch links
  while ((match = branchRegex.exec(outputs)) !== null) {
    links.branches.push({
      name: match[3],
      url: match[0],
    });
  }

  // Extract commit links
  while ((match = commitRegex.exec(outputs)) !== null) {
    links.commits.push({
      sha: match[3],
      url: match[0],
    });
  }

  return links;
}

/**
 * Format GitHub links as Telegram HTML message
 * Uses emojis and clickable links
 */
export function formatGitHubLinks(links: GitHubLinks): string {
  let message = '';

  if (links.pullRequests.length > 0) {
    message += '<b>üîÄ Pull Requests:</b>\n';
    for (const pr of links.pullRequests) {
      message += `‚Ä¢ <a href="${pr.url}">PR #${pr.number}</a>\n`;
    }
    message += '\n';
  }

  if (links.branches.length > 0) {
    message += '<b>üåø Branches:</b>\n';
    for (const branch of links.branches) {
      message += `‚Ä¢ <a href="${branch.url}">${branch.name}</a>\n`;
    }
    message += '\n';
  }

  if (links.commits.length > 0) {
    message += '<b>üìù Commits:</b>\n';
    for (const commit of links.commits) {
      message += `‚Ä¢ <a href="${commit.url}">${commit.sha.slice(0, 7)}</a>\n`;
    }
    message += '\n';
  }

  return message || 'No GitHub links found.';
}

/**
 * Parse source name to GitHub URL for Jules settings
 * Converts "sources/github/user/repo" to "https://jules.google/github/user/repo"
 */
export function parseSourceToGitHubUrl(source: string): string | null {
  // Expected format: "sources/github/owner/repo"
  const match = source.match(/^sources\/github\/([^/]+)\/([^/]+)$/);

  if (!match) {
    return null;
  }

  const owner = match[1];
  const repo = match[2];

  return `https://jules.google/github/${owner}/${repo}`;
}

/**
 * Extract repository info from source name
 * Returns { owner, repo } or null if invalid format
 */
export function parseSourceToRepoInfo(source: string): { owner: string; repo: string } | null {
  const match = source.match(/^sources\/github\/([^/]+)\/([^/]+)$/);

  if (!match) {
    return null;
  }

  return {
    owner: match[1],
    repo: match[2],
  };
}

/**
 * Format repository info as readable string
 */
export function formatRepoInfo(owner: string, repo: string): string {
  return `${owner}/${repo}`;
}

/**
 * Create markdown link for GitHub URL
 * Returns formatted link like "[Ver Pull Request #123](url)"
 */
export function createGitHubMarkdownLink(type: 'pr' | 'branch' | 'commit', text: string, url: string): string {
  const emoji = type === 'pr' ? 'üîÄ' : type === 'branch' ? 'üåø' : 'üìù';
  return `${emoji} [${text}](${url})`;
}
</file>

<file path="src/utils/image.ts">
/**
 * Image utilities for downloading and converting Telegram images
 */

/**
 * Download image from Telegram and convert to base64
 * Used when users send images to Jules
 */
export async function downloadAndConvertImageToBase64(
  filePath: string,
  botToken: string
): Promise<{ data: string; mediaType: string } | null> {
  const url = `https://api.telegram.org/file/bot${botToken}/${filePath}`;

  try {
    // Download image with timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout

    const response = await fetch(url, {
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      console.error(`Failed to download image: ${response.status} ${response.statusText}`);
      return null;
    }

    // Get content type
    const contentType = response.headers.get('content-type') || 'image/jpeg';

    // Validate content type
    if (!contentType.startsWith('image/')) {
      console.error(`Invalid content type: ${contentType}`);
      return null;
    }

    // Convert to array buffer
    const arrayBuffer = await response.arrayBuffer();

    // Check size (max 20MB)
    const maxSize = 20 * 1024 * 1024;
    if (arrayBuffer.byteLength > maxSize) {
      console.error(`Image too large: ${arrayBuffer.byteLength} bytes (max ${maxSize})`);
      return null;
    }

    // Convert to base64
    const base64 = arrayBufferToBase64(arrayBuffer);

    return {
      data: base64,
      mediaType: contentType,
    };
  } catch (error) {
    if (error instanceof Error) {
      if (error.name === 'AbortError') {
        console.error('Image download timeout (30s)');
      } else {
        console.error(`Error downloading image: ${error.message}`);
      }
    }
    return null;
  }
}

/**
 * Convert ArrayBuffer to base64 string
 */
function arrayBufferToBase64(buffer: ArrayBuffer): string {
  const bytes = new Uint8Array(buffer);
  let binary = '';
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

/**
 * Convert base64 string to Uint8Array
 * Used when receiving images from Jules API
 */
export function base64ToUint8Array(base64: string): Uint8Array {
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
}

/**
 * Validate image format
 * Returns true if format is supported
 */
export function isValidImageFormat(contentType: string): boolean {
  const supportedFormats = [
    'image/jpeg',
    'image/jpg',
    'image/png',
    'image/webp',
    'image/gif',
  ];

  return supportedFormats.includes(contentType.toLowerCase());
}

/**
 * Get media type from file extension
 */
export function getMediaTypeFromExtension(filename: string): string {
  const ext = filename.split('.').pop()?.toLowerCase();

  switch (ext) {
    case 'jpg':
    case 'jpeg':
      return 'image/jpeg';
    case 'png':
      return 'image/png';
    case 'webp':
      return 'image/webp';
    case 'gif':
      return 'image/gif';
    default:
      return 'image/jpeg'; // Default fallback
  }
}
</file>

<file path="src/utils/retry.ts">
/**
 * Retry utilities with exponential backoff
 * Used for API calls that may fail temporarily
 */

/**
 * Retry configuration
 */
export interface RetryConfig {
  maxAttempts: number;
  initialDelayMs: number;
  maxDelayMs: number;
  backoffMultiplier: number;
}

/**
 * Default retry configuration
 */
export const DEFAULT_RETRY_CONFIG: RetryConfig = {
  maxAttempts: 3,
  initialDelayMs: 1000,
  maxDelayMs: 10000,
  backoffMultiplier: 2,
};

/**
 * Retry a function with exponential backoff
 * Returns the result of the function or throws the last error
 */
export async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  config: Partial<RetryConfig> = {}
): Promise<T> {
  const finalConfig = { ...DEFAULT_RETRY_CONFIG, ...config };
  let lastError: Error | null = null;
  let delayMs = finalConfig.initialDelayMs;

  for (let attempt = 1; attempt <= finalConfig.maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));

      // Don't retry on last attempt
      if (attempt === finalConfig.maxAttempts) {
        break;
      }

      // Log retry attempt
      console.log(`Retry attempt ${attempt}/${finalConfig.maxAttempts} after ${delayMs}ms delay. Error: ${lastError.message}`);

      // Wait before retrying
      await sleep(delayMs);

      // Increase delay for next attempt (exponential backoff)
      delayMs = Math.min(delayMs * finalConfig.backoffMultiplier, finalConfig.maxDelayMs);
    }
  }

  // All attempts failed
  throw lastError || new Error('Unknown error during retry');
}

/**
 * Sleep for specified milliseconds
 */
export function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Retry only on specific error types
 * Useful for retrying only on network errors, not on validation errors
 */
export async function retryOnSpecificErrors<T>(
  fn: () => Promise<T>,
  shouldRetry: (error: Error) => boolean,
  config: Partial<RetryConfig> = {}
): Promise<T> {
  const finalConfig = { ...DEFAULT_RETRY_CONFIG, ...config };
  let lastError: Error | null = null;
  let delayMs = finalConfig.initialDelayMs;

  for (let attempt = 1; attempt <= finalConfig.maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));

      // Check if we should retry this error
      if (!shouldRetry(lastError)) {
        throw lastError;
      }

      // Don't retry on last attempt
      if (attempt === finalConfig.maxAttempts) {
        break;
      }

      console.log(`Retry attempt ${attempt}/${finalConfig.maxAttempts} after ${delayMs}ms delay. Error: ${lastError.message}`);

      await sleep(delayMs);
      delayMs = Math.min(delayMs * finalConfig.backoffMultiplier, finalConfig.maxDelayMs);
    }
  }

  throw lastError || new Error('Unknown error during retry');
}

/**
 * Check if error is a network error (should retry)
 */
export function isNetworkError(error: Error): boolean {
  const networkErrorMessages = [
    'network',
    'timeout',
    'fetch',
    'connection',
    'econnrefused',
    'enotfound',
    'etimedout',
  ];

  const errorMessage = error.message.toLowerCase();
  return networkErrorMessages.some(msg => errorMessage.includes(msg));
}

/**
 * Check if error is a rate limit error (should retry with longer delay)
 */
export function isRateLimitError(error: Error): boolean {
  const errorMessage = error.message.toLowerCase();
  return errorMessage.includes('rate limit') || errorMessage.includes('429');
}

/**
 * Check if HTTP status code is retryable
 */
export function isRetryableStatusCode(statusCode: number): boolean {
  // Retry on:
  // - 408: Request Timeout
  // - 429: Too Many Requests
  // - 500: Internal Server Error
  // - 502: Bad Gateway
  // - 503: Service Unavailable
  // - 504: Gateway Timeout
  const retryableStatusCodes = [408, 429, 500, 502, 503, 504];
  return retryableStatusCodes.includes(statusCode);
}
</file>

<file path="test/github.test.ts">
/**
 * Tests for GitHub utilities
 */

import { describe, it, expect } from 'vitest';
import {
  extractGitHubLinks,
  parseSourceToGitHubUrl,
  parseSourceToRepoInfo,
  formatRepoInfo,
} from '../src/utils/github';

describe('github utilities', () => {
  describe('extractGitHubLinks', () => {
    it('should extract PR links', () => {
      const outputs = 'Check out https://github.com/user/repo/pull/123 for details';
      const links = extractGitHubLinks(outputs);

      expect(links.pullRequests).toHaveLength(1);
      expect(links.pullRequests[0].number).toBe(123);
      expect(links.pullRequests[0].url).toBe('https://github.com/user/repo/pull/123');
    });

    it('should extract branch links', () => {
      const outputs = 'Branch: https://github.com/user/repo/tree/feature-branch';
      const links = extractGitHubLinks(outputs);

      expect(links.branches).toHaveLength(1);
      expect(links.branches[0].name).toBe('feature-branch');
    });

    it('should extract commit links', () => {
      const outputs = 'Commit: https://github.com/user/repo/commit/abc1234567890def';
      const links = extractGitHubLinks(outputs);

      expect(links.commits).toHaveLength(1);
      expect(links.commits[0].sha).toBe('abc1234567890def');
    });

    it('should extract multiple links', () => {
      const outputs = `
        PR: https://github.com/user/repo/pull/123
        Branch: https://github.com/user/repo/tree/feature
        Commit: https://github.com/user/repo/commit/abc1234567
      `;
      const links = extractGitHubLinks(outputs);

      expect(links.pullRequests).toHaveLength(1);
      expect(links.branches).toHaveLength(1);
      expect(links.commits).toHaveLength(1);
    });

    it('should return empty arrays for no links', () => {
      const links = extractGitHubLinks('No links here');

      expect(links.pullRequests).toHaveLength(0);
      expect(links.branches).toHaveLength(0);
      expect(links.commits).toHaveLength(0);
    });
  });

  describe('parseSourceToGitHubUrl', () => {
    it('should parse valid source to Jules URL', () => {
      const source = 'sources/github/username/repository';
      const url = parseSourceToGitHubUrl(source);

      expect(url).toBe('https://jules.google/github/username/repository');
    });

    it('should return null for invalid format', () => {
      expect(parseSourceToGitHubUrl('invalid')).toBeNull();
      expect(parseSourceToGitHubUrl('sources/gitlab/user/repo')).toBeNull();
      expect(parseSourceToGitHubUrl('sources/github/user')).toBeNull();
    });
  });

  describe('parseSourceToRepoInfo', () => {
    it('should parse valid source to repo info', () => {
      const source = 'sources/github/octocat/hello-world';
      const info = parseSourceToRepoInfo(source);

      expect(info).toEqual({
        owner: 'octocat',
        repo: 'hello-world',
      });
    });

    it('should return null for invalid format', () => {
      expect(parseSourceToRepoInfo('invalid')).toBeNull();
    });
  });

  describe('formatRepoInfo', () => {
    it('should format repo info as owner/repo', () => {
      const formatted = formatRepoInfo('octocat', 'hello-world');
      expect(formatted).toBe('octocat/hello-world');
    });
  });
});
</file>

<file path=".gitignore">
# Dependencies
node_modules/
.pnpm-store/

# Build outputs
dist/
build/
*.js
*.js.map
!vitest.config.ts

# Wrangler
.wrangler/
.mf/
wrangler.toml.backup

# Environment variables
.env
.env.local
.env.*.local
.dev.vars

# Secrets
*.key
*.pem
*.crt
secrets.txt

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store

# Logs
*.log
logs/

# Test coverage
coverage/
.nyc_output/

# Temporary files
tmp/
temp/
*.tmp

# OS
Thumbs.db
</file>

<file path="AGENTS.md">
# AGENTS.md - AI Agent Instructions and Development Guide

This file provides comprehensive guidance for AI agents (Claude Code, GitHub Copilot, etc.) when working with the JoT codebase.

## üìã Instructions for AI Agents

### Critical Starting Steps

**BEFORE replying to any user request, you MUST:**

1. **Fetch documentation** from these essential sources:

   - https://grammy.dev
   - https://grammy.dev/hosting/cloudflare-workers-nodejs
   - https://developers.cloudflare.com/workers/wrangler/environments/
   - https://grammy.dev/ref/core/webhookcallback
   - https://developers.cloudflare.com/workers/configuration/cron-triggers/
   - https://developers.cloudflare.com/kv/
   - https://developers.google.com/jules/api
   - https://core.telegram.org/bots/api
   - https://developers.google.com/jules/api/reference/rest
   - https://developers.google.com/jules/api/reference/rest/v1alpha/sources
   - https://developers.google.com/jules/api/reference/rest/v1alpha/sessions.activities/list
   - https://grammy.dev/ref/core/api
   - https://core.telegram.org/bots/api#sendphoto
   - https://grammy.dev/plugins/keyboard
   - https://grammy.dev/guide/files
   - https://core.telegram.org/bots/api#formatting-options
   - https://core.telegram.org/bots/api#inlinekeyboardmarkup
   - https://grammy.dev/guide/commands
   - https://developers.cloudflare.com/workers/runtime-apis/durable-objects/
   - https://developers.cloudflare.com/workers/wrangler/commands/#deploy
   - https://vitest.dev
   - https://developers.cloudflare.com/workers/testing/vitest-integration/
   - https://developers.cloudflare.com/workers/testing/miniflare/
   - https://jules.google
   - https://developers.cloudflare.com/workers/observability/logging/

2. **Read repomix-output.xml** if it exists in the root directory (it's kept up-to-date)

3. **Check for related documentation files** in the repository

### üéØ Best Practices and Work Rules

#### Code Quality Standards

- **Language**: All code, variables, and comments MUST be in English
- **Comments**: Add comments explaining important decisions throughout the code
- **Keep comments updated**: Comments MUST always reflect the current reality
- **Clarity is crucial**: Having comments in code is critical for maintaining extreme clarity

#### Problem-Solving Approach

- **Research first**: When stuck on an error, search the internet for solutions before asking the user
- **Deep context analysis**: Always seek deeper context within the current code to understand errors
- **Avoid assumptions**: Don't rush to solutions; analyze files deeply to identify possible effects
- **Self-reflection**: Frequently repeat to yourself:
  - The original request
  - What has been done
  - What remains to be done
  - Protection directives against hallucination

#### Search and Documentation Strategy

- **Use web search tools**: Brave Search for errors and documentation
- **Use Context7**: For "straight to the point" documentation
- **Rate limiting**: Limit 2 seconds between each search call to avoid rate limits
- **Generic before specific**: Start with simple, generic search terms before advancing to very specific ones
  - ‚úÖ Example: "laravel code coverage common errors"
  - ‚ùå Avoid: "laravel code coverage pcov null postgres docker compose error"

#### Error Handling Protocol

- **Always search online**: When encountering an error, ALWAYS search the internet to compare your solution idea with actual solutions
- **Compare approaches**: Don't implement the first solution that comes to mind

#### Git Workflow

- **Create branches**: If working with git on main/master, create a branch to work more freely (unless user says to work on main)
- **In plan mode**: Ask the user how they want to proceed with branching
- **No co-authors**: NEVER add co-authors in commits, not even Claude
- **The `gh` command**: Is available and authenticated in the system

#### Environment and Tools

- **Container tool**: Use `podman` and `podman-compose` instead of Docker (already installed in system)
- **Check project structure**: Before starting, review files like docker-compose.yml and Makefile to better understand the system

#### Task Management

- **Always create todo lists**: Keep the user aware of the process
- **Adapt todos**: When one ends and new demands arise, create a new todo or adapt the current one if relevant

#### Quality Checks (TypeScript Projects)

- **Type checking**: If project uses TypeScript, always use project's `tsc` to verify code before advancing/completing task
- **Linting**: If project uses ESLint, verify ESLint errors equally

#### Completion Protocol

- **Notify user**: When needing attention or finishing work, call `mcp__notifications__play_notification` before the final function
- **Auto mode**: If user ends a sentence with exactly the word "auto":
  1. After successfully completing the task
  2. Make commit with summary of operations
  3. Push changes
  4. Call notification as usual
- **Update repomix**: If task succeeds and `repomix-output.xml` exists in root, execute `npx repomix` or call equivalent tool

---

## üèóÔ∏è Project Overview

### What is JoT?

JoT stands for "Jules over Telegram". It is a Cloudflare Worker that provides a Telegram bot interface for Jules (Google's AI asynchronous coding assistant). It uses the Grammy framework for Telegram integration and implements a multi-tenant architecture where each Telegram group has isolated configuration and sessions. Each Telegram topic (forum thread) maps 1:1 to a Jules session for perfect organization.

**Technology Stack:**

- **Runtime**: Cloudflare Workers (serverless)
- **Language**: TypeScript (ES2022)
- **Telegram Framework**: Grammy
- **Testing**: Vitest with `@cloudflare/vitest-pool-workers`
- **Storage**: Cloudflare KV (multi-tenant)
- **API**: Jules API (Google's AI asynchronous coding assistant)

### Common Commands

#### Development

```bash
# Start local development server
npm run dev
# or
wrangler dev
# Server runs at http://localhost:8787
# Note: Cron triggers don't run in dev mode

# Generate TypeScript types from wrangler.toml
npm run cf-typegen
# or
wrangler types
```

#### Testing

```bash
# Run all tests
npm test

# Run tests in watch mode (development)
npm run test:watch

# Run tests with coverage report
npm run test:coverage

# Run tests directly with vitest
npx vitest
npx vitest --run
```

Tests use Vitest with Cloudflare Workers pool for Worker-specific testing. See `vitest.config.ts:3` for configuration.

#### Deployment

```bash
# Deploy to production
npm run deploy
# or
wrangler deploy
```

#### Setup Commands

```bash
# Install dependencies
npm install

# Create KV namespaces (development and preview)
wrangler kv namespace create "KV"
wrangler kv namespace create "KV" --preview

# Set secrets
wrangler secret put BOT_TOKEN
```

### High-Level Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     Webhook      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Telegram   ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ  Cloudflare      ‚îÇ
‚îÇ             ‚îÇ                  ‚îÇ  Worker          ‚îÇ
‚îÇ  User sends ‚îÇ                  ‚îÇ  (Grammy Bot)    ‚îÇ
‚îÇ  message or ‚îÇ                  ‚îÇ                  ‚îÇ
‚îÇ  image      ‚îÇ                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                            ‚îÇ
                                           ‚îÇ API Call
                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                 ‚îÇ                                  ‚îÇ
                 ‚îÇ  Jules API                       ‚îÇ
                 ‚îÇ  (sessions, activities, sources) ‚îÇ
                 ‚îÇ                                  ‚îÇ
                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                 ‚îÇ
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ                                                 ‚îÇ
      ‚îÇ  Cron Trigger (every 1 min)                     ‚îÇ
      ‚îÇ  - Poll new activities for all sessions         ‚îÇ
      ‚îÇ  - Process and format activities                ‚îÇ
      ‚îÇ  - Send to appropriate Telegram topic           ‚îÇ
      ‚îÇ                                                 ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                 ‚îÇ
                                 ‚ñº
                          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                          ‚îÇ  Telegram   ‚îÇ
                          ‚îÇ  (auto      ‚îÇ
                          ‚îÇ  updates)   ‚îÇ
                          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Core Components

#### 1. **Bot Layer** (`src/bot/`)

- **bot.ts** - Core bot configuration, utility functions for sending messages, checking permissions, managing topics
- **commands/** - Command handlers organized by category
  - `basicCommands.ts` - /start, /help
  - `configCommands.ts` - Admin-only configuration commands (/set_jules_token, /set_source, etc.)
  - `infoCommands.ts` - Information display commands (/status, /list_sessions, etc.)
  - `actionCommands.ts` - Action commands (/new_session, /approve_plan, /delete_session, etc.)
- **handlers/** - Message and event processors
  - `messageHandlers.ts` - Processes text and image messages from users
  - `callbackHandlers.ts` - Handles inline button callbacks (approve plan, publish PR, etc.)
  - `activityProcessor.ts` - Processes Jules API activities and formats them for Telegram

#### 2. **Cron Layer** (`src/cron/`)

Automated background tasks triggered by Cloudflare cron triggers:

- `pollActivities.ts` - Polls Jules API for new activities every minute (src/cron/pollActivities.ts:1)
- `syncSessions.ts` - Syncs local sessions with Jules API every 15 minutes (src/cron/syncSessions.ts:1)

Configured in `wrangler.toml:19-23`.

#### 3. **Jules API Integration** (`src/jules/`)

- `api.ts` - Jules API client for:
  - Session management (create, delete, list)
  - Activity polling
  - Sending prompts and images
  - Approving plans
  - Publishing branches/PRs

#### 4. **Storage Layer** (`src/kv/`)

- `storage.ts` - KV storage abstraction for multi-tenant data:
  - Group configurations (token, source, branch, settings)
  - Session mappings (topic ID ‚Üî session ID)
  - Activity tracking
  - KV keys follow pattern: `{groupId}:{type}:{key}`

#### 5. **Utilities** (`src/utils/`)

- `formatters.ts` - Formats Jules outputs for Telegram (expanding blockquotes, GitHub link extraction)
- `github.ts` - GitHub integration utilities
- `image.ts` - Image processing for sending screenshots/designs to Jules
- `retry.ts` - Retry logic for API calls

#### 6. **Main Entry** (`src/index.ts`)

Worker entry point with:

- `fetch()` handler for webhook requests (src/index.ts:109)
- `scheduled()` handler for cron triggers (src/index.ts:143)
- Bot setup and handler registration (src/index.ts:59)

### Multi-Tenancy Model

The architecture implements strict isolation between Telegram groups:

1. **Group Configuration**: Each group has isolated configuration stored in KV

   - Jules API token
   - Default source (repository)
   - Default branch
   - Settings (auto PR, approval required, etc.)

2. **Session Mapping**: Each Telegram topic maps to exactly one Jules session

   - Topic ID ‚Üí Session ID stored in KV
   - Allows multiple concurrent sessions per group
   - Perfect organization with topic-based isolation

3. **Cron Efficiency**: Cron jobs iterate through all active sessions across all groups (see src/cron/pollActivities.ts:15)

### Key Configuration Files

- **wrangler.toml** - Cloudflare Worker configuration

  - KV namespace bindings
  - Cron triggers
  - Environment variables
  - Environment-specific settings (dev/prod)

- **tsconfig.json** - TypeScript configuration

  - ES2022 module system
  - Strict mode enabled
  - Cloudflare Workers types included

- **vitest.config.ts** - Vitest configuration with Cloudflare Workers pool

### Development Workflow

#### Local Development

1. Install dependencies: `npm install`
2. Create KV namespaces for dev and preview
3. Set BOT_TOKEN secret: `wrangler secret put BOT_TOKEN`
4. Start dev server: `npm run dev`
5. Tests: `npm run test:watch` (cron triggers don't run in dev)

#### Testing Strategy

Tests are written using Vitest with Cloudflare Workers pool for realistic Worker environment testing. Tests can run Worker-specific code including:

- KV operations
- Fetch API
- Environment bindings
- Scheduled events

#### Production Deployment

1. Deploy: `npm run deploy`
2. Set Telegram webhook: `curl "https://api.telegram.org/bot<BOT_TOKEN>/setWebhook?url=https://your-worker.workers.dev/webhook"`
3. Cron triggers run automatically (requires Workers Paid plan)

### Critical Implementation Details

#### Permission System

- **Bot Permissions**: Must be admin with "Manage Topics" permission (src/bot/bot.ts:87)
- **User Permissions**: Only group admins can run configuration commands (src/bot/bot.ts:68)
- **Privacy Mode**: Must be disabled in @BotFather to read all group messages

#### Topic Management

- Bot updates topic titles with session info (src/bot/bot.ts:181)
- Format: `{owner}/{repo} {last-4-chars-of-session-id}`
- Requires "can_manage_topics" permission

#### Notification Strategy

- **Important events** (plan ready, errors): Send with notification
- **Routine updates** (typing indicators, progress): Send silently
- See `sendMessage()` in src/bot/bot.ts:151

#### Cron Trigger Logic

Cron jobs determine which task to run based on current minute (src/index.ts:154-165):

- Every 15 minutes: Run session sync
- Every minute: Run activity polling

#### Error Handling

- All bot handlers wrapped in try-catch (src/index.ts:96)
- KV operations include error handling with fallbacks
- API calls use retry logic from utils/retry.ts
- Silent failures for non-critical operations (e.g., topic title updates)

### Common Patterns

#### Creating a New Command

1. Add handler function in appropriate file under `src/bot/commands/`
2. Register in `src/index.ts` setupBot() function
3. Add to relevant command category in README.md
4. Add tests if functionality is complex

#### Processing Messages

1. Text messages: Add handler in `src/bot/handlers/messageHandlers.ts:handleTextMessage`
2. Image messages: Add handler in `src/bot/handlers/messageHandlers.ts:handlePhotoMessage`
3. Callback queries: Add handler in `src/bot/handlers/callbackHandlers.ts`

#### Adding Cron Jobs

1. Create function in `src/cron/`
2. Register in `wrangler.toml` crons array
3. Add logic in `src/index.ts:scheduled()` to determine when to run
4. Requires Workers Paid plan

#### KV Storage Access

Import and use the storage module:

```typescript
import { getGroupConfig, setGroupConfig } from "./kv/storage";

// Read
const config = await getGroupConfig(env, groupId);

// Write
await setGroupConfig(env, groupId, { ...config, key: value });
```

### Testing Guidelines

- Tests are in `test/` directory
- Use Vitest with Cloudflare Workers pool
- Mock external APIs (Telegram, Jules)
- Test KV operations with Workers test environment
- Run `npm test` before committing

### Environment Setup

#### Required Services

1. **Cloudflare Account** - Workers hosting

   - Free tier works for basic functionality
   - Paid tier ($5/month) required for cron triggers

2. **Telegram Bot Token** - From [@BotFather](https://t.me/BotFather)

   - Privacy mode: Disabled
   - Permissions: Admin, Manage Topics

3. **Jules API Key** - From [jules.google](https://jules.google)
   - Configure via `/set_jules_token` command in Telegram

#### KV Namespace Setup

```bash
# Production
wrangler kv namespace create "KV"

# Development
wrangler kv namespace create "KV" --preview
```

Update `wrangler.toml:12-15` with namespace IDs.

### CI/CD Pipeline

Comprehensive GitHub Actions workflows in `.github/workflows/`:

- **ci.yml** - Runs on push/PR: Type checking, linting, tests
- **deploy.yml** - Deploys to Cloudflare on main/develop branch
- **codeql.yml** - Security analysis
- **release.yml** - Creates releases on version tags
- **dependabot.yml** - Automated dependency updates

See `.github/README.md` for detailed CI/CD documentation.

### License

AGPL-3.0-or-later - See LICENSE file for full details.

---

## üìù Development Plan

### Plan Structure Overview

This development plan follows a structured approach to building the Jot Telegram bot. Each section represents a major milestone with specific implementation steps.

### 1. Initial Project Setup

- Create new Cloudflare Worker project using wrangler CLI
- Install Grammy framework as dependency
- Configure basic project structure with TypeScript
- Configure wrangler.toml for development and production environments
- Define Env interface with necessary bindings (KV, environment variables)

**Documentation:**

- https://grammy.dev
- https://grammy.dev/hosting/cloudflare-workers-nodejs
- https://developers.cloudflare.com/workers/wrangler/environments/

### 2. Bot Configuration in Worker

- Create Grammy bot instance using BOT_TOKEN environment variable
- Implement webhookCallback to receive Telegram updates via webhook
- Configure basic Worker fetch handler
- Implement scheduled handler for cron triggers (sync and polling)
- Optimize with pre-configured botInfo to avoid unnecessary getMe calls

**Documentation:**

- https://grammy.dev/hosting/cloudflare-workers-nodejs
- https://grammy.dev/ref/core/webhookcallback
- https://developers.cloudflare.com/workers/configuration/cron-triggers/

### 3. KV Namespace Configuration for Multi-Tenant

- Create KV namespace via wrangler or dashboard
- Configure KV binding in wrangler.toml
- Key structure with group isolation:
  - `group:{group_id}:jules_token`
  - `group:{group_id}:topic:{topic_id}:session`
  - `group:{group_id}:source`
  - `group:{group_id}:automation_mode`
  - `group:{group_id}:require_approval`
  - `group:{group_id}:default_branch`
  - `group:{group_id}:sessions_index`
  - `group:{group_id}:topic:{topic_id}:last_activity_id`
  - `group:{group_id}:topic:{topic_id}:pending_plan`
  - `group:{group_id}:topic:{topic_id}:ready_for_review`
- Implement helpers for KV read/write with group_id as prefix

**Documentation:**

- https://developers.cloudflare.com/kv/

### 4. Authentication System and Per-Group Admin Control

- Implement /set_jules_token command (verifies admin with getChatAdministrators)
- Store token in KV with key `group:{group_id}:jules_token`
- Validate token via GET /v1alpha/sessions before storing
- /status command to verify group configuration
- Ensure total isolation between groups

**Documentation:**

- https://developers.google.com/jules/api
- https://core.telegram.org/bots/api

### 5. 1:1 Topic-Session Management System

- Detect message_thread_id to identify topics
- 1:1 mapping: each topic = 1 Jules session
- Store complete session in KV with status and outputs
- Update topic title: "user/repo session_id" using editForumTopicName
- Verify bot "Manage Topics" permission

**Documentation:**

- https://core.telegram.org/bots/api
- https://developers.google.com/jules/api/reference/rest

### 6. Jules API Integration - Per-Group Sources

- /list_sources command using GET /v1alpha/sources
- Each group sees only their own sources
- /set_source command to define default source
- /get_source command to see configured source
- Store: `group:{group_id}:source`

**Documentation:**

- https://developers.google.com/jules/api/reference/rest/v1alpha/sources

### 7. Jules API Integration - Session Creation

- POST /v1alpha/sessions with {prompt, source, automationMode, requirePlanApproval, startingBranch}
- Extract session_id and store in KV
- Automatically update topic title
- Add to sessions_index
- Start activity polling

**Documentation:**

- https://developers.google.com/jules/api

### 8. "Typing..." Status Indicator

- showTypingIndicator function using sendChatAction "typing"
- Loop repeating every 4-5s (action lasts only 5s)
- Use between sending prompt and receiving activity
- Stop when new activity arrives

**Documentation:**

- https://core.telegram.org/bots/api
- https://grammy.dev/ref/core/api

### 9. Intelligent Notification System

**WITH SOUND (disable_notification=false):**

- planGenerated (MAXIMUM ATTENTION - see section 11)
- sessionCompleted
- "Ready for review"
- progressUpdated with exitCode !== 0
- progressUpdated with artifacts.media
- First activity
- Messages with questions

**SILENT (disable_notification=true):**

- Normal progressUpdated
- bashOutput with exitCode === 0
- Intermediate changeSet
- planApproved
- Informative messages

**Documentation:**

- https://core.telegram.org/bots/api

### 10. Activity Polling via Cron Trigger (AUTOMATIC)

- Cron every 1-2 minutes
- For each active session in each group:
  - GET /v1alpha/sessions/{session_id}/activities
  - Filter new activities (createTime > last_activity_id)
  - **Process and AUTOMATICALLY SEND each activity to correct topic**
  - Update last_activity_id in KV
  - Fetch updated session to get outputs (PRs, branches)
- Implement rate limiting
- **User doesn't need to do anything, activities arrive automatically!**

**Documentation:**

- https://developers.cloudflare.com/workers/configuration/cron-triggers/
- https://developers.google.com/jules/api/reference/rest/v1alpha/sessions.activities/list

### 11. Activity Processing by Type with Special Attention

**planGenerated (MAXIMUM ATTENTION - IMPOSSIBLE TO IGNORE):**

- **Catchy emoji: üéØ**
- **Title in BOLD: "üéØ PLAN CREATED"**
- If requirePlanApproval=true: add **"- APPROVAL REQUIRED"** in bold
- List steps using **expandable blockquote**:
  - Visible title: "üéØ **PLAN CREATED** - X steps"
  - Expandable: `<blockquote expandable>` with complete numbered step list
- Highlighted inline button: "‚úÖ Approve Plan" if requirePlanApproval=true
- If requirePlanApproval=false: inform "Plan will be auto-approved"
- **MANDATORY SOUND NOTIFICATION**
- Use parse_mode: "HTML" for formatting

**planApproved:**

- Brief message: "‚úÖ Plan approved! Jules will start working."
- SILENT

**"Ready for review üéâ":**

- Detect "Ready for review" in title/description
- Format: "üéâ **Ready for review!**\n\nJules finished changes."
- Fetch updated session for outputs
- Inline buttons: "üì¶ Publish branch" and "üîÄ Publish PR"
- Store ready_for_review flag in KV
- WITH SOUND NOTIFICATION

**progressUpdated:**

- If long bashOutput: use expandable blockquote
  - Title: "üîß Command executed: `command`"
  - Expandable: `<blockquote expandable>` with complete output
- If large changeSet: use expandable blockquote
  - Title: "üìÅ Modified files (X files)"
  - Expandable: complete file list
- If artifacts.media: download and send as photo
- exitCode !== 0: emoji ‚ö†Ô∏è + WITH NOTIFICATION
- exitCode === 0: emoji üîß + SILENT

**sessionCompleted:**

- Emoji ‚úÖ + title: "**Session completed!**"
- Fetch final outputs
- Extract and show GitHub links (PR, branch, commits) with emojis
- Clickable links in Markdown: `[View Pull Request #123](URL)`
- If many details: use expandable blockquote
- WITH SOUND NOTIFICATION

**Other activities:**

- If long: use expandable blockquote
- Decide notification based on content

**Documentation:**

- https://developers.google.com/jules/api/reference/rest/v1alpha/sessions.activities
- https://core.telegram.org/bots/api

### 12. Handlers for Publication Buttons

**callback_query "publish_branch:{session_id}":**

- Validate group
- Call Jules API to publish branch
- Update message (remove "Publish branch" button)
- Show branch link: "‚úÖ Branch published! üåø [View on GitHub](URL)"

**callback_query "publish_pr:{session_id}":**

- Validate group
- Call Jules API to create PR
- Update message (remove buttons)
- Show PR link: "‚úÖ Pull Request created! üîÄ [View on GitHub](URL)"

**Documentation:**

- https://grammy.dev/plugins/keyboard

### 13. Support for Receiving User Images

- Handler bot.on("message:photo")
- Extract highest resolution photo: `ctx.message.photo[ctx.message.photo.length - 1]`
- Use ctx.getFile() to get file_path
- Download: `https://api.telegram.org/file/bot<TOKEN>/<file_path>`
- Convert to base64
- Extract caption (or use "Analyze this image")
- POST sendMessage: `{prompt, media: {data: base64, mediaType: "image/jpeg"}}`
- Start "typing..." indicator

**Documentation:**

- https://grammy.dev/guide/files
- https://core.telegram.org/bots/api

### 14. Image to Base64 Conversion

- Function downloadAndConvertImageToBase64(file_path, bot_token)
- Fetch image
- Convert to ArrayBuffer ‚Üí Buffer
- Convert to base64
- Return base64 + mediaType
- Retry logic with exponential backoff
- 30s timeout

**Documentation:**

- https://grammy.dev/guide/files

### 15. Session Sync via Cron

- Cron every 15-30 minutes
- GET /v1alpha/sessions for each group
- Compare with sessions_index in KV
- Detect deleted sessions
- Remove from KV and notify silently
- Update status and outputs

**Documentation:**

- https://developers.google.com/jules/api/reference/rest

### 16. Manual Sync Command

- /sync (admin only)
- Sync only current group
- GET /v1alpha/sessions
- Compare with KV
- If many sessions: use expandable blockquote
- Report: "X synced, Y removed"
- Update titles and show GitHub links

**Documentation:**

- https://grammy.dev/guide/commands

### 17. Delete Session Command

- /delete_session (admin only)
- Verify admin
- Confirmation button: "‚ö†Ô∏è Confirm Deletion"
- Remove from KV and sessions_index
- Notify: "Session removed locally. To permanently delete, visit jules.google"

**Documentation:**

- https://grammy.dev/plugins/keyboard

### 18. Plan Approval

- /approve_plan in topic with pending plan
- Verify pending_plan in KV
- POST /v1alpha/sessions/{session_id}:approvePlan
- Remove pending_plan from KV
- Confirmation: "‚úÖ Plan approved! Jules will start working."
- Callback_query handler for inline button

**Documentation:**

- https://developers.google.com/jules/api/reference/rest

### 19. Continuous Conversation (Text and Images)

**Text in topic with session:**

- POST sendMessage with {prompt}
- Start "typing..."

**Image in topic with session:**

- Download, convert to base64
- POST sendMessage with {prompt, media}
- Start "typing..."

**Without session:**

- Create new session (text or image)

**General chat:**

- Guide to use topics

**Documentation:**

- https://developers.google.com/jules/api

### 20. Artifact Formatting with Expandable Blockquote

**bashOutput:**

- If short: normal code block
- If long: use expandable blockquote
  - Title: "üîß Command: `command`"
  - Expandable: `<blockquote expandable>complete output</blockquote>`
- Show exitCode
- Emoji ‚ö†Ô∏è if error

**changeSet:**

- If few files: list normally
- If many: use expandable blockquote
  - Title: "üìÅ Modified files (X files)"
  - Expandable: `<blockquote expandable>complete list</blockquote>`
- Parse gitPatch.unidiffPatch
- Show +/- lines

**media:**

- Decode base64
- sendPhoto with InputFile
- Caption with title and description

**Documentation:**

- https://core.telegram.org/bots/api#sendphoto

### 21. GitHub Link Extraction

- Function extractGitHubLinks(session.outputs)
- Regex for PR, branch, commit URLs:
  - PR: `https://github.com/[^/]+/[^/]+/pull/\d+`
  - Branch: `https://github.com/[^/]+/[^/]+/tree/[^/\s]+`
  - Commit: `https://github.com/[^/]+/[^/]+/commit/[a-f0-9]+`
- Format as clickable Markdown
- Emojis: üîÄ PR, üåø branch, üìù commit
- Examples:
  - `üîÄ [View Pull Request #123](URL)`
  - `üåø [View Branch feature-xyz](URL)`
  - `üìù [View Commit abc123](URL)`

**Documentation:**

- https://core.telegram.org/bots/api#formatting-options

### 22. Command to Open Jules Settings

**Implement /open_jules_settings:**

- Verify if group has configured source in KV
- If no source: respond "Configure a source first using /set_source"
- If has source:
  - Extract user/repo from source (format: "sources/github/user/repo")
  - Build Jules URL: `https://jules.google/github/{user}/{repo}`
  - Send message with inline button:
    - Text: "‚öôÔ∏è **Advanced Jules Settings**\n\nTo configure Setup Script, Environment Variables and Memories, access repository settings on Jules website."
    - Button: "üîó Open Settings" (url: direct link)
- Add note: "These settings are per-repository and affect all future sessions."
- Works in any context (general chat or topic)

**Technical implementation:**

- Helper function: `parseSourceToGitHubUrl(source: string): string`
  - Input: "sources/github/verseles/dartian"
  - Output: "https://jules.google/github/verseles/dartian"
- Use Grammy's InlineKeyboard to create URL button
- Parse mode: "HTML" or "MarkdownV2" for formatting

**Documentation:**

- https://grammy.dev/plugins/keyboard
- https://core.telegram.org/bots/api#inlinekeyboardmarkup

### 23. Command System (with underscore)

**Basic:**

- /start - Welcome with explanation of topics, images, configuration
- /help - Complete list with examples

**Configuration (admin):**

- /set_jules_token <token>
- /set_source <source_name>
- /set_branch <branch_name>
- /set_auto_pr <on|off>
- /require_approval <on|off>

**Information:**

- /status
- /get_source
- /list_sources
- /list_sessions (use blockquote if many)
- /session_info (use blockquote for details)
- /list_activities (use expandable blockquote)
- /show_plan (use expandable blockquote)
- /show_outputs
- **/open_jules_settings** - Open repository settings on Jules website

**Action:**

- /new_session <prompt>
- /approve_plan
- /delete_session
- /sync

**Documentation:**

- https://grammy.dev/guide/commands

### 24. Message Handlers with Image Support

- Extract group_id
- Verify configured token
- Detect type (text, photo)

**Topic + text:**

- If has session: POST sendMessage
- If not: create new session

**Topic + photo:**

- Download, convert to base64
- POST sendMessage with media
- Create session if necessary

**General chat:**

- Guide to use topics

**Documentation:**

- https://grammy.dev/guide/files

### 25. Multi-Tenant Isolation Layer

- Helper functions always with group_id
- getJulesToken(group_id)
- getSession(group_id, topic_id)
- getActiveSessions(group_id)
- getSource(group_id)
- parseSourceToGitHubUrl(source) - new function
- Validate all KV operations include group_id
- Log cross-group access attempts
- Validate callback_query data

**Documentation:**

- https://developers.cloudflare.com/kv/

### 26. Notification and Feedback System

- Use intelligent notification logic
- Send to correct topic with message_thread_id
- Inline buttons:
  - "‚úÖ Approve Plan"
  - "üì¶ Publish branch"
  - "üîÄ Publish PR"
  - "‚ö†Ô∏è Delete Session"
  - "üîÑ View Details"
  - "üîó Open Settings" (for /open_jules_settings)
  - "‚ùå Cancel"
- Callback_query handlers
- Update messages after action (editMessageText, editMessageReplyMarkup)

**Documentation:**

- https://grammy.dev/plugins/keyboard

### 27. Error Handling and Logs

- Try-catch in all Jules API calls
- Log with group_id, session_id, activity_id, user_id
- Friendly error messages WITH notification
- Rate limiting per group
- Retry logic (3 attempts, exponential backoff)
- Handle 404 (deleted session - remove from KV)
- Handle 401/403 (invalid token - notify admin)
- Image download errors (size, format)
- Image timeout (30s)
- Source parsing error: notify and request /set_source again

**Documentation:**

- https://developers.cloudflare.com/workers/observability/logging/

### 28. Testing with Vitest

- Configure Vitest with @cloudflare/vitest-pool-workers
- Create vitest.config.ts using defineWorkersConfig
- Unit tests:
  - helpers
  - formatters
  - parsers
  - extractGitHubLinks
  - parseSourceToGitHubUrl
- Integration tests: handlers, activity processing, blockquote formatting
- Mock tests: Jules API and Telegram API
- KV tests: read/write operations (miniflare already included)
- Use wrangler dev for local development
- **Note: Miniflare comes integrated in Wrangler 2.0+, no separate installation needed**

**Documentation:**

- https://developers.cloudflare.com/workers/testing/vitest-integration/
- https://developers.cloudflare.com/workers/testing/miniflare/
- https://vitest.dev

### 29. Deploy and Production Configuration

- Environment variables with wrangler secret (BOT_TOKEN)
- Cron triggers in wrangler.toml:
  - `*/1 * * * *` (activity polling - every 1 minute)
  - `*/15 * * * *` (session sync - every 15 minutes)
- wrangler deploy
- Configure Telegram webhook: `https://api.telegram.org/bot<TOKEN>/setWebhook?url=https://<WORKER>.workers.dev/`
- Test complete flow in multiple groups:
  - Create session (text and image)
  - Receive activities automatically via cron
  - Approve plan
  - Ready for review + buttons
  - Publish branch/PR + GitHub links
  - /open_jules_settings
  - Expandable blockquote in long messages
  - Delete session
- Test isolation, notifications, "typing..." indicator
- Monitor logs in dashboard

**Documentation:**

- https://developers.cloudflare.com/workers/wrangler/commands/#deploy
- https://grammy.dev/hosting/cloudflare-workers-nodejs

### 30. Optimizations

- Token cache per group (in memory)
- Sources cache
- Generated Jules URLs cache
- Temporary image cache
- Process only active sessions
- Exponential retry logic
- Consider Durable Objects for continuous "typing..." (5s loop)
- Consider Durable Objects for real-time polling
- Workers Analytics
- Automatic cleanup of old sessions (30 days)
- Debounce for repeated activities
- Compression of long messages or use blockquote
- Streams for large images
- Connection pool for parallel downloads

**Documentation:**

- https://developers.cloudflare.com/workers/runtime-apis/durable-objects/

### 31. Known Jules API Limitations

**Features available ONLY on web interface:**

1. **Setup Script:**

   - No API endpoint to configure/edit setup script
   - Must be configured via web interface at Environment ‚Üí Setup script
   - Affects all future sessions for the repository

2. **Environment Variables per Source:**

   - No endpoint to configure env vars at repository level
   - Must be configured via web interface at Environment ‚Üí Environment variables
   - Affects all future sessions for the repository

3. **Memories/Knowledge:**
   - No endpoint to add/manage memories manually
   - Memories are automatically generated during sessions
   - Manual memories must be added via web interface at Knowledge ‚Üí Add Memory

**Solution in bot:**

- /open_jules_settings command directs user to web interface
- Clearly document these limitations in README
- Add note in relevant commands guiding to use web interface

**Documentation:**

- https://developers.google.com/jules/api
- https://jules.google (web interface)

### 32. Complete README (English, AGPLv3)

**README.md structure:**

- **Title + Badges**: license (AGPLv3), build status, version
- **Description**: What the bot does (2-3 paragraphs)
- **Features**: List with emojis (multi-tenant, topics=sessions, images, GitHub links, etc)
- **Prerequisites**: Node.js 20+, Cloudflare account, Telegram Bot Token (via @BotFather), Jules API key
- **Installation**:
  - Clone repo
  - `npm install`
  - Configure wrangler.toml
  - Create KV namespace
- **Configuration**:
  - Environment variables (BOT_TOKEN via wrangler secret)
  - KV binding setup
  - Cron triggers configuration
- **Bot Setup** (README only):
  - How to create bot in @BotFather
  - How to get bot token
  - How to add bot to group
  - How to grant "Manage Topics" permission
  - How to get Jules API key at jules.google
- **Usage**:
  - Add bot to Telegram group
  - Use /set_jules_token to configure
  - Create topics to organize sessions
  - Send text messages or images
  - System works automatically (cron sends activities)
  - Use /open_jules_settings for advanced settings
- **Commands Reference**: Complete table with all commands and descriptions
- **Image Support**:
  - How to send images to Jules
  - Supported formats (jpg, png, webp)
  - Size limit (20MB)
  - Examples of prompts with images
- **Advanced Configuration**:
  - Setup Script, Environment Variables and Memories must be configured via web interface
  - Use /open_jules_settings for quick access
  - Direct link: https://jules.google/github/{user}/{repo}
- **Architecture**:
  - Flow diagram (Telegram ‚Üí Worker ‚Üí Jules API ‚Üí Activities ‚Üí Telegram)
  - Multi-tenant with per-group isolation
  - Cron for automatic activity polling
- **Development**:
  - `wrangler dev` for local development
  - `npm test` to run tests with Vitest
  - **Note: Don't use Docker** (Workers uses V8 Isolates, not containers)
- **Testing**:
  - How to run tests: `npm test`
  - Vitest with @cloudflare/vitest-pool-workers
  - Miniflare already included in Wrangler 2.0+
- **Deployment**:
  - `wrangler deploy`
  - Configure Telegram webhook
  - Monitor logs
- **API Limitations**:
  - Setup Script: web only
  - Environment Variables (per source): web only
  - Manual Memories: web only
  - Use /open_jules_settings to access web interface
- **Troubleshooting**:
  - Required permissions (admin + "Manage Topics")
  - Invalid/expired token
  - Session deleted on jules.google
  - Rate limiting
  - Images too large
  - Unsupported formats
  - Source not configured (required for /open_jules_settings)
- **Contributing**:
  - Code style: TypeScript, code in English, explanatory comments
  - PR process
  - Mandatory tests
- **License**: AGPLv3 with link to LICENSE file
- **Credits**: Grammy, Jules API, Cloudflare Workers, TypeScript

**Documentation:**

- https://grammy.dev
- https://developers.cloudflare.com/workers/
- https://jules.google

---

## üêõ Known Issues and Debugging

### Bug Reports - Status: REPORTED

**Date:** 06/11/2025
**Conversation:** Continuation session needed

---

### Issue 1: `/list_sources` Infinite Loop ‚ùå

**Status:** REPORTED - Still failing after all fixes
**Error:** Bot sends "üîÑ Loading sources..." repeatedly in a loop

### Issue 2: `/new_session` INVALID_ARGUMENT Error ‚ùå

**Status:** REPORTED - Still failing after multiple attempts
**Error:** `Jules API error (400): Request contains an invalid argument.`

---

### Detailed Analysis

#### Issue 2 - `/new_session` Failure Deep Dive

##### Error Message

```
Jules over Telegram, [06/11/2025 02:45]
‚ùå Failed to create session.

Error: Jules API error (400): {
  "error": {
    "code": 400,
    "message": "Request contains an invalid argument.",
    "status": "INVALID_ARGUMENT"
  }
}
```

##### Root Cause Investigation

**Initial Hypothesis:** automation_mode format issue

- Changed from `'AUTO_PR' | 'MANUAL'` to `'INTERACTIVE' | 'PLAN' | 'AUTO'`
- Updated to send numeric enums (1, 2, 3) to Jules API
- **Result:** FAILED - Same error persists

**Second Attempt:** Only send automation_mode when explicitly set

- Modified code to NOT send `automation_mode` field when null/undefined
- Let Jules API use its default
- **Result:** FAILED - Same error persists

**Code Applied:**

```typescript
// src/bot/commands/actionCommands.ts (lines 92-108)
const defaultBranch = await getDefaultBranch(ctx.env, groupId);
const automationMode = await getAutomationMode(ctx.env, groupId);
const requireApproval = await getRequireApproval(ctx.env, groupId);

const createParams: any = {
  prompt,
  source,
  requirePlanApproval: requireApproval,
  startingBranch: defaultBranch || undefined,
};

// Only add automationMode if explicitly configured
if (automationMode) {
  createParams.automationMode = automationMode;
}

const session = await julesClient.createSession(createParams);
```

**Third Attempt:** Remove ALL optional fields

- Tried sending only `prompt` and `source_context`
- **Result:** NOT TESTED YET

##### Jules API Schema (from src/jules/api.ts)

```typescript
async createSession(params: {
  prompt: string;
  source: string;
  automationMode?: 'INTERACTIVE' | 'PLAN' | 'AUTO';
  requirePlanApproval?: boolean;
  startingBranch?: string;
  media?: {
    data: string;
    mediaType: string;
  };
}): Promise<JulesSession>

// Maps to body:
const body: any = {
  prompt: params.prompt,
  source_context: {
    source: params.source,
  },
};

// Only send automation_mode if explicitly specified
if (params.automationMode) {
  if (params.automationMode === 'INTERACTIVE') {
    body.automation_mode = 1;
  } else if (params.automationMode === 'PLAN') {
    body.automation_mode = 2;
  } else if (params.automationMode === 'AUTO') {
    body.automation_mode = 3;
  }
}

// Only send optional fields if provided
if (params.requirePlanApproval !== undefined && params.requirePlanApproval !== null) {
  body.require_plan_approval = params.requirePlanApproval;
}

if (params.startingBranch && params.startingBranch.trim() !== '') {
  body.starting_branch = params.startingBranch;
}

if (params.media) {
  body.media = params.media;
}
```

##### What Was Changed (Type System)

**All automation mode types updated:**

1. `src/types/env.ts` - SessionData, GroupConfig, JulesSession interfaces
2. `src/kv/storage.ts` - getAutomationMode(), setAutomationMode()
3. `src/bot/commands/actionCommands.ts` - `/new_session` command
4. `src/bot/commands/configCommands.ts` - `/set_auto_pr` command
5. `src/bot/commands/infoCommands.ts` - `/session_info` command
6. `src/bot/handlers/messageHandlers.ts` - Auto-create session (2 locations)
7. `src/utils/formatters.ts` - Status display

**Config Command Changes:**

- `on` ‚Üí `'AUTO'` (was `'AUTO_PR'`)
- `off` ‚Üí `'INTERACTIVE'` (was `'MANUAL'`)
- Messages updated accordingly

##### Debugging Data Needed

The user should provide:

1. What automation mode is configured? Run `/status`
2. What is the source? Run `/get_source`
3. What is default branch? Run `/status`
4. Are there any KV values set? Need to check KV namespace

---

### What Was Fixed ‚úÖ

#### 1. TypeScript Compilation Errors

- **Problem:** CI pipeline failing on "Run TypeScript type check"
- **Cause:** Type mismatch between `'AUTO_PR' | 'MANUAL'` and `'INTERACTIVE' | 'PLAN' | 'AUTO'`
- **Solution:** Updated all type references across 7 files
- **Status:** ‚úÖ FIXED - All 40 tests pass

#### 2. Deployment Pipeline

- **Problem:** GitHub Actions CI failing
- **Cause:** TypeScript errors blocking merge
- **Solution:** Fixed all type mismatches
- **Status:** ‚úÖ FIXED - Can deploy successfully

---

### Current Deployment State

**Worker URL:** https://jules-over-telegram.cloudatlas.workers.dev
**Current Version:** 4b92c9c3-769e-49d1-a85b-4cc1a55e2c79
**Deployment Time:** 06/11/2025 02:46
**Test Status:** ‚úÖ All 40 tests passing
**TypeScript:** ‚úÖ No compilation errors

---

### Next Debugging Steps (for continuation conversation)

#### Step 1: Test Minimal Request

Create a test that sends ONLY the required fields:

```typescript
// In actionCommands.ts line 96, replace with:
const session = await julesClient.createSession({
  prompt,
  source,
  // NO optional fields
});
```

#### Step 2: Check KV Values

Verify what values are actually stored in KV:

```bash
# Check automation mode
wrangler kv key get --binding=KV "group:{groupId}:automation_mode"

# Check require approval
wrangler kv key get --binding=KV "group:{groupId}:require_approval"

# Check default branch
wrangler kv key get --binding=KV "group:{groupId}:default_branch"
```

#### Step 3: Add Debug Logging

Add console.log to see what body is being sent:

```typescript
// In api.ts createSession(), before request:
console.log("Request body:", JSON.stringify(body, null, 2));
```

#### Step 4: Check Jules API Documentation

Look at actual API documentation to verify correct schema:

- URL: https://developers.google.com/jules/api/reference/rest/v1alpha/sessions

#### Step 5: Verify Source Format

Check if source format is correct:

- Current: `sources/github/insign/1kb.club`
- Is this the correct format?
- Should it be just `github/insign/1kb.club`?

---

### File Changes Summary

#### Modified Files (automation mode fix)

1. `src/types/env.ts` - Updated interface types
2. `src/kv/storage.ts` - Updated function signatures
3. `src/bot/commands/actionCommands.ts` - Added conditional automation_mode
4. `src/bot/commands/configCommands.ts` - Changed on/off mapping
5. `src/bot/commands/infoCommands.ts` - Updated display text
6. `src/bot/handlers/messageHandlers.ts` - Added conditional automation_mode (2 places)
7. `src/utils/formatters.ts` - Updated display text

#### Cache Implementation (already exists)

- `src/kv/storage.ts` - Cache functions with 5-minute TTL
- `src/bot/commands/infoCommands.ts` - handleListSources uses cache
- `src/bot/handlers/callbackHandlers.ts` - Pagination with inline keyboards

---

### Jules API Reference

#### Official Documentation

- Base URL: https://jules.googleapis.com/v1alpha
- Sessions: https://developers.google.com/jules/api/reference/rest/v1alpha/sessions
- Sources: https://developers.google.com/jules/api/reference/rest/v1alpha/sources

#### API Endpoints Used

1. `GET /sessions` - List sessions
2. `POST /sessions` - Create session ‚≠ê (failing)
3. `GET /sessions/{id}` - Get session
4. `POST /sessions/{id}:approvePlan` - Approve plan
5. `GET /sources` - List sources
6. `GET /activities` - List activities

#### Authentication

- Header: `X-Goog-Api-Key: {token}`
- ‚ùå NOT using Bearer token

---

### Commands Reference

#### Working Commands ‚úÖ

- `/start` - Bot introduction
- `/help` - Show available commands
- `/status` - Show group configuration
- `/get_source` - Show configured source
- `/list_sources` - List available sources (but may loop)
- `/set_jules_token <token>` - Set Jules API token
- `/set_source <source>` - Set default source
- `/list_sessions` - List active sessions

#### Failing Commands ‚ùå

- `/new_session <prompt>` - Create new session (INVALID_ARGUMENT)
- `/session_info` - Show session details (depends on new_session working)

---

### Testing Commands (for user to run)

Run these in Telegram bot and report results:

1. `/status` - What automation mode is shown?
2. `/get_source` - What source is configured?
3. `/list_sources` - Does it loop or work?
4. `/new_session test` - Does it still fail with INVALID_ARGUMENT?

---

### CI/CD Pipeline

#### GitHub Actions Workflows

- `.github/workflows/ci.yml` - Lint, Type Check, Tests ‚úÖ
- `.github/workflows/deploy.yml` - Deploy to Cloudflare ‚úÖ
- `.github/workflows/codeql.yml` - Security analysis ‚úÖ

#### Status

- **CI:** ‚úÖ Passing (after type fixes)
- **Deploy:** ‚úÖ Passing
- **Type Check:** ‚úÖ Passing (40/40 tests)

---

### Cron Jobs

Configured in `wrangler.toml`:

- `*/1 * * * *` - Poll activities every minute
- `*/15 * * * *` - Sync sessions every 15 minutes

---

### Key Decisions Made

1. **Cache TTL:** 5 minutes (reduced from 1 hour) - User feedback
2. **Pagination:** Inline keyboard with page:index pattern
3. **Automation Modes:** INTERACTIVE (default), PLAN, AUTO
4. **Config Command:** on=AUTO, off=INTERACTIVE
5. **API Schema:** Numeric enums (1,2,3) for automation_mode

---

### Unresolved Questions

1. Why does Jules API reject the request even without automation_mode?
2. Is the source format correct? `sources/github/user/repo` or `github/user/repo`?
3. What is the exact minimum required fields for createSession?
4. Does Jules API require any specific field ordering?
5. Are there any hidden required fields we're missing?

---

### Continuation Instructions

When starting new conversation, reference this file and:

1. Start from "Next Debugging Steps" section
2. Try Step 1 (minimal request) first
3. Add debug logging to see actual request body
4. Verify Jules API documentation for correct schema
5. Check KV values to see what user has configured

---

## üìö Additional Resources

### External Documentation Links

- [Grammy Documentation](https://grammy.dev)
- [Cloudflare Workers Documentation](https://developers.cloudflare.com/workers/)
- [Jules API Documentation](https://developers.google.com/jules/api)
- [Telegram Bot API](https://core.telegram.org/bots/api)
- [Vitest Documentation](https://vitest.dev)

### Project-Specific Resources

- [GitHub Repository](https://github.com/your-org/jot)
- [Issue Tracker](https://github.com/your-org/jot/issues)
- [Cloudflare Workers Dashboard](https://dash.cloudflare.com/)
- [Jules Console](https://jules.google)

---

**Last Updated:** 2025-11-17
**Document Version:** 1.0.0
**License:** AGPL-3.0-or-later
</file>

<file path="LICENSE">
GNU AFFERO GENERAL PUBLIC LICENSE
Version 3, 19 November 2007

Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.

Preamble

The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

The licenses for most software and other practical works are designed
to take away your freedom to share and change the works. By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

When we speak of free software, we are referring to freedom, not
price. Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate. Many developers of free software are heartened and
encouraged by the resulting cooperation. However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community. It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server. Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals. This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

[Full text continues at: https://www.gnu.org/licenses/agpl-3.0.txt]

For the complete and official GNU AFFERO GENERAL PUBLIC LICENSE Version 3,
please visit: https://www.gnu.org/licenses/agpl-3.0.txt
</file>

<file path="repomix.config.json">
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 50000000
  },
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "compress": false,
    "headerText": "This repository contains the source code for the JoT tool.\n\nPlease refer to the README.md file for more detailed information on usage and configuration.\n",
    "instructionFilePath": "AGENTS.md",
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 10,
    "showLineNumbers": false,
    "includeEmptyDirectories": true,
    "truncateBase64": true,
    "tokenCountTree": 50000,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": true,
      "includeLogs": true,
      "includeLogsCount": 50
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "lib": ["ES2022"],
    "types": ["@cloudflare/workers-types/2023-07-01"],
    "jsx": "react",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "noEmit": true,
    "allowJs": true,
    "checkJs": false
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="vitest.config.ts">
import { defineWorkersConfig } from '@cloudflare/vitest-pool-workers/config';

export default defineWorkersConfig({
  test: {
    poolOptions: {
      workers: {
        wrangler: { configPath: './wrangler.toml' },
      },
    },
  },
});
</file>

<file path=".github/workflows/pr-lint.yml">
name: PR Lint

on:
  pull_request:
    types: [opened, edited, synchronize, reopened]

jobs:
  pr-lint:
    name: Lint Pull Request
    runs-on: ubuntu-latest

    steps:
      - name: Check PR title format
        uses: amannn/action-semantic-pull-request@v5
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          # Types: build, chore, ci, docs, feat, fix, perf, refactor, revert, style, test
          types: |
            build
            chore
            ci
            docs
            feat
            fix
            perf
            refactor
            revert
            style
            test
          requireScope: false
          subjectPattern: ^[A-Z].+$
          subjectPatternError: |
            The subject must start with an uppercase character.
          validateSingleCommit: false
          ignoreLabels: |
            ignore-semantic-pull-request

      - name: Check PR size
        uses: actions/github-script@v8
        with:
          script: |
            const pr = context.payload.pull_request;
            const additions = pr.additions;
            const deletions = pr.deletions;
            const changes = additions + deletions;

            // Warn if PR is too large (>1000 lines)
            if (changes > 1000) {
              core.warning(`This PR has ${changes} line changes. Consider breaking it into smaller PRs for easier review.`);

              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `‚ö†Ô∏è **Large PR Warning**\n\nThis PR has ${changes} line changes. Consider breaking it into smaller PRs for easier review.\n\n- Additions: ${additions}\n- Deletions: ${deletions}`
              });
            }

      - name: Check PR description
        uses: actions/github-script@v8
        with:
          script: |
            const pr = context.payload.pull_request;
            const body = pr.body || '';

            // Check if PR has a description
            if (body.trim().length === 0) {
              core.setFailed('PR description is empty. Please add a description explaining your changes.');
            }

            // Check if PR has minimum length (at least 50 characters)
            if (body.trim().length < 50 && body.trim().length > 0) {
              core.warning('PR description is very short. Consider adding more details about your changes.');
            }

      - name: Label PR based on files changed
        uses: actions/github-script@v8
        with:
          script: |
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const labels = new Set();

            for (const file of files) {
              const filename = file.filename;

              if (filename.startsWith('src/bot/')) labels.add('bot');
              if (filename.startsWith('src/jules/')) labels.add('jules-api');
              if (filename.startsWith('src/kv/')) labels.add('storage');
              if (filename.startsWith('src/utils/')) labels.add('utilities');
              if (filename.startsWith('test/')) labels.add('tests');
              if (filename.startsWith('.github/')) labels.add('ci/cd');
              if (filename === 'README.md' || filename.endsWith('.md')) labels.add('documentation');
              if (filename === 'package.json' || filename === 'package-lock.json') labels.add('dependencies');
              if (filename === 'wrangler.toml') labels.add('cloudflare');
            }

            if (labels.size > 0) {
              // Get existing labels
              const { data: existingLabels } = await github.rest.issues.listLabelsOnIssue({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number
              });

              const existingLabelNames = new Set(existingLabels.map(l => l.name));

              // Add new labels
              const labelsToAdd = Array.from(labels).filter(l => !existingLabelNames.has(l));

              if (labelsToAdd.length > 0) {
                try {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    labels: labelsToAdd
                  });
                  console.log(`Added labels: ${labelsToAdd.join(', ')}`);
                } catch (error) {
                  console.log(`Note: Some labels might not exist yet: ${error.message}`);
                }
              }
            }

      - name: Comment with PR stats
        uses: actions/github-script@v8
        with:
          script: |
            const pr = context.payload.pull_request;
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const fileTypes = {};
            for (const file of files) {
              const ext = file.filename.split('.').pop();
              fileTypes[ext] = (fileTypes[ext] || 0) + 1;
            }

            const statsComment = `## üìä PR Statistics

            - **Files changed**: ${files.length}
            - **Additions**: ${pr.additions} lines
            - **Deletions**: ${pr.deletions} lines
            - **Total changes**: ${pr.additions + pr.deletions} lines

            ### File types:
            ${Object.entries(fileTypes).map(([ext, count]) => `- \`.${ext}\`: ${count} file(s)`).join('\n')}

            ---
            *This comment was automatically generated by PR Lint workflow*
            `;

            // Check if we already commented
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('PR Statistics')
            );

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: statsComment
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: statsComment
              });
            }
</file>

<file path=".github/README.md">
# GitHub Actions Workflows

This directory contains all GitHub Actions workflows for continuous integration, deployment, and automation.

## üìã Workflows Overview

### üîÑ CI Pipeline (`ci.yml`)

**Trigger**: Push to main/develop/claude branches, Pull Requests

**Jobs**:
1. **Lint & Type Check** - TypeScript compilation and code formatting
2. **Run Tests** - Execute test suite with Vitest
3. **Build Check** - Verify Wrangler can build the worker
4. **Security Audit** - Check for vulnerabilities with npm audit
5. **All Checks Passed** - Confirmation that all checks succeeded

**Purpose**: Ensures code quality and catches issues early in the development process.

---

### üöÄ Deployment (`deploy.yml`)

**Trigger**: Push to main (production) or develop (preview)

**Environments**:
- **Production** (`main` branch)
  - Deploys to: `jules-over-telegram.cloudatlas.workers.dev`
  - Sets Telegram webhook automatically
  - Runs health check
  - Custom domain: `jot.helio.me`

- **Preview** (`develop` branch)
  - Deploys to preview URL (`*-jules-over-telegram.cloudatlas.workers.dev`)
  - Uses preview KV namespace
  - Uses preview bot token
  - Native preview URL (no separate worker needed)

**Required Secrets**:
- `CLOUDFLARE_API_TOKEN` - API token for Cloudflare Workers
- `CLOUDFLARE_ACCOUNT_ID` - Your Cloudflare account ID
- `BOT_TOKEN` - Production Telegram bot token
- `BOT_TOKEN_PREVIEW` - Preview Telegram bot token

**Purpose**: Automated deployment to Cloudflare Workers with environment-specific configuration.

---

### ü§ñ Dependabot Auto-Merge (`dependabot-auto-merge.yml`)

**Trigger**: Pull requests from Dependabot

**Behavior**:
- **Auto-merge**: Patch and minor version updates
- **Manual review**: Major version updates (adds warning comment)

**Purpose**: Keeps dependencies up-to-date with minimal manual intervention.

---

### üè∑Ô∏è Release Management (`release.yml`)

**Trigger**: Push tags matching `v*.*.*` (e.g., `v1.0.0`)

**Actions**:
1. Runs tests
2. Generates changelog from commits
3. Creates GitHub release
4. Marks as pre-release if version contains alpha/beta/rc

**How to Create a Release**:
```bash
# Tag the commit
git tag v1.0.0

# Push the tag
git push origin v1.0.0
```

**Purpose**: Automated release creation with changelog generation.

---

### ‚úÖ PR Lint (`pr-lint.yml`)

**Trigger**: Pull request opened, edited, or synchronized

**Checks**:
1. **Title Format** - Must follow [Conventional Commits](https://www.conventionalcommits.org/)
   - Types: feat, fix, docs, style, refactor, test, chore, ci, build, perf, revert
   - Example: `feat: Add support for image uploads`

2. **PR Size** - Warns if PR has >1000 line changes

3. **Description** - Ensures PR has a meaningful description (min 50 chars)

4. **Auto-labeling** - Labels PR based on files changed:
   - `bot` - Changes in src/bot/
   - `jules-api` - Changes in src/jules/
   - `storage` - Changes in src/kv/
   - `tests` - Changes in test/
   - `ci/cd` - Changes in .github/
   - `documentation` - Changes to .md files
   - `dependencies` - Changes to package.json
   - `cloudflare` - Changes to wrangler.toml

5. **Statistics** - Comments with PR stats (files changed, additions, deletions, file types)

**Purpose**: Ensures PR quality and consistency.

---

### üîí CodeQL Security Analysis (`codeql.yml`)

**Trigger**:
- Push to main/develop
- Pull requests
- Weekly schedule (Monday 00:00 UTC)

**Analysis**:
- Security vulnerabilities
- Code quality issues
- Uses extended security queries

**Purpose**: Automated security scanning to detect vulnerabilities.

---

### üìä Performance Monitoring (`performance.yml`)

**Trigger**: Pull requests, manual dispatch

**Checks**:
1. **Bundle Size**
   - Measures worker bundle size
   - Warns if exceeds 1MB (Cloudflare Workers Free tier limit)
   - Comments on PR with size report

2. **Test Performance**
   - Runs tests with detailed timing
   - Reports performance metrics

**Purpose**: Monitors bundle size and test performance to prevent regressions.

---

## üì¶ Dependabot Configuration (`dependabot.yml`)

**Schedule**: Weekly on Monday at 09:00 UTC

**Managed Dependencies**:
- npm packages
- GitHub Actions versions

**Behavior**:
- Groups minor and patch updates together
- Ignores wrangler major updates (locked to 3.99.0)
- Auto-assigns to @insign
- Labels: `dependencies`, `automated`

---

## üîê Required Secrets

To use these workflows, configure the following secrets in your GitHub repository:

### Cloudflare
```
CLOUDFLARE_API_TOKEN=<your-cloudflare-api-token>
CLOUDFLARE_ACCOUNT_ID=<your-cloudflare-account-id>
```

### Telegram Bot Tokens
```
BOT_TOKEN=<production-bot-token>
BOT_TOKEN_PREVIEW=<preview-bot-token>
```

### Worker URLs
```
# Production (main branch)
# https://jules-over-telegram.cloudatlas.workers.dev
# Custom domain: https://jot.helio.me (configure in Cloudflare DNS)

# Preview (develop branch)
# https://[random-id]-jules-over-telegram.cloudatlas.workers.dev
# Auto-generated by Cloudflare Workers
```

### Optional
```
CODECOV_TOKEN=<codecov-token>  # For code coverage reporting
```

---

## üéØ Workflow Best Practices

### For Contributors

1. **PR Title**: Use conventional commits format
   - ‚úÖ `feat: Add image upload support`
   - ‚ùå `Added some stuff`

2. **PR Description**: Be descriptive (min 50 characters)
   - Explain what and why
   - Reference related issues

3. **PR Size**: Keep PRs focused and small (<1000 lines when possible)

4. **Tests**: Add tests for new features

5. **Type Safety**: Ensure TypeScript compiles without errors

### For Maintainers

1. **Merging PRs**: Wait for all checks to pass

2. **Creating Releases**:
   ```bash
   git tag v1.0.0
   git push origin v1.0.0
   ```

3. **Emergency Fixes**: Use workflow_dispatch for manual deployments

4. **Monitoring**: Check GitHub Actions dashboard regularly

---

## üêõ Troubleshooting

### Workflow Failed?

1. **Check logs**: Click on the failed job to see details
2. **Common issues**:
   - Missing secrets
   - Type errors
   - Test failures
   - Bundle size too large

### Deployment Failed?

1. **Verify secrets**: Ensure all Cloudflare secrets are set
2. **Check worker quota**: Free tier has limits
3. **Review error logs**: Cloudflare dashboard shows runtime errors

### CodeQL Alerts?

1. **Review alert**: Check the Security tab
2. **Assess severity**: High/Critical should be fixed immediately
3. **Create PR**: Fix the issue and link to the alert

---

## üìö Additional Resources

- [GitHub Actions Documentation](https://docs.github.com/en/actions)
- [Cloudflare Workers Actions](https://github.com/cloudflare/wrangler-action)
- [Conventional Commits](https://www.conventionalcommits.org/)
- [Semantic Versioning](https://semver.org/)

---

## ü§ù Contributing to Workflows

If you want to improve these workflows:

1. Test changes in a fork first
2. Document any new secrets required
3. Update this README with changes
4. Submit a PR with `ci:` prefix in title

---

*Last updated: 2025-11-03*
</file>

<file path="src/bot/commands/actionCommands.ts">
/**
 * Action command handlers
 * Commands for performing actions on sessions
 */

import type { BotContext } from '../bot';
import { getGroupId, getTopicId, isUserAdmin, updateTopicTitle } from '../bot';
import {
  getJulesToken,
  getSource,
  getDefaultBranch,
  getAutomationMode,
  getRequireApproval,
  getSession,
  setSession,
  deleteSession as deleteSessionKV,
  removeFromSessionsIndex,
  addToSessionsIndex,
  setPendingPlan,
} from '../../kv/storage';
import { createJulesClient, isSessionNotFoundError } from '../../jules/api';
import { parseSourceToRepoInfo } from '../../utils/github';
import { InlineKeyboard } from 'grammy';
import type { SessionData } from '../../types/env';

/**
 * /new_session command
 * Create a new Jules session in the current topic
 */
export async function handleNewSession(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);
  const topicId = getTopicId(ctx);

  if (!groupId || !topicId) {
    await ctx.reply('‚ö†Ô∏è This command must be used in a topic.');
    return;
  }

  const text = ctx.message?.text || '';
  const parts = text.split(' ');

  if (parts.length < 2) {
    await ctx.reply(
      '‚ö†Ô∏è Please provide a prompt.\n\n' +
      'Usage: /new_session &lt;prompt&gt;\n\n' +
      'Example: /new_session Add a dark mode toggle to the settings page',
      { parse_mode: 'HTML' }
    );
    return;
  }

  const prompt = parts.slice(1).join(' ').trim();

  // Check if session already exists for this topic
  const existingSession = await getSession(ctx.env, groupId, topicId);

  if (existingSession) {
    await ctx.reply(
      '‚ö†Ô∏è This topic already has a session.\n\n' +
      'Use the topic to continue the conversation, or delete the session with /delete_session first.'
    );
    return;
  }

  const token = await getJulesToken(ctx.env, groupId);

  if (!token) {
    await ctx.reply(
      '‚ö†Ô∏è Jules token not configured.\n\n' +
      'Admin: Use /set_jules_token &lt;token&gt; to get started.',
      { parse_mode: 'HTML' }
    );
    return;
  }

  const source = await getSource(ctx.env, groupId);

  if (!source) {
    await ctx.reply(
      '‚ö†Ô∏è No source configured.\n\n' +
      'Admin: Use /list_sources and /set_source to configure a repository.',
      { parse_mode: 'HTML' }
    );
    return;
  }

  await ctx.reply('üîÑ Creating Jules session...');

  try {
    const julesClient = createJulesClient(token);

    const defaultBranch = await getDefaultBranch(ctx.env, groupId);
    const automationMode = await getAutomationMode(ctx.env, groupId);
    const requireApproval = await getRequireApproval(ctx.env, groupId);

    const createParams: any = {
      prompt,
      source,
      requirePlanApproval: requireApproval,
      startingBranch: defaultBranch || undefined,
    };

    // Only add automationMode if explicitly configured
    if (automationMode) {
      createParams.automationMode = automationMode;
    }

    const session = await julesClient.createSession(createParams);

    // Store session in KV
    const sessionData: SessionData = {
      session_id: session.name,
      group_id: groupId,
      topic_id: topicId,
      source: session.source,
      automation_mode: session.automationMode,
      require_plan_approval: session.requirePlanApproval,
      starting_branch: session.startingBranch,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };

    await setSession(ctx.env, groupId, topicId, sessionData);
    await addToSessionsIndex(ctx.env, groupId, session.name);

    // Update topic title with repo and session info
    const repoInfo = parseSourceToRepoInfo(source);
    if (repoInfo) {
      await updateTopicTitle(ctx, groupId, topicId, repoInfo.owner, repoInfo.repo, session.name);
    }

    await ctx.reply(
      '‚úÖ <b>Session created successfully!</b>\n\n' +
      `<b>Session ID:</b> <code>${session.name}</code>\n` +
      `<b>Source:</b> ${source}\n` +
      `<b>Mode:</b> ${session.automationMode || 'INTERACTIVE'}\n\n` +
      'I will send you updates automatically as Jules works on your request.',
      { parse_mode: 'HTML' }
    );
  } catch (error) {
    console.error('Error creating session:', error);
    await ctx.reply(
      '‚ùå Failed to create session.\n\n' +
      'Error: ' + (error instanceof Error ? error.message : 'Unknown error')
    );
  }
}

/**
 * /approve_plan command
 * Approve a pending plan for the current session
 */
export async function handleApprovePlan(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);
  const topicId = getTopicId(ctx);

  if (!groupId || !topicId) {
    await ctx.reply('‚ö†Ô∏è This command must be used in a topic.');
    return;
  }

  const session = await getSession(ctx.env, groupId, topicId);

  if (!session) {
    await ctx.reply('‚ö†Ô∏è No session found for this topic.');
    return;
  }

  const token = await getJulesToken(ctx.env, groupId);

  if (!token) {
    await ctx.reply('‚ö†Ô∏è Jules token not configured.');
    return;
  }

  await ctx.reply('üîÑ Approving plan...');

  try {
    const julesClient = createJulesClient(token);
    await julesClient.approvePlan(session.session_id);

    // Clear pending plan flag
    await setPendingPlan(ctx.env, groupId, topicId, false);

    await ctx.reply(
      '‚úÖ <b>Plan approved!</b>\n\nJules will start working on the implementation.',
      { parse_mode: 'HTML', disable_notification: true }
    );
  } catch (error) {
    console.error('Error approving plan:', error);
    await ctx.reply(
      '‚ùå Failed to approve plan.\n\n' +
      'Error: ' + (error instanceof Error ? error.message : 'Unknown error')
    );
  }
}

/**
 * /delete_session command
 * Delete the current session (admin only)
 */
export async function handleDeleteSession(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);
  const topicId = getTopicId(ctx);

  if (!groupId || !topicId) {
    await ctx.reply('‚ö†Ô∏è This command must be used in a topic.');
    return;
  }

  if (!(await isUserAdmin(ctx))) {
    await ctx.reply('‚ö†Ô∏è Only admins can delete sessions.');
    return;
  }

  const session = await getSession(ctx.env, groupId, topicId);

  if (!session) {
    await ctx.reply('‚ö†Ô∏è No session found for this topic.');
    return;
  }

  // Show confirmation button
  const keyboard = new InlineKeyboard()
    .text('‚ö†Ô∏è Confirm Deletion', `delete_session:${session.session_id}`)
    .text('‚ùå Cancel', 'cancel_delete');

  await ctx.reply(
    '‚ö†Ô∏è <b>Delete Session</b>\n\n' +
    `Are you sure you want to delete this session?\n\n` +
    `<b>Session ID:</b> <code>${session.session_id}</code>\n\n` +
    '<i>Note: This will only remove the session from this bot. To delete it permanently, visit jules.google</i>',
    {
      parse_mode: 'HTML',
      reply_markup: keyboard,
    }
  );
}

/**
 * /sync command
 * Manually synchronize sessions with Jules API (admin only)
 */
export async function handleSync(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);

  if (!groupId) {
    await ctx.reply('This command only works in group chats.');
    return;
  }

  if (!(await isUserAdmin(ctx))) {
    await ctx.reply('‚ö†Ô∏è Only admins can sync sessions.');
    return;
  }

  const token = await getJulesToken(ctx.env, groupId);

  if (!token) {
    await ctx.reply(
      '‚ö†Ô∏è Jules token not configured.\n\n' +
      'Use /set_jules_token &lt;token&gt; to get started.',
      { parse_mode: 'HTML' }
    );
    return;
  }

  await ctx.reply('üîÑ Synchronizing sessions with Jules...');

  try {
    const julesClient = createJulesClient(token);
    const remoteSessions = await julesClient.listSessions();

    let syncCount = 0;
    let removeCount = 0;

    // TODO: Implement full sync logic
    // This would involve:
    // 1. Getting all local sessions from KV
    // 2. Comparing with remote sessions
    // 3. Removing deleted sessions
    // 4. Updating status for existing sessions

    await ctx.reply(
      `‚úÖ <b>Sync Complete</b>\n\n` +
      `Synced: ${syncCount}\n` +
      `Removed: ${removeCount}\n\n` +
      `Total sessions: ${remoteSessions.length}`,
      { parse_mode: 'HTML' }
    );
  } catch (error) {
    console.error('Error syncing sessions:', error);
    await ctx.reply(
      '‚ùå Failed to sync sessions.\n\n' +
      'Error: ' + (error instanceof Error ? error.message : 'Unknown error')
    );
  }
}
</file>

<file path="src/bot/commands/configCommands.ts">
/**
 * Configuration command handlers
 * Admin-only commands for configuring group settings
 */

import type { BotContext } from '../bot';
import { getGroupId, isUserAdmin } from '../bot';
import {
  setJulesToken,
  setSource,
  setDefaultBranch,
  setAutomationMode,
  setRequireApproval,
} from '../../kv/storage';
import { createJulesClient } from '../../jules/api';

/**
 * /set_jules_token command
 * Configure Jules API token for the group
 */
export async function handleSetJulesToken(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);

  if (!groupId) {
    await ctx.reply('This command only works in group chats.');
    return;
  }

  // Check if user is admin
  if (!(await isUserAdmin(ctx))) {
    await ctx.reply('‚ö†Ô∏è Only admins can configure the Jules token.');
    return;
  }

  // Extract token from command
  const text = ctx.message?.text || '';
  const parts = text.split(' ');

  if (parts.length < 2) {
    await ctx.reply(
      '‚ö†Ô∏è Please provide the Jules API token.\n\n' +
      'Usage: /set_jules_token &lt;token&gt;\n\n' +
      'Get your token from: https://jules.google',
      { parse_mode: 'HTML' }
    );
    return;
  }

  const token = parts.slice(1).join(' ').trim();

  // Validate token by making a test API call
  await ctx.reply('üîÑ Validating token...');

  try {
    const julesClient = createJulesClient(token);
    const isValid = await julesClient.validateToken();

    if (!isValid) {
      await ctx.reply('‚ùå Invalid token. Please check your Jules API key and try again.');
      return;
    }

    // Store token in KV
    await setJulesToken(ctx.env, groupId, token);

    await ctx.reply(
      '‚úÖ Jules token configured successfully!\n\n' +
      'Next steps:\n' +
      '1. Use /list_sources to see available repositories\n' +
      '2. Use /set_source &lt;source&gt; to set a default repository\n' +
      '3. Create a topic and start chatting!',
      { parse_mode: 'HTML' }
    );
  } catch (error) {
    console.error('Error validating Jules token:', error);
    await ctx.reply(
      '‚ùå Failed to validate token. Please check your Jules API key.\n\n' +
      'Error: ' + (error instanceof Error ? error.message : 'Unknown error')
    );
  }
}

/**
 * /set_source command
 * Set default source (repository) for the group
 */
export async function handleSetSource(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);

  if (!groupId) {
    await ctx.reply('This command only works in group chats.');
    return;
  }

  if (!(await isUserAdmin(ctx))) {
    await ctx.reply('‚ö†Ô∏è Only admins can configure the source.');
    return;
  }

  const text = ctx.message?.text || '';
  const parts = text.split(' ');

  if (parts.length < 2) {
    await ctx.reply(
      '‚ö†Ô∏è Please provide the source name.\n\n' +
      'Usage: /set_source &lt;source&gt;\n\n' +
      'Use /list_sources to see available sources.\n' +
      'Example: /set_source sources/github/user/repo',
      { parse_mode: 'HTML' }
    );
    return;
  }

  const source = parts.slice(1).join(' ').trim();

  // Store source in KV
  await setSource(ctx.env, groupId, source);

  await ctx.reply(
    `‚úÖ Default source set to:\n<code>${source}</code>\n\n` +
    'This source will be used for new sessions.\n' +
    'Use /open_jules_settings to configure advanced settings for this repository.',
    { parse_mode: 'HTML' }
  );
}

/**
 * /set_branch command
 * Set default starting branch for sessions
 */
export async function handleSetBranch(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);

  if (!groupId) {
    await ctx.reply('This command only works in group chats.');
    return;
  }

  if (!(await isUserAdmin(ctx))) {
    await ctx.reply('‚ö†Ô∏è Only admins can configure the default branch.');
    return;
  }

  const text = ctx.message?.text || '';
  const parts = text.split(' ');

  if (parts.length < 2) {
    await ctx.reply(
      '‚ö†Ô∏è Please provide the branch name.\n\n' +
      'Usage: /set_branch &lt;branch&gt;\n\n' +
      'Example: /set_branch main',
      { parse_mode: 'HTML' }
    );
    return;
  }

  const branch = parts.slice(1).join(' ').trim();

  await setDefaultBranch(ctx.env, groupId, branch);

  await ctx.reply(
    `‚úÖ Default branch set to: <code>${branch}</code>\n\n` +
    'This branch will be used as the starting point for new sessions.',
    { parse_mode: 'HTML' }
  );
}

/**
 * /set_auto_pr command
 * Configure automatic PR creation mode
 */
export async function handleSetAutoPR(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);

  if (!groupId) {
    await ctx.reply('This command only works in group chats.');
    return;
  }

  if (!(await isUserAdmin(ctx))) {
    await ctx.reply('‚ö†Ô∏è Only admins can configure automation mode.');
    return;
  }

  const text = ctx.message?.text || '';
  const parts = text.split(' ');

  if (parts.length < 2) {
    await ctx.reply(
      '‚ö†Ô∏è Please specify on or off.\n\n' +
      'Usage: /set_auto_pr &lt;on|off&gt;\n\n' +
      'on = AUTO mode (automatic PR creation)\n' +
      'off = INTERACTIVE mode (manual control)',
      { parse_mode: 'HTML' }
    );
    return;
  }

  const value = parts[1].toLowerCase();

  if (value !== 'on' && value !== 'off') {
    await ctx.reply('‚ö†Ô∏è Please use "on" or "off".');
    return;
  }

  const mode = value === 'on' ? 'AUTO' : 'INTERACTIVE';

  await setAutomationMode(ctx.env, groupId, mode);

  await ctx.reply(
    `‚úÖ Automation mode set to: <b>${mode}</b>\n\n` +
    (mode === 'AUTO'
      ? 'Jules will automatically create PRs when sessions are complete.'
      : 'You will have manual control over when to publish branches and PRs.'),
    { parse_mode: 'HTML' }
  );
}

/**
 * /require_approval command
 * Configure whether to require plan approval
 */
export async function handleRequireApproval(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);

  if (!groupId) {
    await ctx.reply('This command only works in group chats.');
    return;
  }

  if (!(await isUserAdmin(ctx))) {
    await ctx.reply('‚ö†Ô∏è Only admins can configure plan approval settings.');
    return;
  }

  const text = ctx.message?.text || '';
  const parts = text.split(' ');

  if (parts.length < 2) {
    await ctx.reply(
      '‚ö†Ô∏è Please specify on or off.\n\n' +
      'Usage: /require_approval &lt;on|off&gt;\n\n' +
      'on = Jules will wait for your approval before executing plans\n' +
      'off = Jules will automatically execute plans',
      { parse_mode: 'HTML' }
    );
    return;
  }

  const value = parts[1].toLowerCase();

  if (value !== 'on' && value !== 'off') {
    await ctx.reply('‚ö†Ô∏è Please use "on" or "off".');
    return;
  }

  const require = value === 'on';

  await setRequireApproval(ctx.env, groupId, require);

  await ctx.reply(
    `‚úÖ Plan approval ${require ? 'enabled' : 'disabled'}.\n\n` +
    (require
      ? 'Jules will wait for your approval before executing plans. You will see an "Approve Plan" button when a plan is generated.'
      : 'Jules will automatically execute plans without waiting for approval.'),
    { parse_mode: 'HTML' }
  );
}
</file>

<file path="src/bot/handlers/messageHandlers.ts">
/**
 * Message handlers
 * Handles text and photo messages for continuous conversation with Jules
 */

import type { BotContext } from '../bot';
import { getGroupId, getTopicId, startTypingLoop, updateTopicTitle } from '../bot';
import {
  getJulesToken,
  getSource,
  getSession,
  setSession,
  addToSessionsIndex,
  getDefaultBranch,
  getAutomationMode,
  getRequireApproval,
} from '../../kv/storage';
import { createJulesClient } from '../../jules/api';
import { downloadAndConvertImageToBase64 } from '../../utils/image';
import { parseSourceToRepoInfo } from '../../utils/github';
import type { SessionData } from '../../types/env';

/**
 * Handle text messages in topics
 * Creates new session or sends message to existing session
 */
export async function handleTextMessage(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);
  const topicId = getTopicId(ctx);

  // Ignore messages not in topics
  if (!groupId || !topicId) {
    return;
  }

  // Ignore commands (they have their own handlers)
  const text = ctx.message?.text || '';
  if (text.startsWith('/')) {
    return;
  }

  const token = await getJulesToken(ctx.env, groupId);

  if (!token) {
    await ctx.reply(
      '‚ö†Ô∏è Jules token not configured.\n\n' +
      'Admin: Use /set_jules_token &lt;token&gt; to get started.',
      { parse_mode: 'HTML' }
    );
    return;
  }

  const source = await getSource(ctx.env, groupId);

  if (!source) {
    await ctx.reply(
      '‚ö†Ô∏è No source configured.\n\n' +
      'Admin: Use /list_sources and /set_source to configure a repository.',
      { parse_mode: 'HTML' }
    );
    return;
  }

  // Check if session exists for this topic
  let session = await getSession(ctx.env, groupId, topicId);

  const julesClient = createJulesClient(token);

  try {
    if (!session) {
      // Create new session
      const stopTyping = startTypingLoop(ctx);

      try {
        const defaultBranch = await getDefaultBranch(ctx.env, groupId);
        const automationMode = await getAutomationMode(ctx.env, groupId);
        const requireApproval = await getRequireApproval(ctx.env, groupId);

        const createParams: any = {
          prompt: text,
          source,
          requirePlanApproval: requireApproval,
          startingBranch: defaultBranch || undefined,
        };

        // Only add automationMode if explicitly configured
        if (automationMode) {
          createParams.automationMode = automationMode;
        }

        const julesSession = await julesClient.createSession(createParams);

        // Store session in KV
        const sessionData: SessionData = {
          session_id: julesSession.name,
          group_id: groupId,
          topic_id: topicId,
          source: julesSession.source,
          automation_mode: julesSession.automationMode,
          require_plan_approval: julesSession.requirePlanApproval,
          starting_branch: julesSession.startingBranch,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        };

        await setSession(ctx.env, groupId, topicId, sessionData);
        await addToSessionsIndex(ctx.env, groupId, julesSession.name);

        // Update topic title
        const repoInfo = parseSourceToRepoInfo(source);
        if (repoInfo) {
          await updateTopicTitle(ctx, groupId, topicId, repoInfo.owner, repoInfo.repo, julesSession.name);
        }

        stopTyping();

        await ctx.reply(
          '‚úÖ <b>Session created!</b>\n\n' +
          'I will send you updates automatically as Jules works on your request.',
          { parse_mode: 'HTML', disable_notification: true }
        );
      } finally {
        stopTyping();
      }
    } else {
      // Send message to existing session
      const stopTyping = startTypingLoop(ctx);

      try {
        await julesClient.sendMessage(session.session_id, {
          prompt: text,
        });

        stopTyping();

        await ctx.reply(
          '‚úÖ Message sent to Jules.',
          { disable_notification: true }
        );
      } finally {
        stopTyping();
      }
    }
  } catch (error) {
    console.error('Error handling text message:', error);
    await ctx.reply(
      '‚ùå Failed to process message.\n\n' +
      'Error: ' + (error instanceof Error ? error.message : 'Unknown error')
    );
  }
}

/**
 * Handle photo messages in topics
 * Downloads photo, converts to base64, and sends to Jules
 */
export async function handlePhotoMessage(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);
  const topicId = getTopicId(ctx);

  // Ignore photos not in topics
  if (!groupId || !topicId) {
    return;
  }

  const token = await getJulesToken(ctx.env, groupId);

  if (!token) {
    await ctx.reply(
      '‚ö†Ô∏è Jules token not configured.\n\n' +
      'Admin: Use /set_jules_token &lt;token&gt; to get started.',
      { parse_mode: 'HTML' }
    );
    return;
  }

  const source = await getSource(ctx.env, groupId);

  if (!source) {
    await ctx.reply(
      '‚ö†Ô∏è No source configured.\n\n' +
      'Admin: Use /list_sources and /set_source to configure a repository.',
      { parse_mode: 'HTML' }
    );
    return;
  }

  // Get highest resolution photo
  const photos = ctx.message?.photo;
  if (!photos || photos.length === 0) {
    return;
  }

  const photo = photos[photos.length - 1];

  // Get caption (or use default)
  const caption = ctx.message?.caption || 'Analyze this image';

  await ctx.reply('üîÑ Processing image...');

  try {
    // Download and convert image to base64
    const file = await ctx.api.getFile(photo.file_id);

    if (!file.file_path) {
      await ctx.reply('‚ùå Failed to get image file path.');
      return;
    }

    const imageData = await downloadAndConvertImageToBase64(file.file_path, ctx.env.BOT_TOKEN);

    if (!imageData) {
      await ctx.reply('‚ùå Failed to download or convert image. Please try again.');
      return;
    }

    // Check if session exists for this topic
    let session = await getSession(ctx.env, groupId, topicId);

    const julesClient = createJulesClient(token);

    if (!session) {
      // Create new session with image
      const stopTyping = startTypingLoop(ctx);

      try {
        const defaultBranch = await getDefaultBranch(ctx.env, groupId);
        const automationMode = await getAutomationMode(ctx.env, groupId);
        const requireApproval = await getRequireApproval(ctx.env, groupId);

        const createParams: any = {
          prompt: caption,
          source,
          requirePlanApproval: requireApproval,
          startingBranch: defaultBranch || undefined,
          media: imageData,
        };

        // Only add automationMode if explicitly configured
        if (automationMode) {
          createParams.automationMode = automationMode;
        }

        const julesSession = await julesClient.createSession(createParams);

        // Store session in KV
        const sessionData: SessionData = {
          session_id: julesSession.name,
          group_id: groupId,
          topic_id: topicId,
          source: julesSession.source,
          automation_mode: julesSession.automationMode,
          require_plan_approval: julesSession.requirePlanApproval,
          starting_branch: julesSession.startingBranch,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        };

        await setSession(ctx.env, groupId, topicId, sessionData);
        await addToSessionsIndex(ctx.env, groupId, julesSession.name);

        // Update topic title
        const repoInfo = parseSourceToRepoInfo(source);
        if (repoInfo) {
          await updateTopicTitle(ctx, groupId, topicId, repoInfo.owner, repoInfo.repo, julesSession.name);
        }

        stopTyping();

        await ctx.reply(
          '‚úÖ <b>Session created with image!</b>\n\n' +
          'I will send you updates automatically as Jules works on your request.',
          { parse_mode: 'HTML', disable_notification: true }
        );
      } finally {
        stopTyping();
      }
    } else {
      // Send message with image to existing session
      const stopTyping = startTypingLoop(ctx);

      try {
        await julesClient.sendMessage(session.session_id, {
          prompt: caption,
          media: imageData,
        });

        stopTyping();

        await ctx.reply(
          '‚úÖ Image sent to Jules.',
          { disable_notification: true }
        );
      } finally {
        stopTyping();
      }
    }
  } catch (error) {
    console.error('Error handling photo message:', error);
    await ctx.reply(
      '‚ùå Failed to process image.\n\n' +
      'Error: ' + (error instanceof Error ? error.message : 'Unknown error')
    );
  }
}
</file>

<file path="src/types/env.ts">
/**
 * Environment bindings for Cloudflare Worker
 * This interface defines all the bindings available in the worker environment
 */
export interface Env {
  // KV Namespace for multi-tenant storage
  KV: KVNamespace;

  // Bot token from Telegram (@BotFather)
  BOT_TOKEN: string;

  // Environment name (development, production)
  ENVIRONMENT?: string;
}

/**
 * Session data structure stored in KV
 * Maps 1:1 with a Telegram topic and a Jules session
 */
export interface SessionData {
  session_id: string;
  group_id: string;
  topic_id: number;
  source: string;
  automation_mode?: 'INTERACTIVE' | 'PLAN' | 'AUTO';
  require_plan_approval?: boolean;
  starting_branch?: string;
  last_activity_id?: string;
  last_activity_time?: string;
  status?: string;
  pending_plan?: boolean;
  ready_for_review?: boolean;
  created_at: string;
  updated_at: string;
}

/**
 * Group configuration structure
 * Stores per-group settings
 */
export interface GroupConfig {
  jules_token: string;
  source?: string;
  default_branch?: string;
  automation_mode?: 'INTERACTIVE' | 'PLAN' | 'AUTO';
  require_approval?: boolean;
  sessions_index?: string[]; // Array of session_ids
}

/**
 * Jules API Activity structure
 * Based on Jules API documentation
 */
export interface JulesActivity {
  name: string;
  createTime: string;
  updateTime: string;
  title?: string;
  description?: string;
  artifacts?: {
    bashOutput?: {
      command?: string;
      output?: string;
      exitCode?: number;
    };
    changeSet?: {
      gitPatch?: {
        unidiffPatch?: string;
      };
      files?: Array<{
        path?: string;
        changeType?: string;
      }>;
    };
    media?: {
      data?: string;
      mediaType?: string;
    };
  };
}

/**
 * Jules API Session structure
 */
export interface JulesSession {
  name: string;
  source: string;
  prompt: string;
  state?: string;
  automationMode?: 'INTERACTIVE' | 'PLAN' | 'AUTO';
  requirePlanApproval?: boolean;
  startingBranch?: string;
  outputs?: string;
  createTime: string;
  updateTime: string;
}

/**
 * Jules API Source structure
 */
export interface JulesSource {
  name: string;
  displayName: string;
  description?: string;
  repository?: {
    owner?: string;
    name?: string;
  };
}
</file>

<file path="src/index.ts">
/**
 * Jot - Telegram Interface for Jules
 * Main Cloudflare Worker entry point
 *
 * This worker provides a Telegram bot interface for Jules (Google's AI coding assistant)
 * Features:
 * - Multi-tenant support (each Telegram group is isolated)
 * - 1:1 mapping between Telegram topics and Jules sessions
 * - Automatic activity polling via cron triggers
 * - Image support (send screenshots/designs to Jules)
 * - Smart notifications (important events with sound, others silent)
 * - GitHub links extraction and formatting
 *
 * License: AGPL-3.0-or-later
 */

import { createBot, createWebhookHandler } from './bot/bot';
import type { BotContext } from './bot/bot';
import type { Env } from './types/env';

// Import command handlers
import { handleStart, handleHelp } from './bot/commands/basicCommands';
import {
  handleSetJulesToken,
  handleSetSource,
  handleSetBranch,
  handleSetAutoPR,
  handleRequireApproval,
} from './bot/commands/configCommands';
import {
  handleStatus,
  handleGetSource,
  handleListSources,
  handleSearchSources,
  handleListSessions,
  handleSessionInfo,
  handleListActivities,
  handleShowPlan,
  handleShowOutputs,
  handleOpenJulesSettings,
} from './bot/commands/infoCommands';
import {
  handleNewSession,
  handleApprovePlan,
  handleDeleteSession,
  handleSync,
} from './bot/commands/actionCommands';

// Import message handlers
import { handleTextMessage, handlePhotoMessage } from './bot/handlers/messageHandlers';
import { handleCallbackQuery } from './bot/handlers/callbackHandlers';

// Import cron handlers
import { pollActivities } from './cron/pollActivities';
import { syncSessions } from './cron/syncSessions';

/**
 * Setup bot with all command and message handlers
 */
function setupBot(bot: ReturnType<typeof createBot>): void {
  // Basic commands
  bot.command('start', handleStart);
  bot.command('help', handleHelp);

  // Configuration commands (admin only)
  bot.command('set_jules_token', handleSetJulesToken);
  bot.command('set_source', handleSetSource);
  bot.command('set_branch', handleSetBranch);
  bot.command('set_auto_pr', handleSetAutoPR);
  bot.command('require_approval', handleRequireApproval);

  // Information commands
  bot.command('status', handleStatus);
  bot.command('get_source', handleGetSource);
  bot.command('list_sources', handleListSources);
  bot.command('search_sources', handleSearchSources);
  bot.command('list_sessions', handleListSessions);
  bot.command('session_info', handleSessionInfo);
  bot.command('list_activities', handleListActivities);
  bot.command('show_plan', handleShowPlan);
  bot.command('show_outputs', handleShowOutputs);
  bot.command('open_jules_settings', handleOpenJulesSettings);

  // Action commands
  bot.command('new_session', handleNewSession);
  bot.command('approve_plan', handleApprovePlan);
  bot.command('delete_session', handleDeleteSession);
  bot.command('sync', handleSync);

  // Message handlers
  bot.on('message:text', handleTextMessage);
  bot.on('message:photo', handlePhotoMessage);

  // Callback query handlers (inline buttons)
  bot.on('callback_query:data', handleCallbackQuery);

  // Error handler
  bot.catch((err) => {
    console.error('Bot error:', err);
  });
}

/**
 * Main Worker export
 * Handles HTTP requests (webhooks) and scheduled events (cron)
 */
export default {
  /**
   * Handle HTTP requests (Telegram webhook)
   */
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    // Check if request is from Telegram
    const url = new URL(request.url);

    // Health check endpoint
    if (url.pathname === '/health') {
      return new Response('OK', { status: 200 });
    }

    // Webhook endpoint
    if (url.pathname === '/' || url.pathname === '/webhook') {
      try {
        // Create bot instance
        const bot = createBot(env.BOT_TOKEN, env);

        // Setup handlers
        setupBot(bot);

        // Handle webhook
        const webhookHandler = createWebhookHandler(bot);
        return await webhookHandler(request);
      } catch (error) {
        console.error('Error handling webhook:', error);
        return new Response('Internal Server Error', { status: 500 });
      }
    }

    // Unknown endpoint
    return new Response('Not Found', { status: 404 });
  },

  /**
   * Handle scheduled events (cron triggers)
   */
  async scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext): Promise<void> {
    console.log('[CRON] Scheduled event triggered:', event.cron);

    try {
      // Determine which cron job to run based on schedule
      // Note: Cloudflare doesn't pass the cron pattern, so we need to infer it

      // For now, we'll run both jobs on every trigger
      // In production, you should use different endpoints or time-based logic

      // Check the minute to determine which job to run
      const now = new Date();
      const minute = now.getMinutes();

      if (minute % 15 === 0) {
        // Run session sync every 15 minutes
        console.log('[CRON] Running session sync...');
        await syncSessions(env);
      }

      // Run activity polling every minute
      console.log('[CRON] Running activity polling...');
      await pollActivities(env);

      console.log('[CRON] Scheduled event complete');
    } catch (error) {
      console.error('[CRON] Error in scheduled event:', error);
    }
  },
};
</file>

<file path=".github/workflows/ci.yml">
name: CI

on:
  push:
    branches:
      - main
      - develop
      - 'claude/**'
  pull_request:
    branches:
      - main
      - develop

jobs:
  # Job 1: Lint and Type Check
  lint-and-typecheck:
    name: Lint & Type Check
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run TypeScript type check
        run: npx tsc --noEmit

      - name: Check code formatting (if prettier is configured)
        run: |
          if [ -f ".prettierrc" ] || [ -f "prettier.config.js" ]; then
            npx prettier --check "src/**/*.ts" "test/**/*.ts"
          else
            echo "Prettier not configured, skipping"
          fi
        continue-on-error: true

  # Job 2: Run Tests
  test:
    name: Run Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test run

      - name: Upload coverage reports (if generated)
        uses: codecov/codecov-action@v5
        if: success()
        continue-on-error: true
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage/coverage-final.json
          flags: unittests
          name: codecov-umbrella

  # Job 3: Build Check
  build:
    name: Build Check
    runs-on: ubuntu-latest
    needs: [lint-and-typecheck, test]

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build with Wrangler
        run: npx wrangler deploy --dry-run --outdir=dist
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}

      - name: Check dist directory
        run: |
          if [ -d "dist" ]; then
            echo "Build successful, dist directory created"
            ls -la dist/
          else
            echo "Warning: dist directory not created"
          fi

  # Job 4: Security Audit
  security:
    name: Security Audit
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Run npm audit
        run: npm audit --audit-level=moderate
        continue-on-error: true

      - name: Check for known vulnerabilities
        run: |
          echo "Checking for critical vulnerabilities..."
          npm audit --audit-level=critical

  # Job 5: All Checks Passed
  all-checks:
    name: All Checks Passed
    runs-on: ubuntu-latest
    needs: [lint-and-typecheck, test, build, security]
    if: success()

    steps:
      - name: All checks passed
        run: |
          echo "‚úÖ All CI checks passed successfully!"
          echo "Ready for deployment or merge."
</file>

<file path=".github/workflows/deploy.yml">
name: Deploy to Cloudflare Workers

on:
  push:
    branches:
      - main  # Production deployment
      - develop  # Preview deployment
  workflow_dispatch:  # Allow manual deployment

jobs:
  # Deploy to Production (main branch)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://jules-over-telegram.cloudatlas.workers.dev

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test run

      - name: Deploy to Cloudflare Workers (Production)
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: deploy
        env:
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}

      - name: Set Telegram Webhook (Production)
        run: |
          WORKER_URL="https://jules-over-telegram.cloudatlas.workers.dev"
          BOT_TOKEN="${{ secrets.BOT_TOKEN }}"

          curl -s "https://api.telegram.org/bot${BOT_TOKEN}/setWebhook?url=${WORKER_URL}/webhook"
          echo "Webhook set to: ${WORKER_URL}/webhook"

      - name: Verify deployment
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" "https://jules-over-telegram.cloudatlas.workers.dev/health")
          if [ "$response" -eq 200 ]; then
            echo "‚úÖ Deployment successful! Health check passed."
          else
            echo "‚ö†Ô∏è Health check failed with status: $response"
            exit 1
          fi

      - name: Create deployment summary
        run: |
          echo "## üöÄ Production Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: Production" >> $GITHUB_STEP_SUMMARY
          echo "- **Worker URL**: https://jules-over-telegram.cloudatlas.workers.dev" >> $GITHUB_STEP_SUMMARY
          echo "- **Custom Domain**: https://jot.helio.me" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: main" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY

  # Deploy to Preview (develop branch)
  deploy-preview:
    name: Deploy to Preview
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment:
      name: preview
      url: https://jules-over-telegram-cloudatlas.preview.pages.dev

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test run

      - name: Deploy to Cloudflare Workers (Preview)
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: deploy --preview
        env:
          BOT_TOKEN: ${{ secrets.BOT_TOKEN_PREVIEW }}

      - name: Get preview URL
        id: wrangler
        run: |
          npx wrangler whoami
          npx wrangler deploy --dry-run --outdir=dist 2>&1 | tee deploy.log
          PREVIEW_URL=$(grep -o 'https://[^[:space:]]*jules-over-telegram[[:space:]]' deploy.log | head -1)
          echo "preview_url=${PREVIEW_URL}" >> $GITHUB_OUTPUT

      - name: Set Telegram Webhook (Preview)
        run: |
          WORKER_URL="${{ steps.wrangler.outputs.preview_url }}"
          BOT_TOKEN="${{ secrets.BOT_TOKEN_PREVIEW }}"

          if [ -n "$WORKER_URL" ] && [ -n "$BOT_TOKEN" ]; then
            curl -s "https://api.telegram.org/bot${BOT_TOKEN}/setWebhook?url=${WORKER_URL}/webhook"
            echo "Webhook set to: ${WORKER_URL}/webhook"
          else
            echo "Warning: Preview URL or BOT_TOKEN_PREVIEW not set"
          fi

      - name: Create deployment summary
        run: |
          echo "## üöß Preview Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: Preview" >> $GITHUB_STEP_SUMMARY
          echo "- **Worker URL**: ${{ steps.wrangler.outputs.preview_url }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: develop" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
</file>

<file path=".github/workflows/performance.yml">
name: Performance Monitoring

on:
  pull_request:
    branches: [ "main", "develop" ]
  workflow_dispatch:

jobs:
  bundle-size:
    name: Check Bundle Size
    runs-on: ubuntu-latest

    steps:
      - name: Checkout PR
        uses: actions/checkout@v5

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build worker
        run: npx wrangler deploy --dry-run --outdir=dist

      - name: Check bundle size
        id: bundle-size
        run: |
          if [ -f "dist/index.js" ]; then
            SIZE=$(stat -f%z dist/index.js 2>/dev/null || stat -c%s dist/index.js)
            SIZE_KB=$((SIZE / 1024))
            echo "size_kb=$SIZE_KB" >> $GITHUB_OUTPUT
            echo "Bundle size: ${SIZE_KB}KB"

            # Warn if bundle is larger than 1MB
            if [ $SIZE_KB -gt 1024 ]; then
              echo "‚ö†Ô∏è Bundle size is larger than 1MB: ${SIZE_KB}KB"
              echo "bundle_warning=true" >> $GITHUB_OUTPUT
            else
              echo "‚úÖ Bundle size is acceptable: ${SIZE_KB}KB"
              echo "bundle_warning=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è Bundle file not found"
            exit 1
          fi

      - name: Comment bundle size
        if: always()
        uses: actions/github-script@v8
        with:
          script: |
            const sizeKb = '${{ steps.bundle-size.outputs.size_kb }}';
            const hasWarning = '${{ steps.bundle-size.outputs.bundle_warning }}' === 'true';

            const comment = `## üì¶ Bundle Size Report

            ${hasWarning ? '‚ö†Ô∏è' : '‚úÖ'} Bundle size: **${sizeKb}KB**

            ${hasWarning ? `
            > **Warning**: Bundle size exceeds 1MB. Consider:
            > - Tree-shaking unused code
            > - Lazy loading heavy dependencies
            > - Removing duplicate dependencies
            ` : ''}

            ### Limits:
            - Cloudflare Workers Free: 1MB (${hasWarning ? '**EXCEEDED**' : 'OK'})
            - Cloudflare Workers Paid: 10MB (OK)

            ---
            *This comment was automatically generated by Performance Monitoring workflow*
            `;

            // Check if we already commented
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Bundle Size Report')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }

  test-performance:
    name: Test Performance
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests with timing
        run: |
          echo "Running tests with detailed timing..."
          npm test run -- --reporter=verbose

      - name: Create performance summary
        run: |
          echo "## üöÄ Performance Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Tests completed successfully. Check logs for detailed timing." >> $GITHUB_STEP_SUMMARY
</file>

<file path=".github/workflows/release.yml">
name: Release

on:
  push:
    tags:
      - 'v*.*.*'  # Trigger on version tags like v1.0.0

permissions:
  contents: write

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0  # Fetch all history for changelog

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test run

      - name: Extract version from tag
        id: get_version
        run: |
          VERSION=${GITHUB_REF#refs/tags/}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Generate changelog
        id: changelog
        run: |
          # Get commits since last tag
          PREVIOUS_TAG=$(git describe --abbrev=0 --tags $(git rev-list --tags --skip=1 --max-count=1) 2>/dev/null || echo "")

          if [ -z "$PREVIOUS_TAG" ]; then
            # First release, get all commits
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" --no-merges)
          else
            # Get commits between tags
            CHANGELOG=$(git log ${PREVIOUS_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          fi

          # Save to file
          echo "$CHANGELOG" > CHANGELOG.txt

          # Also save to output (escaping newlines)
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Release Notes
        run: |
          cat > RELEASE_NOTES.md << 'EOF'
          # Jot - Telegram Interface for Jules ${{ steps.get_version.outputs.version }}

          ## What's New

          ${{ steps.changelog.outputs.changelog }}

          ## Installation

          1. Clone the repository or download the source code
          2. Follow the [Installation Guide](https://github.com/${{ github.repository }}#installation)
          3. Configure your Cloudflare Workers environment
          4. Deploy with `wrangler deploy`

          ## Documentation

          Full documentation available in [README.md](https://github.com/${{ github.repository }}/blob/main/README.md)

          ## License

          This project is licensed under AGPL-3.0-or-later
          EOF

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          name: Release ${{ steps.get_version.outputs.version }}
          body_path: RELEASE_NOTES.md
          draft: false
          prerelease: ${{ contains(steps.get_version.outputs.version, 'alpha') || contains(steps.get_version.outputs.version, 'beta') || contains(steps.get_version.outputs.version, 'rc') }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create release summary
        run: |
          echo "## üéâ Release ${{ steps.get_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Changes" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          cat CHANGELOG.txt >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Links" >> $GITHUB_STEP_SUMMARY
          echo "- [Release Page](https://github.com/${{ github.repository }}/releases/tag/${{ steps.get_version.outputs.version }})" >> $GITHUB_STEP_SUMMARY
          echo "- [Full Changelog](https://github.com/${{ github.repository }}/compare/$PREVIOUS_TAG...${{ steps.get_version.outputs.version }})" >> $GITHUB_STEP_SUMMARY
</file>

<file path=".github/workflows/codeql.yml">
name: CodeQL Security Analysis

on:
  push:
    branches: [ "main", "develop" ]
  pull_request:
    branches: [ "main", "develop" ]
  schedule:
    # Run CodeQL every Monday at 00:00 UTC
    - cron: '0 0 * * 1'

permissions:
  actions: read
  contents: read
  security-events: write

jobs:
  analyze:
    name: Analyze Code
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        language: [ 'javascript-typescript' ]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v4
        with:
          languages: ${{ matrix.language }}
          queries: security-extended,security-and-quality

      - name: Autobuild
        uses: github/codeql-action/autobuild@v4

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v4
        with:
          category: "/language:${{matrix.language}}"
</file>

<file path="src/kv/storage.ts">
import type { Env, SessionData, GroupConfig } from '../types/env';

/**
 * KV Storage Helper Functions
 * Provides multi-tenant isolation by prefixing all keys with group_id
 */

// Key patterns for multi-tenant isolation
const keys = {
  julesToken: (groupId: string) => `group:${groupId}:jules_token`,
  source: (groupId: string) => `group:${groupId}:source`,
  defaultBranch: (groupId: string) => `group:${groupId}:default_branch`,
  automationMode: (groupId: string) => `group:${groupId}:automation_mode`,
  requireApproval: (groupId: string) => `group:${groupId}:require_approval`,
  sessionsIndex: (groupId: string) => `group:${groupId}:sessions_index`,
  session: (groupId: string, topicId: number) => `group:${groupId}:topic:${topicId}:session`,
  lastActivityId: (groupId: string, topicId: number) => `group:${groupId}:topic:${topicId}:last_activity_id`,
  pendingPlan: (groupId: string, topicId: number) => `group:${groupId}:topic:${topicId}:pending_plan`,
  readyForReview: (groupId: string, topicId: number) => `group:${groupId}:topic:${topicId}:ready_for_review`,
};

/**
 * Get Jules API token for a group
 */
export async function getJulesToken(env: Env, groupId: string): Promise<string | null> {
  return await env.KV.get(keys.julesToken(groupId));
}

/**
 * Set Jules API token for a group
 */
export async function setJulesToken(env: Env, groupId: string, token: string): Promise<void> {
  await env.KV.put(keys.julesToken(groupId), token);
}

/**
 * Get configured source for a group
 */
export async function getSource(env: Env, groupId: string): Promise<string | null> {
  return await env.KV.get(keys.source(groupId));
}

/**
 * Set source for a group
 */
export async function setSource(env: Env, groupId: string, source: string): Promise<void> {
  await env.KV.put(keys.source(groupId), source);
}

/**
 * Get default branch for a group
 */
export async function getDefaultBranch(env: Env, groupId: string): Promise<string | null> {
  return await env.KV.get(keys.defaultBranch(groupId));
}

/**
 * Set default branch for a group
 */
export async function setDefaultBranch(env: Env, groupId: string, branch: string): Promise<void> {
  await env.KV.put(keys.defaultBranch(groupId), branch);
}

/**
 * Get automation mode for a group
 */
export async function getAutomationMode(env: Env, groupId: string): Promise<'INTERACTIVE' | 'PLAN' | 'AUTO' | null> {
  const mode = await env.KV.get(keys.automationMode(groupId));
  // Validate the stored value matches expected type
  if (mode === 'INTERACTIVE' || mode === 'PLAN' || mode === 'AUTO' || mode === null) {
    return mode;
  }
  // Return null for invalid values (backward compatibility)
  return null;
}

/**
 * Set automation mode for a group
 */
export async function setAutomationMode(env: Env, groupId: string, mode: 'INTERACTIVE' | 'PLAN' | 'AUTO'): Promise<void> {
  await env.KV.put(keys.automationMode(groupId), mode);
}

/**
 * Get require approval setting for a group
 */
export async function getRequireApproval(env: Env, groupId: string): Promise<boolean> {
  const value = await env.KV.get(keys.requireApproval(groupId));
  return value === 'true';
}

/**
 * Set require approval setting for a group
 */
export async function setRequireApproval(env: Env, groupId: string, require: boolean): Promise<void> {
  await env.KV.put(keys.requireApproval(groupId), require ? 'true' : 'false');
}

/**
 * Get session data for a topic
 */
export async function getSession(env: Env, groupId: string, topicId: number): Promise<SessionData | null> {
  const data = await env.KV.get(keys.session(groupId, topicId));
  return data ? JSON.parse(data) : null;
}

/**
 * Set session data for a topic
 */
export async function setSession(env: Env, groupId: string, topicId: number, session: SessionData): Promise<void> {
  session.updated_at = new Date().toISOString();
  await env.KV.put(keys.session(groupId, topicId), JSON.stringify(session));
}

/**
 * Delete session data for a topic
 */
export async function deleteSession(env: Env, groupId: string, topicId: number): Promise<void> {
  await env.KV.delete(keys.session(groupId, topicId));
  await env.KV.delete(keys.lastActivityId(groupId, topicId));
  await env.KV.delete(keys.pendingPlan(groupId, topicId));
  await env.KV.delete(keys.readyForReview(groupId, topicId));
}

/**
 * Get sessions index for a group
 * Returns array of session_ids
 */
export async function getSessionsIndex(env: Env, groupId: string): Promise<string[]> {
  const data = await env.KV.get(keys.sessionsIndex(groupId));
  return data ? JSON.parse(data) : [];
}

/**
 * Add session to sessions index
 */
export async function addToSessionsIndex(env: Env, groupId: string, sessionId: string): Promise<void> {
  const index = await getSessionsIndex(env, groupId);
  if (!index.includes(sessionId)) {
    index.push(sessionId);
    await env.KV.put(keys.sessionsIndex(groupId), JSON.stringify(index));
  }
}

/**
 * Remove session from sessions index
 */
export async function removeFromSessionsIndex(env: Env, groupId: string, sessionId: string): Promise<void> {
  const index = await getSessionsIndex(env, groupId);
  const filtered = index.filter(id => id !== sessionId);
  await env.KV.put(keys.sessionsIndex(groupId), JSON.stringify(filtered));
}

/**
 * Get all active sessions for a group
 * Returns array of SessionData
 */
export async function getActiveSessions(env: Env, groupId: string): Promise<SessionData[]> {
  const index = await getSessionsIndex(env, groupId);
  const sessions: SessionData[] = [];

  // For each session_id in index, we need to find the corresponding topic_id
  // This is a bit tricky - we'll need to list all keys with the pattern
  // For now, we'll just return the sessions we can find
  // A better approach would be to store the topic_id in the sessions index

  // Note: KV doesn't have a native list operation in Workers
  // We need to maintain a mapping of session_id to topic_id
  // This will be handled by storing topic_id in the session data itself

  return sessions;
}

/**
 * Get last activity ID for a session
 */
export async function getLastActivityId(env: Env, groupId: string, topicId: number): Promise<string | null> {
  return await env.KV.get(keys.lastActivityId(groupId, topicId));
}

/**
 * Set last activity ID for a session
 */
export async function setLastActivityId(env: Env, groupId: string, topicId: number, activityId: string): Promise<void> {
  await env.KV.put(keys.lastActivityId(groupId, topicId), activityId);
}

/**
 * Check if session has pending plan
 */
export async function hasPendingPlan(env: Env, groupId: string, topicId: number): Promise<boolean> {
  const value = await env.KV.get(keys.pendingPlan(groupId, topicId));
  return value === 'true';
}

/**
 * Set pending plan flag
 */
export async function setPendingPlan(env: Env, groupId: string, topicId: number, pending: boolean): Promise<void> {
  await env.KV.put(keys.pendingPlan(groupId, topicId), pending ? 'true' : 'false');
}

/**
 * Check if session is ready for review
 */
export async function isReadyForReview(env: Env, groupId: string, topicId: number): Promise<boolean> {
  const value = await env.KV.get(keys.readyForReview(groupId, topicId));
  return value === 'true';
}

/**
 * Set ready for review flag
 */
export async function setReadyForReview(env: Env, groupId: string, topicId: number, ready: boolean): Promise<void> {
  await env.KV.put(keys.readyForReview(groupId, topicId), ready ? 'true' : 'false');
}

/**
 * Get group configuration
 */
export async function getGroupConfig(env: Env, groupId: string): Promise<GroupConfig | null> {
  const token = await getJulesToken(env, groupId);
  if (!token) return null;

  const source = await getSource(env, groupId);
  const defaultBranch = await getDefaultBranch(env, groupId);
  const automationMode = await getAutomationMode(env, groupId);
  const requireApproval = await getRequireApproval(env, groupId);
  const sessionsIndex = await getSessionsIndex(env, groupId);

  return {
    jules_token: token,
    source: source || undefined,
    default_branch: defaultBranch || undefined,
    automation_mode: automationMode || undefined,
    require_approval: requireApproval,
    sessions_index: sessionsIndex,
  };
}

/**
 * Log storage operation (for debugging and security)
 * Logs any attempt to access KV with group context
 */
export function logStorageAccess(groupId: string, operation: string, key: string): void {
  console.log(`[KV Access] Group: ${groupId}, Operation: ${operation}, Key: ${key}`);
}

/**
 * Cache for sources list to avoid API rate limits
 */
export async function getSourcesCache(env: Env, token: string): Promise<any[] | null> {
  const key = `cache:sources:${hashToken(token)}`;
  const cached = await env.KV.get(key);
  if (!cached) return null;
  return JSON.parse(cached);
}

export async function setSourcesCache(env: Env, token: string, sources: any[]): Promise<void> {
  const key = `cache:sources:${hashToken(token)}`;
  // Cache for 5 minutes (to see new repos quickly)
  await env.KV.put(key, JSON.stringify(sources), { expirationTtl: 300 });
}

export async function clearSourcesCache(env: Env, token: string): Promise<void> {
  const key = `cache:sources:${hashToken(token)}`;
  await env.KV.delete(key);
}

// Simple hash function for token (for cache key)
function hashToken(token: string): string {
  let hash = 0;
  for (let i = 0; i < token.length; i++) {
    const char = token.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32-bit integer
  }
  return Math.abs(hash).toString(36);
}
</file>

<file path="test/formatters.test.ts">
/**
 * Tests for formatter utilities
 */

import { describe, it, expect } from 'vitest';
import {
  escapeHtml,
  createExpandableBlockquote,
  formatBashOutput,
  truncate,
} from '../src/utils/formatters';

describe('formatters', () => {
  describe('escapeHtml', () => {
    it('should escape HTML special characters', () => {
      expect(escapeHtml('<div>Hello</div>')).toBe('&lt;div&gt;Hello&lt;/div&gt;');
      expect(escapeHtml('A & B')).toBe('A &amp; B');
      expect(escapeHtml('"quoted"')).toBe('&quot;quoted&quot;');
    });

    it('should handle empty string', () => {
      expect(escapeHtml('')).toBe('');
    });

    it('should handle null and undefined gracefully (critical fix)', () => {
      // This was causing "Cannot read properties of undefined (reading 'replace')"
      expect(escapeHtml(null)).toBe('');
      expect(escapeHtml(undefined)).toBe('');
      // Jules API sometimes returns undefined values
    });
  });

  describe('createExpandableBlockquote', () => {
    it('should create expandable blockquote', () => {
      const result = createExpandableBlockquote('Title', 'Content');
      expect(result).toContain('<b>Title</b>');
      expect(result).toContain('<blockquote expandable>Content</blockquote>');
    });

    it('should escape HTML in title and content', () => {
      const result = createExpandableBlockquote('<title>', '<content>');
      expect(result).toContain('&lt;title&gt;');
      expect(result).toContain('&lt;content&gt;');
    });
  });

  describe('formatBashOutput', () => {
    it('should format short output inline', () => {
      const result = formatBashOutput('ls -la', 'file1.txt\nfile2.txt', 0);
      expect(result).toContain('üîß');
      expect(result).toContain('<code>ls -la</code>');
      expect(result).toContain('<pre>file1.txt');
    });

    it('should use expandable blockquote for long output', () => {
      const longOutput = 'line\n'.repeat(50);
      const result = formatBashOutput('npm install', longOutput, 0);
      expect(result).toContain('<blockquote expandable>');
    });

    it('should show warning icon for non-zero exit code', () => {
      const result = formatBashOutput('npm test', 'Tests failed', 1);
      expect(result).toContain('‚ö†Ô∏è');
      expect(result).toContain('(exit code: 1)');
    });
  });

  describe('truncate', () => {
    it('should truncate long text', () => {
      const result = truncate('Hello World', 8);
      expect(result).toBe('Hello...');
    });

    it('should not truncate short text', () => {
      const result = truncate('Hello', 10);
      expect(result).toBe('Hello');
    });
  });
});
</file>

<file path="wrangler.toml">
name = "jules-over-telegram"
main = "src/index.ts"
compatibility_date = "2024-11-01"
compatibility_flags = ["nodejs_compat"]

# Workers Paid plan required for cron triggers
# Free plan: 100,000 requests/day
# Paid plan: 10 million requests/month + $0.50 per additional million

# KV Namespace for multi-tenant storage
# Preview environment will use a separate KV namespace
[[kv_namespaces]]
binding = "KV"
id = "106406036996474b9497d9fdeaa96780"
preview_id = "e80c6e500c4549ca966201d288e9eaba"

# Cron Triggers for automatic polling
# Note: Cron triggers require Workers Paid plan
[triggers]
crons = [
  "*/1 * * * *",   # Poll activities every 1 minute
  "*/15 * * * *"   # Sync sessions every 15 minutes
]

# Environment variables (use wrangler secret for sensitive data)
# Set BOT_TOKEN with: wrangler secret put BOT_TOKEN
[vars]
ENVIRONMENT = "production"
</file>

<file path="src/utils/formatters.ts">
/**
 * Formatting utilities for Telegram messages
 * Handles HTML formatting, expandable blockquotes, and message truncation
 */

/**
 * Escape HTML special characters for Telegram HTML parse mode
 * Handles null/undefined gracefully (Jules API may return undefined values)
 */
export function escapeHtml(text: string | undefined | null): string {
  if (text === null || text === undefined) {
    return '';
  }
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

/**
 * Create an expandable blockquote (Telegram feature)
 * Used for long content like bash output, file lists, etc.
 */
export function createExpandableBlockquote(title: string, content: string): string {
  const escapedTitle = escapeHtml(title);
  const escapedContent = escapeHtml(content);
  return `<b>${escapedTitle}</b>\n<blockquote expandable>${escapedContent}</blockquote>`;
}

/**
 * Format bash output for display
 * Uses expandable blockquote if output is too long
 */
export function formatBashOutput(command: string, output: string, exitCode: number): string {
  const emoji = exitCode !== 0 ? '‚ö†Ô∏è' : 'üîß';
  const statusText = exitCode !== 0 ? `(exit code: ${exitCode})` : '';

  // If output is short (< 200 chars), display inline
  if (output.length < 200) {
    return `${emoji} <b>Command:</b> <code>${escapeHtml(command)}</code> ${statusText}\n\n<pre>${escapeHtml(output)}</pre>`;
  }

  // Otherwise, use expandable blockquote
  const title = `${emoji} Command: ${command} ${statusText}`;
  return createExpandableBlockquote(title, output);
}

/**
 * Format changeSet (file changes) for display
 * Uses expandable blockquote if too many files
 */
export function formatChangeSet(files: Array<{ path?: string; changeType?: string }>, gitPatch?: string): string {
  const fileCount = files.length;

  // If few files (< 5), display inline
  if (fileCount <= 5) {
    const filesList = files
      .map(f => {
        const icon = getChangeTypeIcon(f.changeType);
        return `${icon} <code>${escapeHtml(f.path || 'unknown')}</code>`;
      })
      .join('\n');

    return `üìÅ <b>Files modified (${fileCount}):</b>\n${filesList}`;
  }

  // Otherwise, use expandable blockquote
  const filesList = files
    .map(f => {
      const icon = getChangeTypeIcon(f.changeType);
      return `${icon} ${f.path || 'unknown'}`;
    })
    .join('\n');

  const title = `üìÅ Files modified (${fileCount} files)`;
  return createExpandableBlockquote(title, filesList);
}

/**
 * Get icon for change type
 */
function getChangeTypeIcon(changeType?: string): string {
  switch (changeType) {
    case 'ADDED':
      return '‚ûï';
    case 'MODIFIED':
      return '‚úèÔ∏è';
    case 'DELETED':
      return '‚ùå';
    case 'RENAMED':
      return 'üîÑ';
    default:
      return 'üìÑ';
  }
}

/**
 * Format plan steps for display
 * Always uses expandable blockquote for better UX
 */
export function formatPlanSteps(steps: string[]): string {
  const stepsList = steps.map((step, index) => `${index + 1}. ${step}`).join('\n');
  const title = `üéØ PLAN CREATED - ${steps.length} steps`;
  return createExpandableBlockquote(title, stepsList);
}

/**
 * Truncate text to max length with ellipsis
 */
export function truncate(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength - 3) + '...';
}

/**
 * Format session outputs (PR links, branches, etc.)
 * Extracts and formats GitHub links from outputs
 */
export function formatOutputs(outputs?: string): string {
  if (!outputs) return 'No outputs available.';

  // Try to parse as JSON first
  try {
    const parsed = JSON.parse(outputs);
    let result = '';

    if (parsed.pullRequest) {
      result += `üîÄ <b>Pull Request:</b> ${parsed.pullRequest.url}\n`;
    }

    if (parsed.branch) {
      result += `üåø <b>Branch:</b> ${parsed.branch.name}\n`;
    }

    if (parsed.commits && parsed.commits.length > 0) {
      result += `üìù <b>Commits:</b> ${parsed.commits.length}\n`;
    }

    return result || escapeHtml(outputs);
  } catch {
    // If not JSON, return as-is (escaped)
    return escapeHtml(outputs);
  }
}

/**
 * Format activity title and description
 * Handles special cases like "Ready for review"
 */
export function formatActivityMessage(title?: string, description?: string): string {
  // Check for "Ready for review" pattern
  if (title?.toLowerCase().includes('ready for review') || description?.toLowerCase().includes('ready for review')) {
    return 'üéâ <b>Ready for review!</b>\n\nJules finalized the changes.';
  }

  let message = '';

  if (title) {
    message += `<b>${escapeHtml(title)}</b>\n`;
  }

  if (description) {
    message += `\n${escapeHtml(description)}`;
  }

  return message || 'Activity received.';
}

/**
 * Format session status for /status command
 */
export function formatSessionStatus(
  hasToken: boolean,
  source?: string,
  defaultBranch?: string,
  automationMode?: string,
  requireApproval?: boolean,
  sessionsCount?: number
): string {
  let status = '<b>‚öôÔ∏è Group Configuration</b>\n\n';

  status += `<b>Jules Token:</b> ${hasToken ? '‚úÖ Configured' : '‚ùå Not configured'}\n`;
  status += `<b>Source:</b> ${source ? escapeHtml(source) : '‚ùå Not configured'}\n`;
  status += `<b>Default Branch:</b> ${defaultBranch || 'main'}\n`;
  status += `<b>Automation Mode:</b> ${automationMode || 'INTERACTIVE'}\n`;
  status += `<b>Require Plan Approval:</b> ${requireApproval ? 'Yes' : 'No'}\n`;
  status += `<b>Active Sessions:</b> ${sessionsCount || 0}\n`;

  return status;
}

/**
 * Format list of sessions for /list_sessions command
 */
export function formatSessionsList(sessions: Array<{ session_id: string; topic_id: number; source: string; status?: string }>): string {
  if (sessions.length === 0) {
    return 'No active sessions found.';
  }

  // If many sessions (> 10), use expandable blockquote
  if (sessions.length > 10) {
    const sessionsList = sessions
      .map(s => `‚Ä¢ Session ${s.session_id} (Topic ${s.topic_id}) - ${s.status || 'active'}`)
      .join('\n');

    const title = `üìã Active Sessions (${sessions.length} total)`;
    return createExpandableBlockquote(title, sessionsList);
  }

  // Otherwise, display inline
  let result = `<b>üìã Active Sessions (${sessions.length}):</b>\n\n`;

  for (const session of sessions) {
    result += `‚Ä¢ <code>${escapeHtml(session.session_id)}</code>\n`;
    result += `  Topic: ${session.topic_id}\n`;
    result += `  Source: ${escapeHtml(session.source)}\n`;
    result += `  Status: ${session.status || 'active'}\n\n`;
  }

  return result;
}

/**
 * Format list of sources for /list_sources command
 */
export function formatSourcesList(sources: Array<{ name: string; displayName: string; description?: string }>): string {
  if (sources.length === 0) {
    return 'No sources available.';
  }

  let result = `<b>üìö Available Sources (${sources.length}):</b>\n\n`;

  for (const source of sources) {
    result += `‚Ä¢ <b>${escapeHtml(source.displayName)}</b>\n`;
    result += `  Name: <code>${escapeHtml(source.name)}</code>\n`;
    if (source.description) {
      result += `  Description: ${escapeHtml(source.description)}\n`;
    }
    result += '\n';
  }

  return result;
}

/**
 * Create inline keyboard button markup
 */
export function createInlineButton(text: string, callbackData: string): any {
  return {
    text,
    callback_data: callbackData,
  };
}

/**
 * Create inline keyboard button with URL
 */
export function createUrlButton(text: string, url: string): any {
  return {
    text,
    url,
  };
}
</file>

<file path="README.md">
# Jot - Telegram Interface for Jules

[![License: AGPL v3](https://img.shields.io/badge/License-AGPL%20v3-blue.svg)](https://www.gnu.org/licenses/agpl-3.0)
[![TypeScript](https://img.shields.io/badge/TypeScript-5.7-blue)](https://www.typescriptlang.org/)
[![Cloudflare Workers](https://img.shields.io/badge/Cloudflare-Workers-orange)](https://workers.cloudflare.com/)
[![CI](https://github.com/insign/jot/actions/workflows/ci.yml/badge.svg)](https://github.com/insign/jot/actions/workflows/ci.yml)
[![Deploy](https://github.com/insign/jot/actions/workflows/deploy.yml/badge.svg)](https://github.com/insign/jot/actions/workflows/deploy.yml)
[![CodeQL](https://github.com/insign/jot/actions/workflows/codeql.yml/badge.svg)](https://github.com/insign/jot/actions/workflows/codeql.yml)

A powerful Telegram bot that provides a seamless interface to Jules (Google's AI coding assistant), built with Grammy and deployed on Cloudflare Workers.

## Overview

Jot bridges the gap between Telegram and Jules, allowing you to interact with Jules directly from your Telegram groups. Each Telegram topic (forum thread) maps 1:1 to a Jules session, providing organized, isolated workspaces for different coding tasks.

The bot automatically polls for updates from Jules and sends them to your Telegram group, so you never miss a beat. It supports text prompts, images (screenshots, designs, diagrams), and provides smart notifications with GitHub link extraction.

## Features

- üè¢ **Multi-tenant Architecture** - Each Telegram group has isolated configuration and sessions
- üéØ **1:1 Topic-Session Mapping** - Each Telegram topic = one Jules session for perfect organization
- üîÑ **Automatic Activity Polling** - Updates arrive automatically via cron triggers (no manual polling needed!)
- üì∏ **Image Support** - Send screenshots, designs, or diagrams directly to Jules
- üîî **Smart Notifications** - Important events (plan generated, ready for review, errors) with sound, routine updates are silent
- üîó **GitHub Integration** - Automatic extraction and formatting of PR links, branches, and commits
- üí¨ **Expandable Blockquotes** - Long outputs (bash, file lists) use Telegram's expandable format for better UX
- ‚ö° **Plan Approval System** - Review and approve plans before execution with inline buttons
- üé® **Rich Formatting** - HTML formatting with emojis, bold text, code blocks, and clickable links
- üåê **Web Settings Access** - Quick access to Jules web interface for advanced configuration

## Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     Webhook       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Telegram   ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫  ‚îÇ  Cloudflare      ‚îÇ
‚îÇ             ‚îÇ                   ‚îÇ  Worker          ‚îÇ
‚îÇ  User sends ‚îÇ                   ‚îÇ  (Grammy Bot)    ‚îÇ
‚îÇ  message or ‚îÇ                   ‚îÇ                  ‚îÇ
‚îÇ  image      ‚îÇ                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                            ‚îÇ
                                           ‚îÇ API Call
                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                 ‚îÇ                                   ‚îÇ
                 ‚îÇ  Jules API                        ‚îÇ
                 ‚îÇ  (sessions, activities, sources)  ‚îÇ
                 ‚îÇ                                   ‚îÇ
                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                 ‚îÇ
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ                                                 ‚îÇ
      ‚îÇ  Cron Trigger (every 1 min)                     ‚îÇ
      ‚îÇ  - Poll new activities for all sessions         ‚îÇ
      ‚îÇ  - Process and format activities                ‚îÇ
      ‚îÇ  - Send to appropriate Telegram topic           ‚îÇ
      ‚îÇ                                                 ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                 ‚îÇ
                                 ‚ñº
                          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                          ‚îÇ  Telegram   ‚îÇ
                          ‚îÇ  (auto      ‚îÇ
                          ‚îÇ  updates)   ‚îÇ
                          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Prerequisites

- Node.js 20+ and npm
- Cloudflare account (Free tier works, Paid tier required for cron triggers)
- Telegram Bot Token (from [@BotFather](https://t.me/BotFather))
- Jules API key (from [jules.google](https://jules.google))

## Installation

1. **Clone the repository**

```bash
git clone https://github.com/yourusername/jot.git
cd jot
```

2. **Install dependencies**

```bash
npm install
```

3. **Create KV namespaces**

```bash
# Create production KV namespace
wrangler kv namespace create "KV"

# Create preview KV namespace for development
wrangler kv namespace create "KV" --preview
```

Copy the namespace IDs from the output and update `wrangler.toml`:

```toml
[[kv_namespaces]]
binding = "KV"
id = "your_kv_namespace_id_here"
preview_id = "your_preview_kv_namespace_id_here"
```

5. **Configure secrets**

```bash
# Set your Telegram Bot Token
wrangler secret put BOT_TOKEN
```

When prompted, paste your bot token from @BotFather.

**‚ö†Ô∏è IMPORTANT**: The `BOT_TOKEN` must be configured as a secret in your Cloudflare Workers environment. This is separate from CI/CD secrets. You need to set it using `wrangler secret put BOT_TOKEN` even if it's already in your GitHub Actions secrets. The Workers runtime cannot access GitHub repository secrets directly.

## Bot Setup

### Creating Your Telegram Bot

1. Open Telegram and search for [@BotFather](https://t.me/BotFather)
2. Send `/newbot` and follow the instructions
3. Choose a name and username for your bot
4. Save the bot token (you'll need it for `wrangler secret put BOT_TOKEN`)
5. **Important**: Send `/setprivacy` to @BotFather, select your bot, and choose "Disable" to allow the bot to read all messages in groups

### Adding Bot to Group

1. Create or open a Telegram group
2. **Enable Topics (Forums)**: Group Settings ‚Üí Topics ‚Üí Enable
3. Add your bot to the group
4. Make the bot an admin with these permissions:
   - ‚úÖ Delete Messages
   - ‚úÖ Manage Topics (required for updating topic names)
   - ‚úÖ Post Messages
5. The bot is now ready to use!

### Getting Jules API Key

1. Visit [jules.google](https://jules.google)
2. Sign in with your Google account
3. Connect your GitHub repositories
4. Generate an API key from your account settings
5. Use `/set_jules_token <token>` in your Telegram group to configure it

## Usage

### Initial Configuration

1. **Set Jules Token** (Admin only)
```
/set_jules_token YOUR_API_KEY_HERE
```

2. **List Available Sources**
```
/list_sources
```

3. **Set Default Source**
```
/set_source sources/github/username/repository
```

4. **Optional Configuration**
```
/set_branch main              # Set default starting branch
/set_auto_pr on               # Enable automatic PR creation
/require_approval on          # Require plan approval before execution
```

### Working with Sessions

1. **Create a topic** in your Telegram group (any name)

2. **Send your request** in the topic:
   - Text: `Add a dark mode toggle to the settings page`
   - Image: Upload a screenshot with caption `Implement this design`

3. **Automatic updates**: The bot will automatically send you updates as Jules works on your request

4. **Approve plans** (if enabled): Click the "‚úÖ Approve Plan" button when a plan is generated

5. **Publish changes**: When ready for review, click "üì¶ Publish Branch" or "üîÄ Publish PR"

### Continuous Conversation

You can continue the conversation in any topic that has an active session:
- Send text messages to ask questions or provide feedback
- Send images for additional context
- The bot will forward everything to Jules and send you the responses

## Commands Reference

### Basic Commands

| Command | Description |
|---------|-------------|
| `/start` | Show welcome message with setup instructions |
| `/help` | Display complete command reference |

### Configuration (Admin Only)

| Command | Description |
|---------|-------------|
| `/set_jules_token <token>` | Configure Jules API token for the group |
| `/set_source <source>` | Set default repository source |
| `/set_branch <branch>` | Set default starting branch (default: main) |
| `/set_auto_pr <on\|off>` | Enable/disable automatic PR creation |
| `/require_approval <on\|off>` | Require plan approval before execution |

### Information

| Command | Description |
|---------|-------------|
| `/status` | Show group configuration and statistics |
| `/get_source` | Display currently configured source |
| `/list_sources` | List all available repositories from Jules |
| `/list_sessions` | List all active sessions in the group |
| `/session_info` | Show details of current session (use in topic) |
| `/list_activities` | Show activities for current session (use in topic) |
| `/show_plan` | Display plan for current session (use in topic) |
| `/show_outputs` | Show outputs (PR, branch, commits) for current session |
| `/open_jules_settings` | Open Jules web interface for advanced settings |

### Actions

| Command | Description |
|---------|-------------|
| `/new_session <prompt>` | Create new session in current topic with prompt |
| `/approve_plan` | Approve pending plan (use in topic) |
| `/delete_session` | Delete current session (Admin only, use in topic) |
| `/sync` | Manually sync sessions with Jules API (Admin only) |

## Image Support

Jot supports sending images to Jules for analysis and implementation:

### Supported Formats
- JPG/JPEG
- PNG
- WebP
- GIF

### Size Limit
- Maximum: 20MB per image

### Usage Examples

1. **Design Implementation**
   - Upload a design mockup
   - Caption: "Implement this login page design"

2. **Bug Reports**
   - Screenshot of an error
   - Caption: "Fix this error in the checkout flow"

3. **Diagram Analysis**
   - Architecture diagram
   - Caption: "Implement this database schema"

## Advanced Configuration

Some Jules features can only be configured via the web interface:

### Setup Script
- Define commands to run before each session
- Example: Install dependencies, set up environment

### Environment Variables
- Configure per-repository environment variables
- Securely store API keys, database URLs, etc.

### Memories (Knowledge Base)
- Add project-specific knowledge for Jules to use
- Example: Architecture decisions, coding standards, deployment procedures

**Access via**: `/open_jules_settings` command or visit `https://jules.google/github/owner/repo`

## Development

### Local Development

```bash
# Start local development server
npm run dev
```

The development server will run at `http://localhost:8787`.

**Note**: Cron triggers don't run in development mode. You'll need to test cron functionality in a deployed environment.

### Testing

```bash
# Run tests
npm test

# Run tests in watch mode
npm run test:watch

# Run tests with coverage
npm run test:coverage
```

Tests are written using Vitest with `@cloudflare/vitest-pool-workers` for Worker-specific testing.

### Type Generation

```bash
# Generate TypeScript types from wrangler.toml
npm run cf-typegen
```

## Deployment

### Deploy to Cloudflare Workers

```bash
# Deploy to production
npm run deploy
```

### Set Up Telegram Webhook

After deploying, configure the Telegram webhook:

```bash
curl "https://api.telegram.org/bot<YOUR_BOT_TOKEN>/setWebhook?url=https://jules-over-telegram.cloudatlas.workers.dev/webhook"
```

Replace:
- `<YOUR_BOT_TOKEN>` with your bot token from @BotFather
- Or use custom domain: `jot.helio.me/webhook` (configure in Cloudflare DNS)

### Verify Webhook

```bash
curl "https://api.telegram.org/bot<YOUR_BOT_TOKEN>/getWebhookInfo"
```

You should see `"url": "https://jules-over-telegram.cloudatlas.workers.dev/webhook"` or `"url": "https://jot.helio.me/webhook"` in the response.

### Cron Triggers

Cron triggers are configured in `wrangler.toml`:

```toml
[triggers]
crons = [
  "*/1 * * * *",   # Poll activities every 1 minute
  "*/15 * * * *"   # Sync sessions every 15 minutes
]
```

**Note**: Cron triggers require a Cloudflare Workers Paid plan ($5/month).

## API Limitations

Some features are only available via the Jules web interface, not through the API:

| Feature | API Support | Web Interface |
|---------|-------------|---------------|
| Setup Script | ‚ùå No | ‚úÖ Yes |
| Environment Variables (per repo) | ‚ùå No | ‚úÖ Yes |
| Manual Memories | ‚ùå No | ‚úÖ Yes |
| Session Creation | ‚úÖ Yes | ‚úÖ Yes |
| Send Messages | ‚úÖ Yes | ‚úÖ Yes |
| List Activities | ‚úÖ Yes | ‚úÖ Yes |
| Approve Plans | ‚úÖ Yes | ‚úÖ Yes |

Use `/open_jules_settings` to quickly access the web interface for these features.

## Troubleshooting

### Bot Not Responding

**Check bot permissions:**
- Bot must be admin in the group
- Bot must have "Manage Topics" permission
- Bot must have privacy mode disabled (@BotFather ‚Üí /setprivacy ‚Üí Disable)

**Check Worker secrets:**
- Verify `BOT_TOKEN` is configured: `wrangler secret list`
- If missing, add it: `wrangler secret put BOT_TOKEN`
- Redeploy after adding secrets: `wrangler deploy`

### "500 Internal Server Error" on Webhook

**Common causes:**
1. **Missing BOT_TOKEN secret** - The Worker doesn't have access to the BOT_TOKEN
2. **Invalid Jules API token** - Use `/set_jules_token` to configure and validate

**Solution:**
```bash
# Check secrets
wrangler secret list

# Add BOT_TOKEN if missing
wrangler secret put BOT_TOKEN

# Redeploy
wrangler deploy

# Check webhook status
curl "https://api.telegram.org/bot<YOUR_BOT_TOKEN>/getWebhookInfo"
```

### "Token not configured" Error

**Solution:**
```
/set_jules_token YOUR_API_KEY
```

Only group admins can configure the token.

### Session Deleted in jules.google

**Symptom**: Bot shows session but Jules API returns 404

**Solution**: Use `/sync` to synchronize with Jules API, or `/delete_session` to remove locally

### Rate Limiting

**Symptom**: Frequent API errors, delayed responses

**Solution**:
- Reduce number of active sessions
- Wait a few minutes before retrying
- Contact Jules support if persistent

### Images Not Working

**Check:**
- Image size < 20MB
- Format is JPG, PNG, WebP, or GIF
- Bot has permission to access messages

### Source Not Configured for /open_jules_settings

**Solution**:
```
/list_sources
/set_source sources/github/username/repo
/open_jules_settings
```

## Contributing

Contributions are welcome! Here's how to contribute:

### Code Style

- **Language**: TypeScript
- **Code**: English (variables, functions, comments)
- **Comments**: Explain important decisions and "why", not "what"
- **Formatting**: Use Prettier (if configured) or match existing style

### Submitting Changes

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Make your changes with clear commit messages
4. Add tests for new functionality
5. Ensure all tests pass (`npm test`)
6. Push to your fork
7. Open a Pull Request

### Testing Requirements

- All new features must have tests
- Tests must pass before PR is merged
- Aim for >80% code coverage

## CI/CD

This project includes a complete CI/CD pipeline with GitHub Actions:

- ‚úÖ **Automated Testing** - Runs on every push and PR
- üöÄ **Automatic Deployment** - Push to `main` deploys to production, `develop` to staging
- üîí **Security Scanning** - CodeQL analysis on every push
- üì¶ **Release Automation** - Tag a version to create a GitHub release

**For Contributors**: See [`.github/README.md`](.github/README.md) for detailed CI/CD documentation, required secrets, and workflow details.

## License

This project is licensed under the **GNU Affero General Public License v3.0 or later** (AGPL-3.0-or-later).

This means:
- ‚úÖ You can use, modify, and distribute this software
- ‚úÖ You must provide source code when distributing
- ‚úÖ You must license derivatives under AGPL-3.0
- ‚ö†Ô∏è **Network use = distribution**: If you run a modified version on a server, you must make your source code available to users

See [LICENSE](LICENSE) file for full details.

## Credits

Built with:
- [Grammy](https://grammy.dev) - Telegram Bot Framework
- [Jules API](https://developers.google.com/jules) - Google's AI Coding Assistant
- [Cloudflare Workers](https://workers.cloudflare.com/) - Serverless Compute Platform
- [TypeScript](https://www.typescriptlang.org/) - Programming Language
- [Vitest](https://vitest.dev) - Testing Framework

## Support

- üìö [Jules Documentation](https://developers.google.com/jules)
- üí¨ [Grammy Documentation](https://grammy.dev)
- üîß [Cloudflare Workers Docs](https://developers.cloudflare.com/workers/)

## Roadmap

- [ ] Durable Objects for real-time typing indicators
- [ ] Better session indexing (reverse mapping for faster lookups)
- [ ] Group tracking in KV for cron efficiency
- [ ] Retry logic for failed activity notifications
- [ ] Rich plan visualization with step-by-step breakdown
- [ ] Session templates (predefined prompts)
- [ ] Usage analytics per group
- [ ] Multi-language support for bot messages

---

Made with ‚ù§Ô∏è for developers who want to bring Jules to Telegram
</file>

<file path="package.json">
{
  "name": "jules-over-telegram",
  "version": "0.1.0",
  "description": "Telegram interface for Jules using Grammy and Cloudflare Workers",
  "main": "src/index.ts",
  "type": "module",
  "scripts": {
    "dev": "wrangler dev",
    "deploy": "wrangler deploy",
    "tail": "wrangler tail",
    "test": "vitest",
    "test:watch": "vitest --watch",
    "test:coverage": "vitest --coverage",
    "cf-typegen": "wrangler types",
    "wrangler": "wrangler"
  },
  "keywords": [
    "telegram",
    "bot",
    "jules",
    "cloudflare",
    "workers",
    "grammy"
  ],
  "author": "",
  "license": "AGPL-3.0-or-later",
  "devDependencies": {
    "@cloudflare/vitest-pool-workers": "^0.10.5",
    "@cloudflare/workers-types": "^4.20251109.0",
    "typescript": "^5.9.3",
    "vitest": "^3.0.0",
    "wrangler": "^4.45.4"
  },
  "dependencies": {
    "grammy": "^1.38.3"
  }
}
</file>

<file path="src/bot/commands/infoCommands.ts">
/**
 * Information command handlers
 * Commands for viewing configuration and session information
 */

import type { BotContext } from '../bot';
import { getGroupId, getTopicId } from '../bot';
import {
  getJulesToken,
  getSource,
  getDefaultBranch,
  getAutomationMode,
  getRequireApproval,
  getSessionsIndex,
  getSession,
  getGroupConfig,
} from '../../kv/storage';
import { createJulesClient } from '../../jules/api';
import { formatSessionStatus, formatSourcesList, formatSessionsList, createExpandableBlockquote, formatOutputs, escapeHtml } from '../../utils/formatters';
import { parseSourceToGitHubUrl } from '../../utils/github';
import { InlineKeyboard } from 'grammy';

/**
 * /status command
 * Show group configuration and statistics
 */
export async function handleStatus(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);

  if (!groupId) {
    await ctx.reply('This command only works in group chats.');
    return;
  }

  const config = await getGroupConfig(ctx.env, groupId);

  if (!config) {
    await ctx.reply(
      '‚ö†Ô∏è Jules token not configured.\n\n' +
      'Use /set_jules_token &lt;token&gt; to get started.',
      { parse_mode: 'HTML' }
    );
    return;
  }

  const status = formatSessionStatus(
    !!config.jules_token,
    config.source,
    config.default_branch,
    config.automation_mode,
    config.require_approval,
    config.sessions_index?.length
  );

  await ctx.reply(status, { parse_mode: 'HTML' });
}

/**
 * /get_source command
 * Show configured source
 */
export async function handleGetSource(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);

  if (!groupId) {
    await ctx.reply('This command only works in group chats.');
    return;
  }

  const source = await getSource(ctx.env, groupId);

  if (!source) {
    await ctx.reply(
      '‚ö†Ô∏è No source configured.\n\n' +
      'Use /list_sources to see available sources, then /set_source to configure one.',
      { parse_mode: 'HTML' }
    );
    return;
  }

  await ctx.reply(
    `<b>üìö Configured Source:</b>\n<code>${escapeHtml(source)}</code>\n\n` +
    'Use /open_jules_settings to configure advanced settings for this repository.',
    { parse_mode: 'HTML' }
  );
}

/**
 * /list_sources command
 * List all available sources from Jules API with pagination
 */
export async function handleListSources(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);

  if (!groupId) {
    await ctx.reply('This command only works in group chats.');
    return;
  }

  console.log('[DEBUG] Group ID:', groupId);
  const token = await getJulesToken(ctx.env, groupId);
  console.log('[DEBUG] Token from KV:', token ? token.substring(0, 20) + '...' : 'null');

  if (!token) {
    await ctx.reply(
      '‚ö†Ô∏è Jules token not configured.\n\n' +
      'Use /set_jules_token &lt;token&gt; to get started.',
      { parse_mode: 'HTML' }
    );
    return;
  }

  await ctx.reply('üîÑ Loading sources...');

  try {
    // Try to get from cache first
    const { getSourcesCache, setSourcesCache } = await import('../../kv/storage');
    let sources = await getSourcesCache(ctx.env, token);
    let hasMore = false;

    // If not in cache, fetch from API with extended timeout
    if (!sources) {
      const julesClient = createJulesClient(token);
      console.log('[DEBUG] JulesClient created, calling listSources...');

      // Use 9s timeout to get first batch quickly
      const result = await julesClient.listSources(9000);

      if (result.sources.length === 0) {
        await ctx.reply('No sources found. Please connect a repository at https://jules.google');
        return;
      }

      sources = result.sources.map(s => ({
        name: s.name,
        displayName: s.displayName,
        description: s.description,
      }));
      hasMore = result.hasMore;

      // Cache the initial results for 1 hour
      await setSourcesCache(ctx.env, token, sources);

      console.log(`[DEBUG] Cached ${sources.length} sources (hasMore: ${hasMore})`);

      // If there are more sources, start background fetch to get them all
      if (hasMore) {
        console.log('[DEBUG] More sources available, will fetch in background...');
        // Don't await - let it run in background
        fetchAllSourcesInBackground(ctx.env, token).catch(error => {
          console.error('[DEBUG] Background fetch error:', error);
        });
      }
    }

    // Show first page (10 sources per page)
    const { showSourcesPage } = await import('../handlers/callbackHandlers');
    await showSourcesPage(ctx, sources, 0, hasMore);
  } catch (error) {
    console.error('Error fetching sources:', error);
    await ctx.reply(
      '‚ùå Failed to fetch sources from Jules.\n\n' +
      'Error: ' + (error instanceof Error ? error.message : 'Unknown error')
    );
  }
}

/**
 * Fetch all sources in background without timeout limit
 * Updates cache progressively as pages are fetched
 */
async function fetchAllSourcesInBackground(env: any, token: string): Promise<void> {
  console.log('[fetchAllSourcesInBackground] Starting full fetch...');
  const startTime = Date.now();

  try {
    const julesClient = createJulesClient(token);
    const allSources: any[] = [];
    let nextPageToken: string | undefined;
    let pageNum = 0;
    const pageSize = 100;

    do {
      pageNum++;
      const url = nextPageToken
        ? `/sources?pageSize=${pageSize}&pageToken=${encodeURIComponent(nextPageToken)}`
        : `/sources?pageSize=${pageSize}`;

      console.log(`[fetchAllSourcesInBackground] Fetching page ${pageNum}...`);

      const response = await fetch(`https://jules.googleapis.com/v1alpha${url}`, {
        headers: {
          'X-Goog-Api-Key': token,
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) {
        console.error(`[fetchAllSourcesInBackground] API error: ${response.status}`);
        break;
      }

      const data: any = await response.json();

      if (data.sources && data.sources.length > 0) {
        const mapped = data.sources.map((s: any) => ({
          name: s.name,
          displayName: s.displayName,
          description: s.description,
        }));
        allSources.push(...mapped);

        console.log(`[fetchAllSourcesInBackground] Page ${pageNum}: +${data.sources.length} sources (total: ${allSources.length})`);

        // Update cache after each page
        const { setSourcesCache } = await import('../../kv/storage');
        await setSourcesCache(env, token, allSources);
      }

      nextPageToken = data.nextPageToken;

      // Safety limit: max 10 pages (1000 sources)
      if (pageNum >= 10) {
        console.log('[fetchAllSourcesInBackground] Reached page limit (10)');
        break;
      }
    } while (nextPageToken);

    const duration = Date.now() - startTime;
    console.log(`[fetchAllSourcesInBackground] Complete: ${allSources.length} sources in ${duration}ms (${pageNum} pages)`);
  } catch (error) {
    console.error('[fetchAllSourcesInBackground] Error:', error);
  }
}

/**
 * /search_sources command
 * Search sources by owner/repo name
 */
export async function handleSearchSources(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);

  if (!groupId) {
    await ctx.reply('This command only works in group chats.');
    return;
  }

  // Get search query from command arguments
  const text = ctx.message?.text || '';
  const query = text.replace(/^\/search_sources(@\w+)?\s*/, '').trim();

  if (!query) {
    await ctx.reply(
      'üîç <b>Search Sources</b>\n\n' +
      'Usage: <code>/search_sources query</code>\n\n' +
      'Examples:\n' +
      '‚Ä¢ <code>/search_sources myproject</code>\n' +
      '‚Ä¢ <code>/search_sources owner/repo</code>\n' +
      '‚Ä¢ <code>/search_sources org-name</code>',
      { parse_mode: 'HTML' }
    );
    return;
  }

  const token = await getJulesToken(ctx.env, groupId);

  if (!token) {
    await ctx.reply(
      '‚ö†Ô∏è Jules token not configured.\n\n' +
      'Use /set_jules_token &lt;token&gt; to get started.',
      { parse_mode: 'HTML' }
    );
    return;
  }

  await ctx.reply(`üîç Searching for "<code>${escapeHtml(query)}</code>"...`, { parse_mode: 'HTML' });

  try {
    // Try to get from cache first
    const { getSourcesCache } = await import('../../kv/storage');
    let sources = await getSourcesCache(ctx.env, token);

    // If not in cache, fetch from API
    if (!sources) {
      const julesClient = createJulesClient(token);
      const result = await julesClient.listSources();

      if (result.sources.length === 0) {
        await ctx.reply('No sources found. Please connect a repository at https://jules.google');
        return;
      }

      sources = result.sources.map(s => ({
        name: s.name,
        displayName: s.displayName,
        description: s.description,
      }));

      // Cache for future searches
      const { setSourcesCache } = await import('../../kv/storage');
      await setSourcesCache(ctx.env, token, sources);
    }

    // Filter sources by query (case-insensitive search in name)
    const queryLower = query.toLowerCase();
    const filteredSources = sources.filter(s => {
      const nameLower = s.name.toLowerCase();
      const displayNameLower = (s.displayName || '').toLowerCase();

      return nameLower.includes(queryLower) || displayNameLower.includes(queryLower);
    });

    if (filteredSources.length === 0) {
      await ctx.reply(
        `‚ùå No sources found matching "<code>${escapeHtml(query)}</code>"\n\n` +
        'Try a different search term or use /list_sources to see all repositories.',
        { parse_mode: 'HTML' }
      );
      return;
    }

    // Show results (first page)
    const { showSourcesPage } = await import('../handlers/callbackHandlers');
    await showSourcesPage(ctx, filteredSources, 0, false);
  } catch (error) {
    console.error('Error searching sources:', error);
    await ctx.reply(
      '‚ùå Failed to search sources.\n\n' +
      'Error: ' + (error instanceof Error ? error.message : 'Unknown error')
    );
  }
}

/**
 * /list_sessions command
 * List all active sessions for the group
 */
export async function handleListSessions(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);

  if (!groupId) {
    await ctx.reply('This command only works in group chats.');
    return;
  }

  const token = await getJulesToken(ctx.env, groupId);

  if (!token) {
    await ctx.reply(
      '‚ö†Ô∏è Jules token not configured.\n\n' +
      'Use /set_jules_token &lt;token&gt; to get started.',
      { parse_mode: 'HTML' }
    );
    return;
  }

  await ctx.reply('üîÑ Fetching sessions from Jules...');

  try {
    const julesClient = createJulesClient(token);
    const sessions = await julesClient.listSessions();

    if (sessions.length === 0) {
      await ctx.reply('No active sessions found.');
      return;
    }

    const sessionsList = sessions.map(s => ({
      session_id: s.name,
      topic_id: 0, // We don't have topic_id from Jules API
      source: s.source,
      status: s.state,
    }));

    const formatted = formatSessionsList(sessionsList);

    await ctx.reply(formatted, { parse_mode: 'HTML' });
  } catch (error) {
    console.error('Error fetching sessions:', error);
    await ctx.reply(
      '‚ùå Failed to fetch sessions from Jules.\n\n' +
      'Error: ' + (error instanceof Error ? error.message : 'Unknown error')
    );
  }
}

/**
 * /session_info command
 * Show details of current session (use in topic)
 */
export async function handleSessionInfo(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);
  const topicId = getTopicId(ctx);

  if (!groupId || !topicId) {
    await ctx.reply('‚ö†Ô∏è This command must be used in a topic.');
    return;
  }

  const session = await getSession(ctx.env, groupId, topicId);

  if (!session) {
    await ctx.reply('‚ö†Ô∏è No session found for this topic.');
    return;
  }

  const token = await getJulesToken(ctx.env, groupId);

  if (!token) {
    await ctx.reply('‚ö†Ô∏è Jules token not configured.');
    return;
  }

  try {
    const julesClient = createJulesClient(token);
    const julesSession = await julesClient.getSession(session.session_id);

    let info = '<b>üìä Session Info</b>\n\n';
    info += `<b>Session ID:</b> <code>${escapeHtml(session.session_id)}</code>\n`;
    info += `<b>Source:</b> ${escapeHtml(session.source)}\n`;
    info += `<b>Status:</b> ${julesSession.state || 'active'}\n`;
    info += `<b>Automation Mode:</b> ${session.automation_mode || 'INTERACTIVE'}\n`;
    info += `<b>Created:</b> ${new Date(session.created_at).toLocaleString()}\n`;

    if (session.starting_branch) {
      info += `<b>Starting Branch:</b> ${escapeHtml(session.starting_branch)}\n`;
    }

    await ctx.reply(info, { parse_mode: 'HTML' });
  } catch (error) {
    console.error('Error fetching session info:', error);
    await ctx.reply(
      '‚ùå Failed to fetch session info.\n\n' +
      'Error: ' + (error instanceof Error ? error.message : 'Unknown error')
    );
  }
}

/**
 * /list_activities command
 * Show activities for current session (use in topic)
 */
export async function handleListActivities(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);
  const topicId = getTopicId(ctx);

  if (!groupId || !topicId) {
    await ctx.reply('‚ö†Ô∏è This command must be used in a topic.');
    return;
  }

  const session = await getSession(ctx.env, groupId, topicId);

  if (!session) {
    await ctx.reply('‚ö†Ô∏è No session found for this topic.');
    return;
  }

  const token = await getJulesToken(ctx.env, groupId);

  if (!token) {
    await ctx.reply('‚ö†Ô∏è Jules token not configured.');
    return;
  }

  await ctx.reply('üîÑ Fetching activities...');

  try {
    const julesClient = createJulesClient(token);
    const activities = await julesClient.listActivities(session.session_id);

    if (activities.length === 0) {
      await ctx.reply('No activities found for this session.');
      return;
    }

    const activitiesList = activities
      .map(a => `‚Ä¢ ${a.title || 'Activity'} (${new Date(a.createTime).toLocaleString()})`)
      .join('\n');

    const formatted = createExpandableBlockquote(
      `üìã Activities (${activities.length} total)`,
      activitiesList
    );

    await ctx.reply(formatted, { parse_mode: 'HTML' });
  } catch (error) {
    console.error('Error fetching activities:', error);
    await ctx.reply(
      '‚ùå Failed to fetch activities.\n\n' +
      'Error: ' + (error instanceof Error ? error.message : 'Unknown error')
    );
  }
}

/**
 * /show_plan command
 * Show plan for current session (use in topic)
 */
export async function handleShowPlan(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);
  const topicId = getTopicId(ctx);

  if (!groupId || !topicId) {
    await ctx.reply('‚ö†Ô∏è This command must be used in a topic.');
    return;
  }

  await ctx.reply('‚ö†Ô∏è Plan display not yet implemented. Use /list_activities to see all activities.');
}

/**
 * /show_outputs command
 * Show outputs (PR, branch, commits) for current session
 */
export async function handleShowOutputs(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);
  const topicId = getTopicId(ctx);

  if (!groupId || !topicId) {
    await ctx.reply('‚ö†Ô∏è This command must be used in a topic.');
    return;
  }

  const session = await getSession(ctx.env, groupId, topicId);

  if (!session) {
    await ctx.reply('‚ö†Ô∏è No session found for this topic.');
    return;
  }

  const token = await getJulesToken(ctx.env, groupId);

  if (!token) {
    await ctx.reply('‚ö†Ô∏è Jules token not configured.');
    return;
  }

  try {
    const julesClient = createJulesClient(token);
    const julesSession = await julesClient.getSession(session.session_id);

    const outputs = formatOutputs(julesSession.outputs);

    await ctx.reply(
      `<b>üì¶ Session Outputs</b>\n\n${outputs}`,
      { parse_mode: 'HTML' }
    );
  } catch (error) {
    console.error('Error fetching outputs:', error);
    await ctx.reply(
      '‚ùå Failed to fetch outputs.\n\n' +
      'Error: ' + (error instanceof Error ? error.message : 'Unknown error')
    );
  }
}

/**
 * /open_jules_settings command
 * Open Jules web interface for advanced repository settings
 */
export async function handleOpenJulesSettings(ctx: BotContext): Promise<void> {
  const groupId = getGroupId(ctx);

  if (!groupId) {
    await ctx.reply('This command only works in group chats.');
    return;
  }

  const source = await getSource(ctx.env, groupId);

  if (!source) {
    await ctx.reply(
      '‚ö†Ô∏è No source configured.\n\n' +
      'Use /list_sources and /set_source to configure a repository first.',
      { parse_mode: 'HTML' }
    );
    return;
  }

  const julesUrl = parseSourceToGitHubUrl(source);

  if (!julesUrl) {
    await ctx.reply(
      '‚ö†Ô∏è Failed to parse source URL.\n\n' +
      'Please verify your source is in the format: sources/github/user/repo',
      { parse_mode: 'HTML' }
    );
    return;
  }

  const keyboard = new InlineKeyboard().url('üîó Open Settings', julesUrl);

  await ctx.reply(
    '‚öôÔ∏è <b>Advanced Jules Settings</b>\n\n' +
    'To configure <b>Setup Script</b>, <b>Environment Variables</b>, and <b>Memories</b>, ' +
    'access the repository settings on the Jules website.\n\n' +
    'These settings are per-repository and affect all future sessions.',
    {
      parse_mode: 'HTML',
      reply_markup: keyboard,
    }
  );
}
</file>

<file path="test/jules.test.ts">
/**
 * Tests for Jules API integration
 * Tests all edge cases and bugs discovered during development
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { createJulesClient, isAuthError, isSessionNotFoundError } from '../src/jules/api';

// Mock fetch
const mockFetch = vi.fn();
vi.stubGlobal('fetch', mockFetch);

describe('Jules API', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('Authentication', () => {
    it('should use X-Goog-Api-Key header (NOT Bearer)', async () => {
      // Setup mock for this test only
      mockFetch.mockReturnValue(
        Promise.resolve({
          ok: true,
          json: async () => ({ sessions: [] }),
        })
      );

      const client = createJulesClient('test-api-key');
      await client.listSessions();

      // Verify X-Goog-Api-Key is used
      const call = mockFetch.mock.calls[0];
      const headers = call[1].headers;
      expect(headers['X-Goog-Api-Key']).toBe('test-api-key');
      expect(headers['Authorization']).toBeUndefined(); // Should NOT have Bearer
      expect(headers['Content-Type']).toBe('application/json');
    });

    it('should detect auth errors (401, 403, unauthorized)', () => {
      const errors = [
        new Error('API error (401): Unauthorized'),
        new Error('API error (403): Forbidden'),
        new Error('unauthorized access'),
      ];

      errors.forEach(error => {
        expect(isAuthError(error)).toBe(true);
      });
    });

    it('should validate token successfully', async () => {
      mockFetch.mockReturnValue(
        Promise.resolve({
          ok: true,
          json: async () => ({ sessions: [] }),
        })
      );

      const client = createJulesClient('valid-token');
      const result = await client.validateToken();

      expect(result).toBe(true);
    });

    it('should handle invalid token', async () => {
      mockFetch.mockReturnValue(
        Promise.resolve({
          ok: false,
          status: 401,
          text: async () => 'Unauthorized',
        })
      );

      const client = createJulesClient('invalid-token');
      const result = await client.validateToken();

      expect(result).toBe(false);
    });
  });

  describe('listSources', () => {
    it('should fetch sources list', async () => {
      mockFetch.mockReturnValue(
        Promise.resolve({
          ok: true,
          json: async () => ({
            sources: [{ name: 'source1' }, { name: 'source2' }],
          }),
        })
      );

      const client = createJulesClient('test-key');
      const sources = await client.listSources();

      expect(sources).toHaveLength(2);
      expect(mockFetch).toHaveBeenCalledTimes(1);
    });

    it('should handle empty sources list', async () => {
      mockFetch.mockReturnValue(
        Promise.resolve({
          ok: true,
          json: async () => ({ sources: [] }),
        })
      );

      const client = createJulesClient('test-key');
      const sources = await client.listSources();

      expect(sources).toEqual([]);
    });
  });

  describe('createSession - API Schema', () => {
    it('should use source_context.source format', async () => {
      mockFetch.mockReturnValue(
        Promise.resolve({
          ok: true,
          json: async () => ({ name: 'session-123', state: 'active' }),
        })
      );

      const client = createJulesClient('test-key');
      await client.createSession({
        prompt: 'Fix the bug',
        source: 'sources/github/user/repo',
      });

      const callArgs = mockFetch.mock.calls[0];
      const body = JSON.parse(callArgs[1].body as string);

      expect(body).toHaveProperty('source_context');
      expect(body.source_context).toHaveProperty('source', 'sources/github/user/repo');
      expect(body).not.toHaveProperty('source'); // Old format should not exist
    });

    it('should handle automationMode correctly (INTERACTIVE, PLAN, AUTO)', async () => {
      mockFetch.mockReturnValue(
        Promise.resolve({
          ok: true,
          json: async () => ({ name: 'session-123' }),
        })
      );

      const client = createJulesClient('test-key');

      // Test INTERACTIVE
      await client.createSession({
        prompt: 'Fix bug',
        source: 'sources/github/user/repo',
        automationMode: 'INTERACTIVE',
      });

      let body = JSON.parse(mockFetch.mock.calls[0][1].body as string);
      expect(body.automation_mode).toBe(1); // Interactive mode

      // Test PLAN
      await client.createSession({
        prompt: 'Fix bug',
        source: 'sources/github/user/repo',
        automationMode: 'PLAN',
      });

      body = JSON.parse(mockFetch.mock.calls[1][1].body as string);
      expect(body.automation_mode).toBe(2); // Plan mode only

      // Test AUTO
      await client.createSession({
        prompt: 'Fix bug',
        source: 'sources/github/user/repo',
        automationMode: 'AUTO',
      });

      body = JSON.parse(mockFetch.mock.calls[2][1].body as string);
      expect(body.automation_mode).toBe(3); // Autonomous mode
    });

    it('should handle optional parameters', async () => {
      mockFetch.mockReturnValue(
        Promise.resolve({
          ok: true,
          json: async () => ({ name: 'session-123' }),
        })
      );

      const client = createJulesClient('test-key');
      await client.createSession({
        prompt: 'Fix bug',
        source: 'sources/github/user/repo',
        requirePlanApproval: true,
        startingBranch: 'main',
        media: {
          data: 'base64data',
          mediaType: 'image/png',
        },
      });

      const body = JSON.parse(mockFetch.mock.calls[0][1].body as string);
      expect(body.require_plan_approval).toBe(true);
      expect(body.starting_branch).toBe('main');
      expect(body.media).toEqual({
        data: 'base64data',
        mediaType: 'image/png',
      });
    });
  });

  describe('getSession', () => {
    it('should detect session not found errors (404)', () => {
      const error = new Error('API error (404): Session not found');
      expect(isSessionNotFoundError(error)).toBe(true);
    });

    it('should fetch session details', async () => {
      const mockSession = {
        name: 'session-123',
        state: 'active',
        source: 'sources/github/user/repo',
      };

      mockFetch.mockReturnValue(
        Promise.resolve({
          ok: true,
          json: async () => mockSession,
        })
      );

      const client = createJulesClient('test-key');
      const session = await client.getSession('session-123');

      expect(session.name).toBe('session-123');
      expect(session.state).toBe('active');
    });
  });

  describe('listActivities', () => {
    it('should fetch activities for a session', async () => {
      const mockActivities = [
        {
          name: 'activity-1',
          title: 'Fixed bug',
          createTime: '2024-01-01T10:00:00Z',
        },
        {
          name: 'activity-2',
          title: 'Added tests',
          createTime: '2024-01-01T11:00:00Z',
        },
      ];

      mockFetch.mockReturnValue(
        Promise.resolve({
          ok: true,
          json: async () => ({ activities: mockActivities }),
        })
      );

      const client = createJulesClient('test-key');
      const activities = await client.listActivities('session-123');

      expect(activities).toHaveLength(2);
      expect(activities[0].title).toBe('Fixed bug');
    });

    it('should handle empty activities', async () => {
      mockFetch.mockReturnValue(
        Promise.resolve({
          ok: true,
          json: async () => ({ activities: [] }),
        })
      );

      const client = createJulesClient('test-key');
      const activities = await client.listActivities('session-123');

      expect(activities).toEqual([]);
    });
  });

  describe('Error Handling', () => {
    it('should throw meaningful error messages', async () => {
      mockFetch.mockReturnValue(
        Promise.resolve({
          ok: false,
          status: 500,
          text: async () => 'Internal Server Error',
        })
      );

      const client = createJulesClient('test-key');

      await expect(client.listSessions()).rejects.toThrow(
        'Jules API error (500): Internal Server Error'
      );
    });

    it('should handle network errors', async () => {
      mockFetch.mockRejectedValue(new Error('Network error'));

      const client = createJulesClient('test-key');

      await expect(client.listSessions()).rejects.toThrow('Network error');
    });
  });

  describe('approvePlan', () => {
    it('should approve a plan', async () => {
      mockFetch.mockReturnValue(
        Promise.resolve({
          ok: true,
          json: async () => ({}),
        })
      );

      const client = createJulesClient('test-key');
      await client.approvePlan('session-123');

      expect(mockFetch).toHaveBeenCalledWith(
        expect.stringContaining('/sessions/session-123:approvePlan'),
        expect.objectContaining({
          method: 'POST',
          body: '{}',
        })
      );
    });
  });

  describe('sendMessage', () => {
    it('should send message to session', async () => {
      mockFetch.mockReturnValue(
        Promise.resolve({
          ok: true,
          json: async () => ({}),
        })
      );

      const client = createJulesClient('test-key');
      await client.sendMessage('session-123', {
        prompt: 'Continue the work',
        media: {
          data: 'base64image',
          mediaType: 'image/png',
        },
      });

      const body = JSON.parse(mockFetch.mock.calls[0][1].body as string);
      expect(body.prompt).toBe('Continue the work');
      expect(body.media).toEqual({
        data: 'base64image',
        mediaType: 'image/png',
      });
    });
  });

  describe('publishBranch & publishPR', () => {
    it('should attempt to publish branch', async () => {
      mockFetch.mockRejectedValue(new Error('Method not found'));

      const client = createJulesClient('test-key');

      await expect(client.publishBranch('session-123')).rejects.toThrow('Method not found');
    });

    it('should attempt to publish PR', async () => {
      mockFetch.mockRejectedValue(new Error('Method not found'));

      const client = createJulesClient('test-key');

      await expect(client.publishPR('session-123')).rejects.toThrow('Method not found');
    });
  });

  describe('Rate Limiting Detection', () => {
    it('should handle API_KEY_SERVICE_BLOCKED error', async () => {
      mockFetch.mockReturnValue(
        Promise.resolve({
          ok: false,
          status: 400,
          text: async () => 'API_KEY_SERVICE_BLOCKED',
        })
      );

      const client = createJulesClient('test-key');

      await expect(client.listSources()).rejects.toThrow(
        'Jules API error (400): API_KEY_SERVICE_BLOCKED'
      );
    });
  });
});
</file>

<file path="src/bot/handlers/callbackHandlers.ts">
/**
 * Callback query handlers
 * Handles inline button clicks (approve plan, publish branch/PR, delete session, etc.)
 */

import type { BotContext } from '../bot';
import { getGroupId, getTopicId } from '../bot';
import {
  getJulesToken,
  getSession,
  deleteSession as deleteSessionKV,
  removeFromSessionsIndex,
  setPendingPlan,
} from '../../kv/storage';
import { createJulesClient } from '../../jules/api';
import { extractGitHubLinks, formatGitHubLinks } from '../../utils/github';
import { escapeHtml } from '../../utils/formatters';

/**
 * Handle callback query for approving plan
 * Pattern: approve_plan:{session_id}
 */
export async function handleApprovePlanCallback(ctx: BotContext): Promise<void> {
  const data = ctx.callbackQuery?.data;

  if (!data || !data.startsWith('approve_plan:')) {
    return;
  }

  const sessionId = data.replace('approve_plan:', '');

  const groupId = getGroupId(ctx);
  const topicId = getTopicId(ctx);

  if (!groupId || !topicId) {
    await ctx.answerCallbackQuery({ text: '‚ö†Ô∏è Invalid context' });
    return;
  }

  const token = await getJulesToken(ctx.env, groupId);

  if (!token) {
    await ctx.answerCallbackQuery({ text: '‚ö†Ô∏è Jules token not configured' });
    return;
  }

  try {
    const julesClient = createJulesClient(token);
    await julesClient.approvePlan(sessionId);

    // Clear pending plan flag
    await setPendingPlan(ctx.env, groupId, topicId, false);

    // Update message to remove button
    await ctx.editMessageReplyMarkup({ reply_markup: undefined });

    // Send confirmation
    await ctx.reply(
      '‚úÖ <b>Plan approved!</b>\n\nJules will start working on the implementation.',
      { parse_mode: 'HTML', disable_notification: true }
    );

    await ctx.answerCallbackQuery({ text: '‚úÖ Plan approved!' });
  } catch (error) {
    console.error('Error approving plan:', error);
    await ctx.answerCallbackQuery({ text: '‚ùå Failed to approve plan' });
  }
}

/**
 * Handle callback query for publishing branch
 * Pattern: publish_branch:{session_id}
 */
export async function handlePublishBranchCallback(ctx: BotContext): Promise<void> {
  const data = ctx.callbackQuery?.data;

  if (!data || !data.startsWith('publish_branch:')) {
    return;
  }

  const sessionId = data.replace('publish_branch:', '');

  const groupId = getGroupId(ctx);

  if (!groupId) {
    await ctx.answerCallbackQuery({ text: '‚ö†Ô∏è Invalid context' });
    return;
  }

  const token = await getJulesToken(ctx.env, groupId);

  if (!token) {
    await ctx.answerCallbackQuery({ text: '‚ö†Ô∏è Jules token not configured' });
    return;
  }

  try {
    const julesClient = createJulesClient(token);

    // Note: Jules API may not have publishBranch endpoint
    // This is a placeholder - may need to be implemented differently
    try {
      const result = await julesClient.publishBranch(sessionId);

      // Update message to show branch link
      await ctx.editMessageText(
        ctx.callbackQuery?.message?.text + '\n\n‚úÖ <b>Branch published!</b>\nüåø ' + result.branchUrl,
        { parse_mode: 'HTML' }
      );

      await ctx.answerCallbackQuery({ text: '‚úÖ Branch published!' });
    } catch (error) {
      // If endpoint doesn't exist, inform user
      await ctx.answerCallbackQuery({
        text: '‚ö†Ô∏è This feature requires manual action via jules.google',
        show_alert: true,
      });
    }
  } catch (error) {
    console.error('Error publishing branch:', error);
    await ctx.answerCallbackQuery({ text: '‚ùå Failed to publish branch' });
  }
}

/**
 * Handle callback query for publishing PR
 * Pattern: publish_pr:{session_id}
 */
export async function handlePublishPRCallback(ctx: BotContext): Promise<void> {
  const data = ctx.callbackQuery?.data;

  if (!data || !data.startsWith('publish_pr:')) {
    return;
  }

  const sessionId = data.replace('publish_pr:', '');

  const groupId = getGroupId(ctx);

  if (!groupId) {
    await ctx.answerCallbackQuery({ text: '‚ö†Ô∏è Invalid context' });
    return;
  }

  const token = await getJulesToken(ctx.env, groupId);

  if (!token) {
    await ctx.answerCallbackQuery({ text: '‚ö†Ô∏è Jules token not configured' });
    return;
  }

  try {
    const julesClient = createJulesClient(token);

    // Note: Jules API may not have publishPR endpoint
    // This is a placeholder - may need to be implemented differently
    try {
      const result = await julesClient.publishPR(sessionId);

      // Update message to show PR link
      await ctx.editMessageText(
        ctx.callbackQuery?.message?.text + '\n\n‚úÖ <b>Pull Request created!</b>\nüîÄ ' + result.prUrl,
        { parse_mode: 'HTML' }
      );

      await ctx.answerCallbackQuery({ text: '‚úÖ PR created!' });
    } catch (error) {
      // If endpoint doesn't exist, inform user
      await ctx.answerCallbackQuery({
        text: '‚ö†Ô∏è This feature requires manual action via jules.google',
        show_alert: true,
      });
    }
  } catch (error) {
    console.error('Error publishing PR:', error);
    await ctx.answerCallbackQuery({ text: '‚ùå Failed to publish PR' });
  }
}

/**
 * Handle callback query for deleting session
 * Pattern: delete_session:{session_id}
 */
export async function handleDeleteSessionCallback(ctx: BotContext): Promise<void> {
  const data = ctx.callbackQuery?.data;

  if (!data || !data.startsWith('delete_session:')) {
    return;
  }

  const sessionId = data.replace('delete_session:', '');

  const groupId = getGroupId(ctx);
  const topicId = getTopicId(ctx);

  if (!groupId || !topicId) {
    await ctx.answerCallbackQuery({ text: '‚ö†Ô∏è Invalid context' });
    return;
  }

  const session = await getSession(ctx.env, groupId, topicId);

  if (!session || session.session_id !== sessionId) {
    await ctx.answerCallbackQuery({ text: '‚ö†Ô∏è Session not found' });
    return;
  }

  try {
    // Remove from KV
    await deleteSessionKV(ctx.env, groupId, topicId);
    await removeFromSessionsIndex(ctx.env, groupId, sessionId);

    // Update message to remove buttons
    await ctx.editMessageReplyMarkup({ reply_markup: undefined });

    await ctx.reply(
      '‚úÖ <b>Session deleted from bot.</b>\n\n' +
      '<i>Note: To delete the session permanently, visit jules.google</i>',
      { parse_mode: 'HTML' }
    );

    await ctx.answerCallbackQuery({ text: '‚úÖ Session deleted' });
  } catch (error) {
    console.error('Error deleting session:', error);
    await ctx.answerCallbackQuery({ text: '‚ùå Failed to delete session' });
  }
}

/**
 * Handle callback query for canceling deletion
 * Pattern: cancel_delete
 */
export async function handleCancelDeleteCallback(ctx: BotContext): Promise<void> {
  const data = ctx.callbackQuery?.data;

  if (data !== 'cancel_delete') {
    return;
  }

  try {
    // Update message to remove buttons
    await ctx.editMessageReplyMarkup({ reply_markup: undefined });

    await ctx.answerCallbackQuery({ text: '‚ùå Deletion cancelled' });
  } catch (error) {
    console.error('Error canceling deletion:', error);
  }
}

/**
 * Handle callback query for sources pagination
 * Pattern: sources_page:{page_number}
 */
export async function handleSourcesPageCallback(ctx: BotContext): Promise<void> {
  const data = ctx.callbackQuery?.data;

  if (!data || !data.startsWith('sources_page:')) {
    return;
  }

  const page = parseInt(data.replace('sources_page:', ''));

  if (isNaN(page) || page < 0) {
    await ctx.answerCallbackQuery({ text: '‚ö†Ô∏è Invalid page number' });
    return;
  }

  const groupId = getGroupId(ctx);

  if (!groupId) {
    await ctx.answerCallbackQuery({ text: '‚ö†Ô∏è Invalid context' });
    return;
  }

  const token = await getJulesToken(ctx.env, groupId);

  if (!token) {
    await ctx.answerCallbackQuery({ text: '‚ö†Ô∏è Jules token not configured' });
    return;
  }

  try {
    // Get cached sources
    const { getSourcesCache } = await import('../../kv/storage');
    const sources = await getSourcesCache(ctx.env, token);

    if (!sources || sources.length === 0) {
      await ctx.answerCallbackQuery({ text: '‚ö†Ô∏è Sources cache not found. Use /list_sources again.' });
      return;
    }

    // Show requested page
    await showSourcesPage(ctx, sources, page);

    await ctx.answerCallbackQuery();
  } catch (error) {
    console.error('Error handling sources page:', error);
    await ctx.answerCallbackQuery({ text: '‚ùå Failed to load page' });
  }
}

/**
 * Handle callback query for selecting a source
 * Pattern: select_source:{page}:{index}
 */
export async function handleSelectSourceCallback(ctx: BotContext): Promise<void> {
  const data = ctx.callbackQuery?.data;

  if (!data || !data.startsWith('select_source:')) {
    return;
  }

  const parts = data.replace('select_source:', '').split(':');
  if (parts.length !== 2) {
    await ctx.answerCallbackQuery({ text: '‚ö†Ô∏è Invalid selection' });
    return;
  }

  const [pageStr, indexStr] = parts;
  const page = parseInt(pageStr);
  const index = parseInt(indexStr);

  if (isNaN(page) || isNaN(index) || page < 0 || index < 0) {
    await ctx.answerCallbackQuery({ text: '‚ö†Ô∏è Invalid selection data' });
    return;
  }

  const groupId = getGroupId(ctx);

  if (!groupId) {
    await ctx.answerCallbackQuery({ text: '‚ö†Ô∏è Invalid context' });
    return;
  }

  const token = await getJulesToken(ctx.env, groupId);

  if (!token) {
    await ctx.answerCallbackQuery({ text: '‚ö†Ô∏è Jules token not configured' });
    return;
  }

  try {
    // Get cached sources and get specific source by page + index
    const { getSourcesCache } = await import('../../kv/storage');
    const sources = await getSourcesCache(ctx.env, token);

    if (!sources || sources.length === 0) {
      await ctx.answerCallbackQuery({ text: '‚ö†Ô∏è Sources cache not found. Use /list_sources again.' });
      return;
    }

    // Calculate actual index in sources array
    const PAGE_SIZE = 10;
    const start = page * PAGE_SIZE;
    const actualIndex = start + index;

    if (actualIndex >= sources.length) {
      await ctx.answerCallbackQuery({ text: '‚ö†Ô∏è Source index out of range' });
      return;
    }

    const source = sources[actualIndex];

    if (!source) {
      await ctx.answerCallbackQuery({ text: '‚ö†Ô∏è Source not found. Please try again.' });
      return;
    }

    // Save source
    const { setSource } = await import('../../kv/storage');
    await setSource(ctx.env, groupId, source.name);

    // Parse source name for display
    const sourceDisplay = source.name.split('/').slice(3).join('/'); // sources/github/user/repo -> user/repo

    // Update message to show confirmation
    await ctx.editMessageText(
      `<b>‚úÖ Source Selected</b>\n\n` +
      `<code>${escapeHtml(source.name)}</code>\n\n` +
      `This repository will now be used as default for new sessions.\n` +
      `You can change it anytime with /list_sources`,
      { parse_mode: 'HTML' }
    );

    await ctx.answerCallbackQuery({ text: `‚úÖ Selected: ${sourceDisplay}` });
  } catch (error) {
    console.error('Error selecting source:', error);
    await ctx.answerCallbackQuery({ text: '‚ùå Failed to select source' });
  }
}

/**
 * Show a specific page of sources with pagination keyboard
 * Shared between handleListSources and handleSourcesPageCallback
 */
export async function showSourcesPage(ctx: BotContext, sources: any[], page: number, hasMore: boolean = false): Promise<void> {
  const PAGE_SIZE = 10;
  const totalPages = Math.ceil(sources.length / PAGE_SIZE);
  const start = page * PAGE_SIZE;
  const end = Math.min(start + PAGE_SIZE, sources.length);
  const pageSources = sources.slice(start, end);

  let message = `<b>üìö Available Sources (${sources.length}${hasMore ? '+' : ''} total)</b>\n\n`;
  message += `<i>Page ${page + 1} of ${totalPages}</i>\n\n`;
  if (hasMore) {
    message += `<i>‚è≥ Loading more sources in background... Use /list_sources again in a few seconds to see all.</i>\n\n`;
  }
  message += `<i>Tap a source to select it as default</i>\n\n`;

  // Create pagination keyboard
  const { InlineKeyboard } = await import('grammy');
  const keyboard = new InlineKeyboard();

  // Add buttons for each source (1 per line)
  pageSources.forEach((source, index) => {
    const num = start + index + 1;

    // Extract owner/repo from source name (format: sources/github/owner/repo)
    let displayText = source.displayName || source.name;
    if (source.name.includes('sources/github/')) {
      const parts = source.name.split('/');
      if (parts.length >= 4) {
        const owner = parts[2];
        const repo = parts[3];
        displayText = `${owner}/${repo}`;
      }
    }

    const displayName = `${num}. ${displayText}`;

    // Use page:index for callback data (shorter, precise)
    keyboard.text(`üì¶ ${displayName}`, `select_source:${page}:${index}`);

    // Move to next line for next source
    keyboard.row();
  });

  // Add pagination buttons
  if (totalPages > 1) {
    if (page > 0) {
      keyboard.text(`‚¨ÖÔ∏è Prev (${page})`, `sources_page:${page - 1}`);
    }

    if (page < totalPages - 1) {
      keyboard.text(`Next (${page + 2}) ‚û°Ô∏è`, `sources_page:${page + 1}`);
    }

    // Add close button on new row
    keyboard.row();
    keyboard.text('‚ùå Close', 'sources_close');
  }

  // Use reply for first message, edit for callback queries
  if (ctx.callbackQuery) {
    await ctx.editMessageText(message, {
      parse_mode: 'HTML',
      reply_markup: keyboard,
    });
  } else {
    await ctx.reply(message, {
      parse_mode: 'HTML',
      reply_markup: keyboard,
    });
  }
}

/**
 * Handle callback query for closing sources list
 * Pattern: sources_close
 */
export async function handleSourcesCloseCallback(ctx: BotContext): Promise<void> {
  const data = ctx.callbackQuery?.data;

  if (data !== 'sources_close') {
    return;
  }

  try {
    await ctx.editMessageReplyMarkup({ reply_markup: undefined });
    await ctx.answerCallbackQuery({ text: '‚úÖ Closed' });
  } catch (error) {
    console.error('Error closing sources:', error);
  }
}

/**
 * Main callback query handler
 * Routes to specific handlers based on callback data pattern
 */
export async function handleCallbackQuery(ctx: BotContext): Promise<void> {
  const data = ctx.callbackQuery?.data;

  if (!data) {
    return;
  }

  // Route to specific handlers
  if (data.startsWith('approve_plan:')) {
    await handleApprovePlanCallback(ctx);
  } else if (data.startsWith('publish_branch:')) {
    await handlePublishBranchCallback(ctx);
  } else if (data.startsWith('publish_pr:')) {
    await handlePublishPRCallback(ctx);
  } else if (data.startsWith('delete_session:')) {
    await handleDeleteSessionCallback(ctx);
  } else if (data === 'cancel_delete') {
    await handleCancelDeleteCallback(ctx);
  } else if (data.startsWith('sources_page:')) {
    await handleSourcesPageCallback(ctx);
  } else if (data.startsWith('select_source:')) {
    await handleSelectSourceCallback(ctx);
  } else if (data === 'sources_close') {
    await handleSourcesCloseCallback(ctx);
  } else {
    // Unknown callback
    await ctx.answerCallbackQuery({ text: '‚ö†Ô∏è Unknown action' });
  }
}
</file>

<file path="src/jules/api.ts">
/**
 * Jules API integration
 * Handles all API calls to Jules (Google's AI coding assistant)
 * Documentation: https://developers.google.com/jules/api
 */

import type { JulesSession, JulesActivity, JulesSource } from '../types/env';
import { retryWithBackoff, isRetryableStatusCode } from '../utils/retry';

const JULES_API_BASE = 'https://jules.googleapis.com/v1alpha';

/**
 * Jules API client
 */
export class JulesAPI {
  private apiKey: string;

  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }

  /**
   * Make authenticated request to Jules API
   */
  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${JULES_API_BASE}${endpoint}`;

    const response = await fetch(url, {
      ...options,
      headers: {
        'X-Goog-Api-Key': this.apiKey,
        'Content-Type': 'application/json',
        ...options.headers,
      },
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Jules API error (${response.status}): ${errorText}`);
    }

    return await response.json();
  }

  /**
   * Validate API token by checking /sessions endpoint
   */
  async validateToken(): Promise<boolean> {
    try {
      await this.listSessions();
      return true;
    } catch (error) {
      console.error('Token validation failed:', error);
      return false;
    }
  }

  /**
   * List all sources available to the user with timeout protection
   * GET /v1alpha/sources
   * Fetches sources with a time limit to avoid worker timeouts
   * Optimized to fetch as many sources as possible within timeout
   * @param timeoutMs - Maximum time to spend fetching (default 9000ms)
   * @param pageSize - Number of sources per page (default 100, API max)
   * @returns Object with sources array and hasMore indicator
   */
  async listSources(timeoutMs: number = 9000, pageSize: number = 100): Promise<{ sources: JulesSource[]; hasMore: boolean }> {
    console.log(`[listSources] Starting with ${timeoutMs}ms timeout, pageSize=${pageSize}`);
    const startTime = Date.now();

    // Shared state between fetchSources and timeout
    const sharedState = {
      sources: [] as JulesSource[],
      hasMore: false,
      stopped: false,
    };

    const fetchSources = async (): Promise<void> => {
      let nextPageToken: string | undefined;
      let pageNum = 0;

      try {
        do {
          // Check if we should stop
          if (sharedState.stopped) {
            console.log(`[listSources] Fetch stopped by timeout at page ${pageNum}`);
            break;
          }

          pageNum++;

          // Build URL with pageSize parameter
          let url = `/sources?pageSize=${pageSize}`;
          if (nextPageToken) {
            url += `&pageToken=${encodeURIComponent(nextPageToken)}`;
          }

          console.log(`[listSources] Fetching page ${pageNum}...`);
          const pageStart = Date.now();

          const response = await retryWithBackoff(() =>
            this.request<{ sources?: JulesSource[]; nextPageToken?: string }>(url),
            { maxAttempts: 1 } // Single attempt to avoid delays
          );

          const pageTime = Date.now() - pageStart;

          if (response.sources && response.sources.length > 0) {
            sharedState.sources.push(...response.sources);
            console.log(`[listSources] Page ${pageNum} returned ${response.sources.length} sources in ${pageTime}ms (total: ${sharedState.sources.length})`);
          }

          nextPageToken = response.nextPageToken;
          sharedState.hasMore = !!nextPageToken;
          console.log(`[listSources] Page ${pageNum} nextPageToken: ${nextPageToken ? 'exists' : 'null'}`);
        } while (nextPageToken && !sharedState.stopped);

        if (!sharedState.stopped) {
          console.log(`[listSources] Fetch complete: ${sharedState.sources.length} total sources in ${Date.now() - startTime}ms`);
        }
      } catch (error) {
        console.error('[listSources] Error in fetchSources:', error);
        sharedState.hasMore = true; // Assume there might be more
      }
    };

    // Start fetching (don't await yet)
    const fetchPromise = fetchSources();

    // Wait for either completion or timeout
    await Promise.race([
      fetchPromise,
      new Promise<void>((resolve) => {
        setTimeout(() => {
          console.log(`[listSources] Timeout triggered after ${timeoutMs}ms`);
          sharedState.stopped = true;
          sharedState.hasMore = true;
          resolve();
        }, timeoutMs);
      })
    ]);

    // If we have no sources at all, try to get at least the first page
    if (sharedState.sources.length === 0) {
      console.log('[listSources] No sources collected, attempting first page...');
      try {
        const response = await retryWithBackoff(() =>
          this.request<{ sources?: JulesSource[]; nextPageToken?: string }>(`/sources?pageSize=${pageSize}`),
          { maxAttempts: 1 }
        );

        if (response.sources) {
          sharedState.sources = response.sources;
          sharedState.hasMore = !!response.nextPageToken;
          console.log(`[listSources] First page fallback: ${sharedState.sources.length} sources`);
        }
      } catch (error) {
        console.error('[listSources] Error fetching first page:', error);
      }
    }

    console.log(`[listSources] Returning ${sharedState.sources.length} sources (hasMore: ${sharedState.hasMore}) in ${Date.now() - startTime}ms`);
    return { sources: sharedState.sources, hasMore: sharedState.hasMore };
  }

  /**
   * Get a specific source
   * GET /v1alpha/sources/{source_name}
   */
  async getSource(sourceName: string): Promise<JulesSource> {
    return await retryWithBackoff(() =>
      this.request<JulesSource>(`/sources/${sourceName}`)
    );
  }

  /**
   * List all sessions
   * GET /v1alpha/sessions
   */
  async listSessions(): Promise<JulesSession[]> {
    const response = await retryWithBackoff(() =>
      this.request<{ sessions: JulesSession[] }>('/sessions')
    );

    return response.sessions || [];
  }

  /**
   * Get a specific session
   * GET /v1alpha/sessions/{session_id}
   */
  async getSession(sessionId: string): Promise<JulesSession> {
    return await retryWithBackoff(() =>
      this.request<JulesSession>(`/sessions/${sessionId}`)
    );
  }

  /**
   * Create a new session
   * POST /v1alpha/sessions
   */
  async createSession(params: {
    prompt: string;
    source: string;
    automationMode?: 'INTERACTIVE' | 'PLAN' | 'AUTO';
    requirePlanApproval?: boolean;
    startingBranch?: string;
    media?: {
      data: string;
      mediaType: string;
    };
  }): Promise<JulesSession> {
    const body: any = {
      prompt: params.prompt,
      source_context: {
        source: params.source,
      },
    };

    // Only send automation_mode if explicitly specified
    // Default might be handled by the API
    if (params.automationMode) {
      if (params.automationMode === 'INTERACTIVE') {
        body.automation_mode = 1;
      } else if (params.automationMode === 'PLAN') {
        body.automation_mode = 2;
      } else if (params.automationMode === 'AUTO') {
        body.automation_mode = 3;
      }
    }

    // Only send optional fields if provided
    if (params.requirePlanApproval !== undefined && params.requirePlanApproval !== null) {
      body.require_plan_approval = params.requirePlanApproval;
    }

    if (params.startingBranch && params.startingBranch.trim() !== '') {
      body.starting_branch = params.startingBranch;
    }

    if (params.media) {
      body.media = params.media;
    }

    return await retryWithBackoff(() =>
      this.request<JulesSession>('/sessions', {
        method: 'POST',
        body: JSON.stringify(body),
      })
    );
  }

  /**
   * Send a message to an existing session
   * POST /v1alpha/sessions/{session_id}:sendMessage
   */
  async sendMessage(
    sessionId: string,
    params: {
      prompt: string;
      media?: {
        data: string;
        mediaType: string;
      };
    }
  ): Promise<void> {
    await retryWithBackoff<void>(() =>
      this.request<void>(`/sessions/${sessionId}:sendMessage`, {
        method: 'POST',
        body: JSON.stringify(params),
      })
    );
  }

  /**
   * Approve a plan for a session
   * POST /v1alpha/sessions/{session_id}:approvePlan
   */
  async approvePlan(sessionId: string): Promise<void> {
    await retryWithBackoff<void>(() =>
      this.request<void>(`/sessions/${sessionId}:approvePlan`, {
        method: 'POST',
        body: JSON.stringify({}),
      })
    );
  }

  /**
   * List activities for a session
   * GET /v1alpha/sessions/{session_id}/activities
   */
  async listActivities(sessionId: string): Promise<JulesActivity[]> {
    const response = await retryWithBackoff(() =>
      this.request<{ activities: JulesActivity[] }>(`/sessions/${sessionId}/activities`)
    );

    return response.activities || [];
  }

  /**
   * Get activities created after a specific time
   * Used for polling new activities
   */
  async getNewActivities(sessionId: string, afterTime: string): Promise<JulesActivity[]> {
    const activities = await this.listActivities(sessionId);

    // Filter activities created after the specified time
    return activities.filter(activity => activity.createTime > afterTime);
  }

  /**
   * Publish branch for a session
   * POST /v1alpha/sessions/{session_id}:publishBranch
   * Note: This endpoint may not exist in the API, check documentation
   */
  async publishBranch(sessionId: string): Promise<{ branchUrl: string }> {
    return await retryWithBackoff(() =>
      this.request<{ branchUrl: string }>(`/sessions/${sessionId}:publishBranch`, {
        method: 'POST',
        body: JSON.stringify({}),
      })
    );
  }

  /**
   * Publish PR for a session
   * POST /v1alpha/sessions/{session_id}:publishPr
   * Note: This endpoint may not exist in the API, check documentation
   */
  async publishPR(sessionId: string): Promise<{ prUrl: string }> {
    return await retryWithBackoff(() =>
      this.request<{ prUrl: string }>(`/sessions/${sessionId}:publishPr`, {
        method: 'POST',
        body: JSON.stringify({}),
      })
    );
  }
}

/**
 * Create Jules API client instance
 */
export function createJulesClient(apiKey: string): JulesAPI {
  return new JulesAPI(apiKey);
}

/**
 * Check if error is a Jules API authentication error
 */
export function isAuthError(error: Error): boolean {
  const message = error.message.toLowerCase();
  return message.includes('401') || message.includes('403') || message.includes('unauthorized');
}

/**
 * Check if error is a session not found error
 */
export function isSessionNotFoundError(error: Error): boolean {
  const message = error.message.toLowerCase();
  return message.includes('404') || message.includes('not found');
}
</file>

</files>

<git_diffs>
<git_diff_work_tree>
src/bot/commands/infoCommands.ts --- 1/3 --- TypeScript
123       const julesClient = createJul 123       const julesClient = createJul
... esClient(token);                    ... esClient(token);
124       console.log('[DEBUG] JulesCli 124       console.log('[DEBUG] JulesCli
... ent created, calling listSources... ... ent created, calling listSources...
... ');                                 ... ');
125                                     125 
126       // Use 9s timeout to get as m 126       // Use 9s timeout to get firs
... any sources as possible             ... t batch quickly
127       // This should fetch 1-2 page ... 
... s (100-200 sources) before timeout  ... 
128       const result = await julesCli 127       const result = await julesCli
... ent.listSources(9000);              ... ent.listSources(9000);
129                                     128 
130       if (result.sources.length === 129       if (result.sources.length ===
     0) {                                    0) {

src/bot/commands/infoCommands.ts --- 2/3 --- TypeScript
139       }));                          138       }));
140       hasMore = result.hasMore;     139       hasMore = result.hasMore;
141                                     140 
142       // Cache the results for 1 ho 141       // Cache the initial results 
... ur                                  ... for 1 hour
143       await setSourcesCache(ctx.env 142       await setSourcesCache(ctx.env
... , token, sources);                  ... , token, sources);
144                                     143 
145       console.log(`[DEBUG] Cached $ 144       console.log(`[DEBUG] Cached $
... {sources.length} sources (hasMore:  ... {sources.length} sources (hasMore: 
... ${hasMore})`);                      ... ${hasMore})`);
...                                     145 
...                                     146       // If there are more sources,
...                                     ...  start background fetch to get them
...                                     ...  all
...                                     147       if (hasMore) {
...                                     148         console.log('[DEBUG] More s
...                                     ... ources available, will fetch in bac
...                                     ... kground...');
...                                     149         // Don't await - let it run
...                                     ...  in background
...                                     150         fetchAllSourcesInBackground
...                                     ... (ctx.env, token).catch(error => {
...                                     151           console.error('[DEBUG] Ba
...                                     ... ckground fetch error:', error);
...                                     152         });
...                                     153       }
146     }                               154     }
147                                     155 
148     // Show first page (10 sources  156     // Show first page (10 sources 
    per page)                               per page)

src/bot/commands/infoCommands.ts --- 3/3 --- TypeScript
157 165   }
158 166 }
... 167 
... 168 /**
... 169  * Fetch all sources in background without timeout limit
... 170  * Updates cache progressively as pages are fetched
... 171  */
... 172 async function fetchAllSourcesInBackground(env: any, token: string): Promise<void> {
... 173   console.log('[fetchAllSourcesInBackground] Starting full fetch...');
... 174   const startTime = Date.now();
... 175 
... 176   try {
... 177     const julesClient = createJulesClient(token);
... 178     const allSources: any[] = [];
... 179     let nextPageToken: string | undefined;
... 180     let pageNum = 0;
... 181     const pageSize = 100;
... 182 
... 183     do {
... 184       pageNum++;
... 185       const url = nextPageToken
... 186         ? `/sources?pageSize=${pageSize}&pageToken=${encodeURIComponent(nextPageToken)}`
... 187         : `/sources?pageSize=${pageSize}`;
... 188 
... 189       console.log(`[fetchAllSourcesInBackground] Fetching page ${pageNum}...`);
... 190 
... 191       const response = await fetch(`https://jules.googleapis.com/v1alpha${url}`, {
... 192         headers: {
... 193           'X-Goog-Api-Key': token,
... 194           'Content-Type': 'application/json',
... 195         },
... 196       });
... 197 
... 198       if (!response.ok) {
... 199         console.error(`[fetchAllSourcesInBackground] API error: ${response.status}`);
... 200         break;
... 201       }
... 202 
... 203       const data: any = await response.json();
... 204 
... 205       if (data.sources && data.sources.length > 0) {
... 206         const mapped = data.sources.map((s: any) => ({
... 207           name: s.name,
... 208           displayName: s.displayName,
... 209           description: s.description,
... 210         }));
... 211         allSources.push(...mapped);
... 212 
... 213         console.log(`[fetchAllSourcesInBackground] Page ${pageNum}: +${data.sources.length} sources (total: ${allSources.length})`);
... 214 
... 215         // Update cache after each page
... 216         const { setSourcesCache } = await import('../../kv/storage');
... 217         await setSourcesCache(env, token, allSources);
... 218       }
... 219 
... 220       nextPageToken = data.nextPageToken;
... 221 
... 222       // Safety limit: max 10 pages (1000 sources)
... 223       if (pageNum >= 10) {
... 224         console.log('[fetchAllSourcesInBackground] Reached page limit (10)');
... 225         break;
... 226       }
... 227     } while (nextPageToken);
... 228 
... 229     const duration = Date.now() - startTime;
... 230     console.log(`[fetchAllSourcesInBackground] Complete: ${allSources.length} sources in ${duration}ms (${pageNum} pages)`);
... 231   } catch (error) {
... 232     console.error('[fetchAllSourcesInBackground] Error:', error);
... 233   }
... 234 }
159 235 
160 236 /**
161 237  * /search_sources command

src/bot/handlers/callbackHandlers.ts --- TypeScript
403   let message = `<b>üìö Available So 403   let message = `<b>üìö Available So
... urces (${sources.length}${hasMore ? ... urces (${sources.length}${hasMore ?
...  '+' : ''} total)</b>\n\n`;         ...  '+' : ''} total)</b>\n\n`;
404   message += `<i>Page ${page + 1} o 404   message += `<i>Page ${page + 1} o
... f ${totalPages}</i>\n\n`;           ... f ${totalPages}</i>\n\n`;
405   if (hasMore) {                    405   if (hasMore) {
406     message += `<i>‚ö†Ô∏è Showing first  406     message += `<i>‚è≥ Loading more 
... ${sources.length} sources (timeout  ... sources in background... Use /list_
... limit reached)</i>\n\n`;            ... sources again in a few seconds to s
...                                     ... ee all.</i>\n\n`;
407   }                                 407   }
408   message += `<i>Tap a source to se 408   message += `<i>Tap a source to se
... lect it as default</i>\n\n`;        ... lect it as default</i>\n\n`;
409                                     409 


</git_diff_work_tree>
<git_diff_staged>

</git_diff_staged>
</git_diffs>

<git_logs>
<git_log_commit>
<date>2025-11-17 03:57:36 -0300</date>
<message>feat: Increase timeout to 9s for better sources coverage</message>
<files>
src/bot/commands/infoCommands.ts
src/cron/refreshSourcesCache.ts
src/jules/api.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-17 03:42:02 -0300</date>
<message>feat: Add search functionality and improve sources display</message>
<files>
repomix-output.xml
src/bot/commands/infoCommands.ts
src/bot/handlers/callbackHandlers.ts
src/index.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-17 03:28:23 -0300</date>
<message>feat: Fix sources pagination with timeout protection and pageSize optimization</message>
<files>
repomix-output.xml
src/bot/commands/infoCommands.ts
src/bot/handlers/callbackHandlers.ts
src/jules/api.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-17 02:27:10 -0300</date>
<message>add tail</message>
<files>
package.json
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-17 00:45:53 -0300</date>
<message>docs: Consolidate AI agent documentation and add repomix integration</message>
<files>
AGENTS.md
BUGS_DOCUMENTATION.md
CLAUDE.md
PLAN.md
deleteme.txt
repomix-output.xml
repomix.config.json
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-10 12:10:14 +0000</date>
<message>chore(deps-dev)(deps-dev): bump the minor-and-patch group with 3 updates (#10)</message>
<files>
package-lock.json
package.json
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 13:04:54 -0300</date>
<message>fix: Resolve TypeScript errors in automation mode and API</message>
<files>
BUGS_DOCUMENTATION.md
src/bot/commands/actionCommands.ts
src/bot/commands/configCommands.ts
src/bot/commands/infoCommands.ts
src/bot/handlers/messageHandlers.ts
src/jules/api.ts
src/kv/storage.ts
src/types/env.ts
src/utils/formatters.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 12:58:47 -0300</date>
<message>docs: Remove outdated wrangler global installation recommendation</message>
<files>
README.md
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 02:29:30 -0300</date>
<message>fix: Only send fields to Jules API if explicitly provided</message>
<files>
src/jules/api.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 02:27:09 -0300</date>
<message>test: Update tests for 3 Jules automation modes</message>
<files>
test/jules.test.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 02:25:25 -0300</date>
<message>fix: Update automation modes to match Jules UI (Interactive, Plan, Autonomous)</message>
<files>
src/jules/api.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 02:24:06 -0300</date>
<message>test: Update tests for numeric automation_mode enum values</message>
<files>
test/jules.test.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 02:21:57 -0300</date>
<message>fix: Use numeric enum values for automation_mode (protobuf standard)</message>
<files>
README.md
src/jules/api.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 02:17:32 -0300</date>
<message>fix: Reduce sources cache TTL from 1 hour to 5 minutes</message>
<files>
src/kv/storage.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 02:10:48 -0300</date>
<message>test: Update jules tests to match corrected automation_mode format</message>
<files>
test/jules.test.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 02:08:57 -0300</date>
<message>fix: Correct automation_mode values for Jules API createSession</message>
<files>
src/jules/api.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 01:54:34 -0300</date>
<message>feat: Implement proper pagination for Jules API listSources</message>
<files>
src/bot/handlers/callbackHandlers.ts
src/jules/api.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 01:49:38 -0300</date>
<message>fix: Fix BUTTON_DATA_INVALID error by limiting callback data size</message>
<files>
src/bot/handlers/callbackHandlers.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 01:38:45 -0300</date>
<message>feat: Add clickable source selection buttons</message>
<files>
src/bot/handlers/callbackHandlers.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 01:32:51 -0300</date>
<message>fix: Use reply for first sources page instead of editMessageText</message>
<files>
src/bot/handlers/callbackHandlers.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 01:28:29 -0300</date>
<message>feat: Implement pagination for sources with KV cache</message>
<files>
src/bot/commands/infoCommands.ts
src/bot/handlers/callbackHandlers.ts
src/kv/storage.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 01:16:17 -0300</date>
<message>fix: URGENT - Revert pagination to prevent infinite loop</message>
<files>
src/jules/api.ts
test/jules.test.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 01:00:22 -0300</date>
<message>docs: Simplify README and add workflow status badges</message>
<files>
README.md
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 00:40:14 -0300</date>
<message>fix: Remove redundant SARIF upload step in CodeQL workflow</message>
<files>
.github/workflows/codeql.yml
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 00:29:02 -0300</date>
<message>fix: Correct Jules API authentication and add comprehensive tests</message>
<files>
src/jules/api.ts
src/utils/formatters.ts
test/formatters.test.ts
test/jules.test.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 00:13:50 -0300</date>
<message>debug: Add debug logs to listSources</message>
<files>
src/bot/commands/infoCommands.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 00:09:37 -0300</date>
<message>fix: Resolve merge conflicts</message>
<files>
src/jules/api.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 00:08:25 -0300</date>
<message>revert: Revert API changes (testing)</message>
<files>
src/jules/api.ts
src/utils/formatters.ts
test/formatters.test.ts
test/jules.test.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 00:08:00 -0300</date>
<message>revert: URGENT - Revert pagination (causing infinite loop)</message>
<files>
src/jules/api.ts
test/jules.test.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-06 00:04:52 -0300</date>
<message>revert: URGENT - Revert visual interface (causing crash)</message>
<files>
src/bot/commands/infoCommands.ts
src/bot/handlers/callbackHandlers.ts
src/utils/formatters.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-05 23:58:03 -0300</date>
<message>feat: Add visual interface for /list_sources with inline keyboard</message>
<files>
src/bot/commands/infoCommands.ts
src/bot/handlers/callbackHandlers.ts
src/utils/formatters.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-05 23:55:13 -0300</date>
<message>fix: URGENT - Prevent infinite loop in listSources pagination</message>
<files>
src/jules/api.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-05 22:10:18 -0300</date>
<message>fix: Add pagination to listSources and fix session creation schema</message>
<files>
src/jules/api.ts
test/jules.test.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-05 22:01:49 -0300</date>
<message>test: Update tests with Jules API authentication and escapeHtml changes</message>
<files>
src/jules/api.ts
src/utils/formatters.ts
test/formatters.test.ts
test/jules.test.ts
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-05 21:50:09 -0300</date>
<message>docs: Update README with BOT_TOKEN secret requirements and wrangler command fixes</message>
<files>
CLAUDE.md
README.md
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-05 21:05:19 -0300</date>
<message>force run</message>
<files>
deleteme.txt
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-05 20:56:40 -0300</date>
<message>trigger: Force redeploy with updated secrets</message>
<files>
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-05 20:50:46 -0300</date>
<message>refactor: Update KV preview namespace to use cleaner name</message>
<files>
wrangler.toml
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-05 20:36:38 -0300</date>
<message>feat: Add KV namespaces for production and preview environments</message>
<files>
CLAUDE.md
package.json
wrangler.toml
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-05 19:52:46 -0300</date>
<message>chore(deps): Update all dependencies to latest versions</message>
<files>
package-lock.json
package.json
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-05 16:52:53 -0300</date>
<message>refactor: Update project name and domains to jules-over-telegram</message>
<files>
.github/README.md
.github/workflows/deploy.yml
README.md
package.json
wrangler.toml
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-05 07:27:18 -0300</date>
<message>ci(deps): Bump actions/github-script from 7 to 8</message>
<files>
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-05 07:26:59 -0300</date>
<message>ci(deps): Bump codecov/codecov-action from 4 to 5</message>
<files>
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-05 07:26:16 -0300</date>
<message>ci(deps): Bump actions/checkout from 4 to 5</message>
<files>
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-05 07:26:04 -0300</date>
<message>ci(deps): Bump github/codeql-action from 3 to 4</message>
<files>
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-05 07:25:26 -0300</date>
<message>ci(deps): Bump softprops/action-gh-release from 1 to 2</message>
<files>
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-05 07:19:57 -0300</date>
<message>Resolve conflicts: upgrade vitest to v3.x and @cloudflare/vitest-pool-workers to v0.10.4</message>
<files>
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-03 22:40:01 +0000</date>
<message>ci(deps): Bump actions/github-script from 7 to 8</message>
<files>
.github/workflows/performance.yml
.github/workflows/pr-lint.yml
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-03 22:39:58 +0000</date>
<message>ci(deps): Bump codecov/codecov-action from 4 to 5</message>
<files>
.github/workflows/ci.yml
</files>
</git_log_commit>
<git_log_commit>
<date>2025-11-03 22:39:55 +0000</date>
<message>ci(deps): Bump actions/checkout from 4 to 5</message>
<files>
.github/workflows/ci.yml
.github/workflows/codeql.yml
.github/workflows/deploy.yml
.github/workflows/performance.yml
.github/workflows/release.yml
</files>
</git_log_commit>
</git_logs>

<instruction>
# AGENTS.md - AI Agent Instructions and Development Guide

This file provides comprehensive guidance for AI agents (Claude Code, GitHub Copilot, etc.) when working with the JoT codebase.

## üìã Instructions for AI Agents

### Critical Starting Steps

**BEFORE replying to any user request, you MUST:**

1. **Fetch documentation** from these essential sources:

   - https://grammy.dev
   - https://grammy.dev/hosting/cloudflare-workers-nodejs
   - https://developers.cloudflare.com/workers/wrangler/environments/
   - https://grammy.dev/ref/core/webhookcallback
   - https://developers.cloudflare.com/workers/configuration/cron-triggers/
   - https://developers.cloudflare.com/kv/
   - https://developers.google.com/jules/api
   - https://core.telegram.org/bots/api
   - https://developers.google.com/jules/api/reference/rest
   - https://developers.google.com/jules/api/reference/rest/v1alpha/sources
   - https://developers.google.com/jules/api/reference/rest/v1alpha/sessions.activities/list
   - https://grammy.dev/ref/core/api
   - https://core.telegram.org/bots/api#sendphoto
   - https://grammy.dev/plugins/keyboard
   - https://grammy.dev/guide/files
   - https://core.telegram.org/bots/api#formatting-options
   - https://core.telegram.org/bots/api#inlinekeyboardmarkup
   - https://grammy.dev/guide/commands
   - https://developers.cloudflare.com/workers/runtime-apis/durable-objects/
   - https://developers.cloudflare.com/workers/wrangler/commands/#deploy
   - https://vitest.dev
   - https://developers.cloudflare.com/workers/testing/vitest-integration/
   - https://developers.cloudflare.com/workers/testing/miniflare/
   - https://jules.google
   - https://developers.cloudflare.com/workers/observability/logging/

2. **Read repomix-output.xml** if it exists in the root directory (it's kept up-to-date)

3. **Check for related documentation files** in the repository

### üéØ Best Practices and Work Rules

#### Code Quality Standards

- **Language**: All code, variables, and comments MUST be in English
- **Comments**: Add comments explaining important decisions throughout the code
- **Keep comments updated**: Comments MUST always reflect the current reality
- **Clarity is crucial**: Having comments in code is critical for maintaining extreme clarity

#### Problem-Solving Approach

- **Research first**: When stuck on an error, search the internet for solutions before asking the user
- **Deep context analysis**: Always seek deeper context within the current code to understand errors
- **Avoid assumptions**: Don't rush to solutions; analyze files deeply to identify possible effects
- **Self-reflection**: Frequently repeat to yourself:
  - The original request
  - What has been done
  - What remains to be done
  - Protection directives against hallucination

#### Search and Documentation Strategy

- **Use web search tools**: Brave Search for errors and documentation
- **Use Context7**: For "straight to the point" documentation
- **Rate limiting**: Limit 2 seconds between each search call to avoid rate limits
- **Generic before specific**: Start with simple, generic search terms before advancing to very specific ones
  - ‚úÖ Example: "laravel code coverage common errors"
  - ‚ùå Avoid: "laravel code coverage pcov null postgres docker compose error"

#### Error Handling Protocol

- **Always search online**: When encountering an error, ALWAYS search the internet to compare your solution idea with actual solutions
- **Compare approaches**: Don't implement the first solution that comes to mind

#### Git Workflow

- **Create branches**: If working with git on main/master, create a branch to work more freely (unless user says to work on main)
- **In plan mode**: Ask the user how they want to proceed with branching
- **No co-authors**: NEVER add co-authors in commits, not even Claude
- **The `gh` command**: Is available and authenticated in the system

#### Environment and Tools

- **Container tool**: Use `podman` and `podman-compose` instead of Docker (already installed in system)
- **Check project structure**: Before starting, review files like docker-compose.yml and Makefile to better understand the system

#### Task Management

- **Always create todo lists**: Keep the user aware of the process
- **Adapt todos**: When one ends and new demands arise, create a new todo or adapt the current one if relevant

#### Quality Checks (TypeScript Projects)

- **Type checking**: If project uses TypeScript, always use project's `tsc` to verify code before advancing/completing task
- **Linting**: If project uses ESLint, verify ESLint errors equally

#### Completion Protocol

- **Notify user**: When needing attention or finishing work, call `mcp__notifications__play_notification` before the final function
- **Auto mode**: If user ends a sentence with exactly the word "auto":
  1. After successfully completing the task
  2. Make commit with summary of operations
  3. Push changes
  4. Call notification as usual
- **Update repomix**: If task succeeds and `repomix-output.xml` exists in root, execute `npx repomix` or call equivalent tool

---

## üèóÔ∏è Project Overview

### What is JoT?

JoT stands for "Jules over Telegram". It is a Cloudflare Worker that provides a Telegram bot interface for Jules (Google's AI asynchronous coding assistant). It uses the Grammy framework for Telegram integration and implements a multi-tenant architecture where each Telegram group has isolated configuration and sessions. Each Telegram topic (forum thread) maps 1:1 to a Jules session for perfect organization.

**Technology Stack:**

- **Runtime**: Cloudflare Workers (serverless)
- **Language**: TypeScript (ES2022)
- **Telegram Framework**: Grammy
- **Testing**: Vitest with `@cloudflare/vitest-pool-workers`
- **Storage**: Cloudflare KV (multi-tenant)
- **API**: Jules API (Google's AI asynchronous coding assistant)

### Common Commands

#### Development

```bash
# Start local development server
npm run dev
# or
wrangler dev
# Server runs at http://localhost:8787
# Note: Cron triggers don't run in dev mode

# Generate TypeScript types from wrangler.toml
npm run cf-typegen
# or
wrangler types
```

#### Testing

```bash
# Run all tests
npm test

# Run tests in watch mode (development)
npm run test:watch

# Run tests with coverage report
npm run test:coverage

# Run tests directly with vitest
npx vitest
npx vitest --run
```

Tests use Vitest with Cloudflare Workers pool for Worker-specific testing. See `vitest.config.ts:3` for configuration.

#### Deployment

```bash
# Deploy to production
npm run deploy
# or
wrangler deploy
```

#### Setup Commands

```bash
# Install dependencies
npm install

# Create KV namespaces (development and preview)
wrangler kv namespace create "KV"
wrangler kv namespace create "KV" --preview

# Set secrets
wrangler secret put BOT_TOKEN
```

### High-Level Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     Webhook      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Telegram   ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ  Cloudflare      ‚îÇ
‚îÇ             ‚îÇ                  ‚îÇ  Worker          ‚îÇ
‚îÇ  User sends ‚îÇ                  ‚îÇ  (Grammy Bot)    ‚îÇ
‚îÇ  message or ‚îÇ                  ‚îÇ                  ‚îÇ
‚îÇ  image      ‚îÇ                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                            ‚îÇ
                                           ‚îÇ API Call
                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                 ‚îÇ                                  ‚îÇ
                 ‚îÇ  Jules API                       ‚îÇ
                 ‚îÇ  (sessions, activities, sources) ‚îÇ
                 ‚îÇ                                  ‚îÇ
                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                 ‚îÇ
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ                                                 ‚îÇ
      ‚îÇ  Cron Trigger (every 1 min)                     ‚îÇ
      ‚îÇ  - Poll new activities for all sessions         ‚îÇ
      ‚îÇ  - Process and format activities                ‚îÇ
      ‚îÇ  - Send to appropriate Telegram topic           ‚îÇ
      ‚îÇ                                                 ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                 ‚îÇ
                                 ‚ñº
                          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                          ‚îÇ  Telegram   ‚îÇ
                          ‚îÇ  (auto      ‚îÇ
                          ‚îÇ  updates)   ‚îÇ
                          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Core Components

#### 1. **Bot Layer** (`src/bot/`)

- **bot.ts** - Core bot configuration, utility functions for sending messages, checking permissions, managing topics
- **commands/** - Command handlers organized by category
  - `basicCommands.ts` - /start, /help
  - `configCommands.ts` - Admin-only configuration commands (/set_jules_token, /set_source, etc.)
  - `infoCommands.ts` - Information display commands (/status, /list_sessions, etc.)
  - `actionCommands.ts` - Action commands (/new_session, /approve_plan, /delete_session, etc.)
- **handlers/** - Message and event processors
  - `messageHandlers.ts` - Processes text and image messages from users
  - `callbackHandlers.ts` - Handles inline button callbacks (approve plan, publish PR, etc.)
  - `activityProcessor.ts` - Processes Jules API activities and formats them for Telegram

#### 2. **Cron Layer** (`src/cron/`)

Automated background tasks triggered by Cloudflare cron triggers:

- `pollActivities.ts` - Polls Jules API for new activities every minute (src/cron/pollActivities.ts:1)
- `syncSessions.ts` - Syncs local sessions with Jules API every 15 minutes (src/cron/syncSessions.ts:1)

Configured in `wrangler.toml:19-23`.

#### 3. **Jules API Integration** (`src/jules/`)

- `api.ts` - Jules API client for:
  - Session management (create, delete, list)
  - Activity polling
  - Sending prompts and images
  - Approving plans
  - Publishing branches/PRs

#### 4. **Storage Layer** (`src/kv/`)

- `storage.ts` - KV storage abstraction for multi-tenant data:
  - Group configurations (token, source, branch, settings)
  - Session mappings (topic ID ‚Üî session ID)
  - Activity tracking
  - KV keys follow pattern: `{groupId}:{type}:{key}`

#### 5. **Utilities** (`src/utils/`)

- `formatters.ts` - Formats Jules outputs for Telegram (expanding blockquotes, GitHub link extraction)
- `github.ts` - GitHub integration utilities
- `image.ts` - Image processing for sending screenshots/designs to Jules
- `retry.ts` - Retry logic for API calls

#### 6. **Main Entry** (`src/index.ts`)

Worker entry point with:

- `fetch()` handler for webhook requests (src/index.ts:109)
- `scheduled()` handler for cron triggers (src/index.ts:143)
- Bot setup and handler registration (src/index.ts:59)

### Multi-Tenancy Model

The architecture implements strict isolation between Telegram groups:

1. **Group Configuration**: Each group has isolated configuration stored in KV

   - Jules API token
   - Default source (repository)
   - Default branch
   - Settings (auto PR, approval required, etc.)

2. **Session Mapping**: Each Telegram topic maps to exactly one Jules session

   - Topic ID ‚Üí Session ID stored in KV
   - Allows multiple concurrent sessions per group
   - Perfect organization with topic-based isolation

3. **Cron Efficiency**: Cron jobs iterate through all active sessions across all groups (see src/cron/pollActivities.ts:15)

### Key Configuration Files

- **wrangler.toml** - Cloudflare Worker configuration

  - KV namespace bindings
  - Cron triggers
  - Environment variables
  - Environment-specific settings (dev/prod)

- **tsconfig.json** - TypeScript configuration

  - ES2022 module system
  - Strict mode enabled
  - Cloudflare Workers types included

- **vitest.config.ts** - Vitest configuration with Cloudflare Workers pool

### Development Workflow

#### Local Development

1. Install dependencies: `npm install`
2. Create KV namespaces for dev and preview
3. Set BOT_TOKEN secret: `wrangler secret put BOT_TOKEN`
4. Start dev server: `npm run dev`
5. Tests: `npm run test:watch` (cron triggers don't run in dev)

#### Testing Strategy

Tests are written using Vitest with Cloudflare Workers pool for realistic Worker environment testing. Tests can run Worker-specific code including:

- KV operations
- Fetch API
- Environment bindings
- Scheduled events

#### Production Deployment

1. Deploy: `npm run deploy`
2. Set Telegram webhook: `curl "https://api.telegram.org/bot<BOT_TOKEN>/setWebhook?url=https://your-worker.workers.dev/webhook"`
3. Cron triggers run automatically (requires Workers Paid plan)

### Critical Implementation Details

#### Permission System

- **Bot Permissions**: Must be admin with "Manage Topics" permission (src/bot/bot.ts:87)
- **User Permissions**: Only group admins can run configuration commands (src/bot/bot.ts:68)
- **Privacy Mode**: Must be disabled in @BotFather to read all group messages

#### Topic Management

- Bot updates topic titles with session info (src/bot/bot.ts:181)
- Format: `{owner}/{repo} {last-4-chars-of-session-id}`
- Requires "can_manage_topics" permission

#### Notification Strategy

- **Important events** (plan ready, errors): Send with notification
- **Routine updates** (typing indicators, progress): Send silently
- See `sendMessage()` in src/bot/bot.ts:151

#### Cron Trigger Logic

Cron jobs determine which task to run based on current minute (src/index.ts:154-165):

- Every 15 minutes: Run session sync
- Every minute: Run activity polling

#### Error Handling

- All bot handlers wrapped in try-catch (src/index.ts:96)
- KV operations include error handling with fallbacks
- API calls use retry logic from utils/retry.ts
- Silent failures for non-critical operations (e.g., topic title updates)

### Common Patterns

#### Creating a New Command

1. Add handler function in appropriate file under `src/bot/commands/`
2. Register in `src/index.ts` setupBot() function
3. Add to relevant command category in README.md
4. Add tests if functionality is complex

#### Processing Messages

1. Text messages: Add handler in `src/bot/handlers/messageHandlers.ts:handleTextMessage`
2. Image messages: Add handler in `src/bot/handlers/messageHandlers.ts:handlePhotoMessage`
3. Callback queries: Add handler in `src/bot/handlers/callbackHandlers.ts`

#### Adding Cron Jobs

1. Create function in `src/cron/`
2. Register in `wrangler.toml` crons array
3. Add logic in `src/index.ts:scheduled()` to determine when to run
4. Requires Workers Paid plan

#### KV Storage Access

Import and use the storage module:

```typescript
import { getGroupConfig, setGroupConfig } from "./kv/storage";

// Read
const config = await getGroupConfig(env, groupId);

// Write
await setGroupConfig(env, groupId, { ...config, key: value });
```

### Testing Guidelines

- Tests are in `test/` directory
- Use Vitest with Cloudflare Workers pool
- Mock external APIs (Telegram, Jules)
- Test KV operations with Workers test environment
- Run `npm test` before committing

### Environment Setup

#### Required Services

1. **Cloudflare Account** - Workers hosting

   - Free tier works for basic functionality
   - Paid tier ($5/month) required for cron triggers

2. **Telegram Bot Token** - From [@BotFather](https://t.me/BotFather)

   - Privacy mode: Disabled
   - Permissions: Admin, Manage Topics

3. **Jules API Key** - From [jules.google](https://jules.google)
   - Configure via `/set_jules_token` command in Telegram

#### KV Namespace Setup

```bash
# Production
wrangler kv namespace create "KV"

# Development
wrangler kv namespace create "KV" --preview
```

Update `wrangler.toml:12-15` with namespace IDs.

### CI/CD Pipeline

Comprehensive GitHub Actions workflows in `.github/workflows/`:

- **ci.yml** - Runs on push/PR: Type checking, linting, tests
- **deploy.yml** - Deploys to Cloudflare on main/develop branch
- **codeql.yml** - Security analysis
- **release.yml** - Creates releases on version tags
- **dependabot.yml** - Automated dependency updates

See `.github/README.md` for detailed CI/CD documentation.

### License

AGPL-3.0-or-later - See LICENSE file for full details.

---

## üìù Development Plan

### Plan Structure Overview

This development plan follows a structured approach to building the Jot Telegram bot. Each section represents a major milestone with specific implementation steps.

### 1. Initial Project Setup

- Create new Cloudflare Worker project using wrangler CLI
- Install Grammy framework as dependency
- Configure basic project structure with TypeScript
- Configure wrangler.toml for development and production environments
- Define Env interface with necessary bindings (KV, environment variables)

**Documentation:**

- https://grammy.dev
- https://grammy.dev/hosting/cloudflare-workers-nodejs
- https://developers.cloudflare.com/workers/wrangler/environments/

### 2. Bot Configuration in Worker

- Create Grammy bot instance using BOT_TOKEN environment variable
- Implement webhookCallback to receive Telegram updates via webhook
- Configure basic Worker fetch handler
- Implement scheduled handler for cron triggers (sync and polling)
- Optimize with pre-configured botInfo to avoid unnecessary getMe calls

**Documentation:**

- https://grammy.dev/hosting/cloudflare-workers-nodejs
- https://grammy.dev/ref/core/webhookcallback
- https://developers.cloudflare.com/workers/configuration/cron-triggers/

### 3. KV Namespace Configuration for Multi-Tenant

- Create KV namespace via wrangler or dashboard
- Configure KV binding in wrangler.toml
- Key structure with group isolation:
  - `group:{group_id}:jules_token`
  - `group:{group_id}:topic:{topic_id}:session`
  - `group:{group_id}:source`
  - `group:{group_id}:automation_mode`
  - `group:{group_id}:require_approval`
  - `group:{group_id}:default_branch`
  - `group:{group_id}:sessions_index`
  - `group:{group_id}:topic:{topic_id}:last_activity_id`
  - `group:{group_id}:topic:{topic_id}:pending_plan`
  - `group:{group_id}:topic:{topic_id}:ready_for_review`
- Implement helpers for KV read/write with group_id as prefix

**Documentation:**

- https://developers.cloudflare.com/kv/

### 4. Authentication System and Per-Group Admin Control

- Implement /set_jules_token command (verifies admin with getChatAdministrators)
- Store token in KV with key `group:{group_id}:jules_token`
- Validate token via GET /v1alpha/sessions before storing
- /status command to verify group configuration
- Ensure total isolation between groups

**Documentation:**

- https://developers.google.com/jules/api
- https://core.telegram.org/bots/api

### 5. 1:1 Topic-Session Management System

- Detect message_thread_id to identify topics
- 1:1 mapping: each topic = 1 Jules session
- Store complete session in KV with status and outputs
- Update topic title: "user/repo session_id" using editForumTopicName
- Verify bot "Manage Topics" permission

**Documentation:**

- https://core.telegram.org/bots/api
- https://developers.google.com/jules/api/reference/rest

### 6. Jules API Integration - Per-Group Sources

- /list_sources command using GET /v1alpha/sources
- Each group sees only their own sources
- /set_source command to define default source
- /get_source command to see configured source
- Store: `group:{group_id}:source`

**Documentation:**

- https://developers.google.com/jules/api/reference/rest/v1alpha/sources

### 7. Jules API Integration - Session Creation

- POST /v1alpha/sessions with {prompt, source, automationMode, requirePlanApproval, startingBranch}
- Extract session_id and store in KV
- Automatically update topic title
- Add to sessions_index
- Start activity polling

**Documentation:**

- https://developers.google.com/jules/api

### 8. "Typing..." Status Indicator

- showTypingIndicator function using sendChatAction "typing"
- Loop repeating every 4-5s (action lasts only 5s)
- Use between sending prompt and receiving activity
- Stop when new activity arrives

**Documentation:**

- https://core.telegram.org/bots/api
- https://grammy.dev/ref/core/api

### 9. Intelligent Notification System

**WITH SOUND (disable_notification=false):**

- planGenerated (MAXIMUM ATTENTION - see section 11)
- sessionCompleted
- "Ready for review"
- progressUpdated with exitCode !== 0
- progressUpdated with artifacts.media
- First activity
- Messages with questions

**SILENT (disable_notification=true):**

- Normal progressUpdated
- bashOutput with exitCode === 0
- Intermediate changeSet
- planApproved
- Informative messages

**Documentation:**

- https://core.telegram.org/bots/api

### 10. Activity Polling via Cron Trigger (AUTOMATIC)

- Cron every 1-2 minutes
- For each active session in each group:
  - GET /v1alpha/sessions/{session_id}/activities
  - Filter new activities (createTime > last_activity_id)
  - **Process and AUTOMATICALLY SEND each activity to correct topic**
  - Update last_activity_id in KV
  - Fetch updated session to get outputs (PRs, branches)
- Implement rate limiting
- **User doesn't need to do anything, activities arrive automatically!**

**Documentation:**

- https://developers.cloudflare.com/workers/configuration/cron-triggers/
- https://developers.google.com/jules/api/reference/rest/v1alpha/sessions.activities/list

### 11. Activity Processing by Type with Special Attention

**planGenerated (MAXIMUM ATTENTION - IMPOSSIBLE TO IGNORE):**

- **Catchy emoji: üéØ**
- **Title in BOLD: "üéØ PLAN CREATED"**
- If requirePlanApproval=true: add **"- APPROVAL REQUIRED"** in bold
- List steps using **expandable blockquote**:
  - Visible title: "üéØ **PLAN CREATED** - X steps"
  - Expandable: `<blockquote expandable>` with complete numbered step list
- Highlighted inline button: "‚úÖ Approve Plan" if requirePlanApproval=true
- If requirePlanApproval=false: inform "Plan will be auto-approved"
- **MANDATORY SOUND NOTIFICATION**
- Use parse_mode: "HTML" for formatting

**planApproved:**

- Brief message: "‚úÖ Plan approved! Jules will start working."
- SILENT

**"Ready for review üéâ":**

- Detect "Ready for review" in title/description
- Format: "üéâ **Ready for review!**\n\nJules finished changes."
- Fetch updated session for outputs
- Inline buttons: "üì¶ Publish branch" and "üîÄ Publish PR"
- Store ready_for_review flag in KV
- WITH SOUND NOTIFICATION

**progressUpdated:**

- If long bashOutput: use expandable blockquote
  - Title: "üîß Command executed: `command`"
  - Expandable: `<blockquote expandable>` with complete output
- If large changeSet: use expandable blockquote
  - Title: "üìÅ Modified files (X files)"
  - Expandable: complete file list
- If artifacts.media: download and send as photo
- exitCode !== 0: emoji ‚ö†Ô∏è + WITH NOTIFICATION
- exitCode === 0: emoji üîß + SILENT

**sessionCompleted:**

- Emoji ‚úÖ + title: "**Session completed!**"
- Fetch final outputs
- Extract and show GitHub links (PR, branch, commits) with emojis
- Clickable links in Markdown: `[View Pull Request #123](URL)`
- If many details: use expandable blockquote
- WITH SOUND NOTIFICATION

**Other activities:**

- If long: use expandable blockquote
- Decide notification based on content

**Documentation:**

- https://developers.google.com/jules/api/reference/rest/v1alpha/sessions.activities
- https://core.telegram.org/bots/api

### 12. Handlers for Publication Buttons

**callback_query "publish_branch:{session_id}":**

- Validate group
- Call Jules API to publish branch
- Update message (remove "Publish branch" button)
- Show branch link: "‚úÖ Branch published! üåø [View on GitHub](URL)"

**callback_query "publish_pr:{session_id}":**

- Validate group
- Call Jules API to create PR
- Update message (remove buttons)
- Show PR link: "‚úÖ Pull Request created! üîÄ [View on GitHub](URL)"

**Documentation:**

- https://grammy.dev/plugins/keyboard

### 13. Support for Receiving User Images

- Handler bot.on("message:photo")
- Extract highest resolution photo: `ctx.message.photo[ctx.message.photo.length - 1]`
- Use ctx.getFile() to get file_path
- Download: `https://api.telegram.org/file/bot<TOKEN>/<file_path>`
- Convert to base64
- Extract caption (or use "Analyze this image")
- POST sendMessage: `{prompt, media: {data: base64, mediaType: "image/jpeg"}}`
- Start "typing..." indicator

**Documentation:**

- https://grammy.dev/guide/files
- https://core.telegram.org/bots/api

### 14. Image to Base64 Conversion

- Function downloadAndConvertImageToBase64(file_path, bot_token)
- Fetch image
- Convert to ArrayBuffer ‚Üí Buffer
- Convert to base64
- Return base64 + mediaType
- Retry logic with exponential backoff
- 30s timeout

**Documentation:**

- https://grammy.dev/guide/files

### 15. Session Sync via Cron

- Cron every 15-30 minutes
- GET /v1alpha/sessions for each group
- Compare with sessions_index in KV
- Detect deleted sessions
- Remove from KV and notify silently
- Update status and outputs

**Documentation:**

- https://developers.google.com/jules/api/reference/rest

### 16. Manual Sync Command

- /sync (admin only)
- Sync only current group
- GET /v1alpha/sessions
- Compare with KV
- If many sessions: use expandable blockquote
- Report: "X synced, Y removed"
- Update titles and show GitHub links

**Documentation:**

- https://grammy.dev/guide/commands

### 17. Delete Session Command

- /delete_session (admin only)
- Verify admin
- Confirmation button: "‚ö†Ô∏è Confirm Deletion"
- Remove from KV and sessions_index
- Notify: "Session removed locally. To permanently delete, visit jules.google"

**Documentation:**

- https://grammy.dev/plugins/keyboard

### 18. Plan Approval

- /approve_plan in topic with pending plan
- Verify pending_plan in KV
- POST /v1alpha/sessions/{session_id}:approvePlan
- Remove pending_plan from KV
- Confirmation: "‚úÖ Plan approved! Jules will start working."
- Callback_query handler for inline button

**Documentation:**

- https://developers.google.com/jules/api/reference/rest

### 19. Continuous Conversation (Text and Images)

**Text in topic with session:**

- POST sendMessage with {prompt}
- Start "typing..."

**Image in topic with session:**

- Download, convert to base64
- POST sendMessage with {prompt, media}
- Start "typing..."

**Without session:**

- Create new session (text or image)

**General chat:**

- Guide to use topics

**Documentation:**

- https://developers.google.com/jules/api

### 20. Artifact Formatting with Expandable Blockquote

**bashOutput:**

- If short: normal code block
- If long: use expandable blockquote
  - Title: "üîß Command: `command`"
  - Expandable: `<blockquote expandable>complete output</blockquote>`
- Show exitCode
- Emoji ‚ö†Ô∏è if error

**changeSet:**

- If few files: list normally
- If many: use expandable blockquote
  - Title: "üìÅ Modified files (X files)"
  - Expandable: `<blockquote expandable>complete list</blockquote>`
- Parse gitPatch.unidiffPatch
- Show +/- lines

**media:**

- Decode base64
- sendPhoto with InputFile
- Caption with title and description

**Documentation:**

- https://core.telegram.org/bots/api#sendphoto

### 21. GitHub Link Extraction

- Function extractGitHubLinks(session.outputs)
- Regex for PR, branch, commit URLs:
  - PR: `https://github.com/[^/]+/[^/]+/pull/\d+`
  - Branch: `https://github.com/[^/]+/[^/]+/tree/[^/\s]+`
  - Commit: `https://github.com/[^/]+/[^/]+/commit/[a-f0-9]+`
- Format as clickable Markdown
- Emojis: üîÄ PR, üåø branch, üìù commit
- Examples:
  - `üîÄ [View Pull Request #123](URL)`
  - `üåø [View Branch feature-xyz](URL)`
  - `üìù [View Commit abc123](URL)`

**Documentation:**

- https://core.telegram.org/bots/api#formatting-options

### 22. Command to Open Jules Settings

**Implement /open_jules_settings:**

- Verify if group has configured source in KV
- If no source: respond "Configure a source first using /set_source"
- If has source:
  - Extract user/repo from source (format: "sources/github/user/repo")
  - Build Jules URL: `https://jules.google/github/{user}/{repo}`
  - Send message with inline button:
    - Text: "‚öôÔ∏è **Advanced Jules Settings**\n\nTo configure Setup Script, Environment Variables and Memories, access repository settings on Jules website."
    - Button: "üîó Open Settings" (url: direct link)
- Add note: "These settings are per-repository and affect all future sessions."
- Works in any context (general chat or topic)

**Technical implementation:**

- Helper function: `parseSourceToGitHubUrl(source: string): string`
  - Input: "sources/github/verseles/dartian"
  - Output: "https://jules.google/github/verseles/dartian"
- Use Grammy's InlineKeyboard to create URL button
- Parse mode: "HTML" or "MarkdownV2" for formatting

**Documentation:**

- https://grammy.dev/plugins/keyboard
- https://core.telegram.org/bots/api#inlinekeyboardmarkup

### 23. Command System (with underscore)

**Basic:**

- /start - Welcome with explanation of topics, images, configuration
- /help - Complete list with examples

**Configuration (admin):**

- /set_jules_token <token>
- /set_source <source_name>
- /set_branch <branch_name>
- /set_auto_pr <on|off>
- /require_approval <on|off>

**Information:**

- /status
- /get_source
- /list_sources
- /list_sessions (use blockquote if many)
- /session_info (use blockquote for details)
- /list_activities (use expandable blockquote)
- /show_plan (use expandable blockquote)
- /show_outputs
- **/open_jules_settings** - Open repository settings on Jules website

**Action:**

- /new_session <prompt>
- /approve_plan
- /delete_session
- /sync

**Documentation:**

- https://grammy.dev/guide/commands

### 24. Message Handlers with Image Support

- Extract group_id
- Verify configured token
- Detect type (text, photo)

**Topic + text:**

- If has session: POST sendMessage
- If not: create new session

**Topic + photo:**

- Download, convert to base64
- POST sendMessage with media
- Create session if necessary

**General chat:**

- Guide to use topics

**Documentation:**

- https://grammy.dev/guide/files

### 25. Multi-Tenant Isolation Layer

- Helper functions always with group_id
- getJulesToken(group_id)
- getSession(group_id, topic_id)
- getActiveSessions(group_id)
- getSource(group_id)
- parseSourceToGitHubUrl(source) - new function
- Validate all KV operations include group_id
- Log cross-group access attempts
- Validate callback_query data

**Documentation:**

- https://developers.cloudflare.com/kv/

### 26. Notification and Feedback System

- Use intelligent notification logic
- Send to correct topic with message_thread_id
- Inline buttons:
  - "‚úÖ Approve Plan"
  - "üì¶ Publish branch"
  - "üîÄ Publish PR"
  - "‚ö†Ô∏è Delete Session"
  - "üîÑ View Details"
  - "üîó Open Settings" (for /open_jules_settings)
  - "‚ùå Cancel"
- Callback_query handlers
- Update messages after action (editMessageText, editMessageReplyMarkup)

**Documentation:**

- https://grammy.dev/plugins/keyboard

### 27. Error Handling and Logs

- Try-catch in all Jules API calls
- Log with group_id, session_id, activity_id, user_id
- Friendly error messages WITH notification
- Rate limiting per group
- Retry logic (3 attempts, exponential backoff)
- Handle 404 (deleted session - remove from KV)
- Handle 401/403 (invalid token - notify admin)
- Image download errors (size, format)
- Image timeout (30s)
- Source parsing error: notify and request /set_source again

**Documentation:**

- https://developers.cloudflare.com/workers/observability/logging/

### 28. Testing with Vitest

- Configure Vitest with @cloudflare/vitest-pool-workers
- Create vitest.config.ts using defineWorkersConfig
- Unit tests:
  - helpers
  - formatters
  - parsers
  - extractGitHubLinks
  - parseSourceToGitHubUrl
- Integration tests: handlers, activity processing, blockquote formatting
- Mock tests: Jules API and Telegram API
- KV tests: read/write operations (miniflare already included)
- Use wrangler dev for local development
- **Note: Miniflare comes integrated in Wrangler 2.0+, no separate installation needed**

**Documentation:**

- https://developers.cloudflare.com/workers/testing/vitest-integration/
- https://developers.cloudflare.com/workers/testing/miniflare/
- https://vitest.dev

### 29. Deploy and Production Configuration

- Environment variables with wrangler secret (BOT_TOKEN)
- Cron triggers in wrangler.toml:
  - `*/1 * * * *` (activity polling - every 1 minute)
  - `*/15 * * * *` (session sync - every 15 minutes)
- wrangler deploy
- Configure Telegram webhook: `https://api.telegram.org/bot<TOKEN>/setWebhook?url=https://<WORKER>.workers.dev/`
- Test complete flow in multiple groups:
  - Create session (text and image)
  - Receive activities automatically via cron
  - Approve plan
  - Ready for review + buttons
  - Publish branch/PR + GitHub links
  - /open_jules_settings
  - Expandable blockquote in long messages
  - Delete session
- Test isolation, notifications, "typing..." indicator
- Monitor logs in dashboard

**Documentation:**

- https://developers.cloudflare.com/workers/wrangler/commands/#deploy
- https://grammy.dev/hosting/cloudflare-workers-nodejs

### 30. Optimizations

- Token cache per group (in memory)
- Sources cache
- Generated Jules URLs cache
- Temporary image cache
- Process only active sessions
- Exponential retry logic
- Consider Durable Objects for continuous "typing..." (5s loop)
- Consider Durable Objects for real-time polling
- Workers Analytics
- Automatic cleanup of old sessions (30 days)
- Debounce for repeated activities
- Compression of long messages or use blockquote
- Streams for large images
- Connection pool for parallel downloads

**Documentation:**

- https://developers.cloudflare.com/workers/runtime-apis/durable-objects/

### 31. Known Jules API Limitations

**Features available ONLY on web interface:**

1. **Setup Script:**

   - No API endpoint to configure/edit setup script
   - Must be configured via web interface at Environment ‚Üí Setup script
   - Affects all future sessions for the repository

2. **Environment Variables per Source:**

   - No endpoint to configure env vars at repository level
   - Must be configured via web interface at Environment ‚Üí Environment variables
   - Affects all future sessions for the repository

3. **Memories/Knowledge:**
   - No endpoint to add/manage memories manually
   - Memories are automatically generated during sessions
   - Manual memories must be added via web interface at Knowledge ‚Üí Add Memory

**Solution in bot:**

- /open_jules_settings command directs user to web interface
- Clearly document these limitations in README
- Add note in relevant commands guiding to use web interface

**Documentation:**

- https://developers.google.com/jules/api
- https://jules.google (web interface)

### 32. Complete README (English, AGPLv3)

**README.md structure:**

- **Title + Badges**: license (AGPLv3), build status, version
- **Description**: What the bot does (2-3 paragraphs)
- **Features**: List with emojis (multi-tenant, topics=sessions, images, GitHub links, etc)
- **Prerequisites**: Node.js 20+, Cloudflare account, Telegram Bot Token (via @BotFather), Jules API key
- **Installation**:
  - Clone repo
  - `npm install`
  - Configure wrangler.toml
  - Create KV namespace
- **Configuration**:
  - Environment variables (BOT_TOKEN via wrangler secret)
  - KV binding setup
  - Cron triggers configuration
- **Bot Setup** (README only):
  - How to create bot in @BotFather
  - How to get bot token
  - How to add bot to group
  - How to grant "Manage Topics" permission
  - How to get Jules API key at jules.google
- **Usage**:
  - Add bot to Telegram group
  - Use /set_jules_token to configure
  - Create topics to organize sessions
  - Send text messages or images
  - System works automatically (cron sends activities)
  - Use /open_jules_settings for advanced settings
- **Commands Reference**: Complete table with all commands and descriptions
- **Image Support**:
  - How to send images to Jules
  - Supported formats (jpg, png, webp)
  - Size limit (20MB)
  - Examples of prompts with images
- **Advanced Configuration**:
  - Setup Script, Environment Variables and Memories must be configured via web interface
  - Use /open_jules_settings for quick access
  - Direct link: https://jules.google/github/{user}/{repo}
- **Architecture**:
  - Flow diagram (Telegram ‚Üí Worker ‚Üí Jules API ‚Üí Activities ‚Üí Telegram)
  - Multi-tenant with per-group isolation
  - Cron for automatic activity polling
- **Development**:
  - `wrangler dev` for local development
  - `npm test` to run tests with Vitest
  - **Note: Don't use Docker** (Workers uses V8 Isolates, not containers)
- **Testing**:
  - How to run tests: `npm test`
  - Vitest with @cloudflare/vitest-pool-workers
  - Miniflare already included in Wrangler 2.0+
- **Deployment**:
  - `wrangler deploy`
  - Configure Telegram webhook
  - Monitor logs
- **API Limitations**:
  - Setup Script: web only
  - Environment Variables (per source): web only
  - Manual Memories: web only
  - Use /open_jules_settings to access web interface
- **Troubleshooting**:
  - Required permissions (admin + "Manage Topics")
  - Invalid/expired token
  - Session deleted on jules.google
  - Rate limiting
  - Images too large
  - Unsupported formats
  - Source not configured (required for /open_jules_settings)
- **Contributing**:
  - Code style: TypeScript, code in English, explanatory comments
  - PR process
  - Mandatory tests
- **License**: AGPLv3 with link to LICENSE file
- **Credits**: Grammy, Jules API, Cloudflare Workers, TypeScript

**Documentation:**

- https://grammy.dev
- https://developers.cloudflare.com/workers/
- https://jules.google

---

## üêõ Known Issues and Debugging

### Bug Reports - Status: REPORTED

**Date:** 06/11/2025
**Conversation:** Continuation session needed

---

### Issue 1: `/list_sources` Infinite Loop ‚ùå

**Status:** REPORTED - Still failing after all fixes
**Error:** Bot sends "üîÑ Loading sources..." repeatedly in a loop

### Issue 2: `/new_session` INVALID_ARGUMENT Error ‚ùå

**Status:** REPORTED - Still failing after multiple attempts
**Error:** `Jules API error (400): Request contains an invalid argument.`

---

### Detailed Analysis

#### Issue 2 - `/new_session` Failure Deep Dive

##### Error Message

```
Jules over Telegram, [06/11/2025 02:45]
‚ùå Failed to create session.

Error: Jules API error (400): {
  "error": {
    "code": 400,
    "message": "Request contains an invalid argument.",
    "status": "INVALID_ARGUMENT"
  }
}
```

##### Root Cause Investigation

**Initial Hypothesis:** automation_mode format issue

- Changed from `'AUTO_PR' | 'MANUAL'` to `'INTERACTIVE' | 'PLAN' | 'AUTO'`
- Updated to send numeric enums (1, 2, 3) to Jules API
- **Result:** FAILED - Same error persists

**Second Attempt:** Only send automation_mode when explicitly set

- Modified code to NOT send `automation_mode` field when null/undefined
- Let Jules API use its default
- **Result:** FAILED - Same error persists

**Code Applied:**

```typescript
// src/bot/commands/actionCommands.ts (lines 92-108)
const defaultBranch = await getDefaultBranch(ctx.env, groupId);
const automationMode = await getAutomationMode(ctx.env, groupId);
const requireApproval = await getRequireApproval(ctx.env, groupId);

const createParams: any = {
  prompt,
  source,
  requirePlanApproval: requireApproval,
  startingBranch: defaultBranch || undefined,
};

// Only add automationMode if explicitly configured
if (automationMode) {
  createParams.automationMode = automationMode;
}

const session = await julesClient.createSession(createParams);
```

**Third Attempt:** Remove ALL optional fields

- Tried sending only `prompt` and `source_context`
- **Result:** NOT TESTED YET

##### Jules API Schema (from src/jules/api.ts)

```typescript
async createSession(params: {
  prompt: string;
  source: string;
  automationMode?: 'INTERACTIVE' | 'PLAN' | 'AUTO';
  requirePlanApproval?: boolean;
  startingBranch?: string;
  media?: {
    data: string;
    mediaType: string;
  };
}): Promise<JulesSession>

// Maps to body:
const body: any = {
  prompt: params.prompt,
  source_context: {
    source: params.source,
  },
};

// Only send automation_mode if explicitly specified
if (params.automationMode) {
  if (params.automationMode === 'INTERACTIVE') {
    body.automation_mode = 1;
  } else if (params.automationMode === 'PLAN') {
    body.automation_mode = 2;
  } else if (params.automationMode === 'AUTO') {
    body.automation_mode = 3;
  }
}

// Only send optional fields if provided
if (params.requirePlanApproval !== undefined && params.requirePlanApproval !== null) {
  body.require_plan_approval = params.requirePlanApproval;
}

if (params.startingBranch && params.startingBranch.trim() !== '') {
  body.starting_branch = params.startingBranch;
}

if (params.media) {
  body.media = params.media;
}
```

##### What Was Changed (Type System)

**All automation mode types updated:**

1. `src/types/env.ts` - SessionData, GroupConfig, JulesSession interfaces
2. `src/kv/storage.ts` - getAutomationMode(), setAutomationMode()
3. `src/bot/commands/actionCommands.ts` - `/new_session` command
4. `src/bot/commands/configCommands.ts` - `/set_auto_pr` command
5. `src/bot/commands/infoCommands.ts` - `/session_info` command
6. `src/bot/handlers/messageHandlers.ts` - Auto-create session (2 locations)
7. `src/utils/formatters.ts` - Status display

**Config Command Changes:**

- `on` ‚Üí `'AUTO'` (was `'AUTO_PR'`)
- `off` ‚Üí `'INTERACTIVE'` (was `'MANUAL'`)
- Messages updated accordingly

##### Debugging Data Needed

The user should provide:

1. What automation mode is configured? Run `/status`
2. What is the source? Run `/get_source`
3. What is default branch? Run `/status`
4. Are there any KV values set? Need to check KV namespace

---

### What Was Fixed ‚úÖ

#### 1. TypeScript Compilation Errors

- **Problem:** CI pipeline failing on "Run TypeScript type check"
- **Cause:** Type mismatch between `'AUTO_PR' | 'MANUAL'` and `'INTERACTIVE' | 'PLAN' | 'AUTO'`
- **Solution:** Updated all type references across 7 files
- **Status:** ‚úÖ FIXED - All 40 tests pass

#### 2. Deployment Pipeline

- **Problem:** GitHub Actions CI failing
- **Cause:** TypeScript errors blocking merge
- **Solution:** Fixed all type mismatches
- **Status:** ‚úÖ FIXED - Can deploy successfully

---

### Current Deployment State

**Worker URL:** https://jules-over-telegram.cloudatlas.workers.dev
**Current Version:** 4b92c9c3-769e-49d1-a85b-4cc1a55e2c79
**Deployment Time:** 06/11/2025 02:46
**Test Status:** ‚úÖ All 40 tests passing
**TypeScript:** ‚úÖ No compilation errors

---

### Next Debugging Steps (for continuation conversation)

#### Step 1: Test Minimal Request

Create a test that sends ONLY the required fields:

```typescript
// In actionCommands.ts line 96, replace with:
const session = await julesClient.createSession({
  prompt,
  source,
  // NO optional fields
});
```

#### Step 2: Check KV Values

Verify what values are actually stored in KV:

```bash
# Check automation mode
wrangler kv key get --binding=KV "group:{groupId}:automation_mode"

# Check require approval
wrangler kv key get --binding=KV "group:{groupId}:require_approval"

# Check default branch
wrangler kv key get --binding=KV "group:{groupId}:default_branch"
```

#### Step 3: Add Debug Logging

Add console.log to see what body is being sent:

```typescript
// In api.ts createSession(), before request:
console.log("Request body:", JSON.stringify(body, null, 2));
```

#### Step 4: Check Jules API Documentation

Look at actual API documentation to verify correct schema:

- URL: https://developers.google.com/jules/api/reference/rest/v1alpha/sessions

#### Step 5: Verify Source Format

Check if source format is correct:

- Current: `sources/github/insign/1kb.club`
- Is this the correct format?
- Should it be just `github/insign/1kb.club`?

---

### File Changes Summary

#### Modified Files (automation mode fix)

1. `src/types/env.ts` - Updated interface types
2. `src/kv/storage.ts` - Updated function signatures
3. `src/bot/commands/actionCommands.ts` - Added conditional automation_mode
4. `src/bot/commands/configCommands.ts` - Changed on/off mapping
5. `src/bot/commands/infoCommands.ts` - Updated display text
6. `src/bot/handlers/messageHandlers.ts` - Added conditional automation_mode (2 places)
7. `src/utils/formatters.ts` - Updated display text

#### Cache Implementation (already exists)

- `src/kv/storage.ts` - Cache functions with 5-minute TTL
- `src/bot/commands/infoCommands.ts` - handleListSources uses cache
- `src/bot/handlers/callbackHandlers.ts` - Pagination with inline keyboards

---

### Jules API Reference

#### Official Documentation

- Base URL: https://jules.googleapis.com/v1alpha
- Sessions: https://developers.google.com/jules/api/reference/rest/v1alpha/sessions
- Sources: https://developers.google.com/jules/api/reference/rest/v1alpha/sources

#### API Endpoints Used

1. `GET /sessions` - List sessions
2. `POST /sessions` - Create session ‚≠ê (failing)
3. `GET /sessions/{id}` - Get session
4. `POST /sessions/{id}:approvePlan` - Approve plan
5. `GET /sources` - List sources
6. `GET /activities` - List activities

#### Authentication

- Header: `X-Goog-Api-Key: {token}`
- ‚ùå NOT using Bearer token

---

### Commands Reference

#### Working Commands ‚úÖ

- `/start` - Bot introduction
- `/help` - Show available commands
- `/status` - Show group configuration
- `/get_source` - Show configured source
- `/list_sources` - List available sources (but may loop)
- `/set_jules_token <token>` - Set Jules API token
- `/set_source <source>` - Set default source
- `/list_sessions` - List active sessions

#### Failing Commands ‚ùå

- `/new_session <prompt>` - Create new session (INVALID_ARGUMENT)
- `/session_info` - Show session details (depends on new_session working)

---

### Testing Commands (for user to run)

Run these in Telegram bot and report results:

1. `/status` - What automation mode is shown?
2. `/get_source` - What source is configured?
3. `/list_sources` - Does it loop or work?
4. `/new_session test` - Does it still fail with INVALID_ARGUMENT?

---

### CI/CD Pipeline

#### GitHub Actions Workflows

- `.github/workflows/ci.yml` - Lint, Type Check, Tests ‚úÖ
- `.github/workflows/deploy.yml` - Deploy to Cloudflare ‚úÖ
- `.github/workflows/codeql.yml` - Security analysis ‚úÖ

#### Status

- **CI:** ‚úÖ Passing (after type fixes)
- **Deploy:** ‚úÖ Passing
- **Type Check:** ‚úÖ Passing (40/40 tests)

---

### Cron Jobs

Configured in `wrangler.toml`:

- `*/1 * * * *` - Poll activities every minute
- `*/15 * * * *` - Sync sessions every 15 minutes

---

### Key Decisions Made

1. **Cache TTL:** 5 minutes (reduced from 1 hour) - User feedback
2. **Pagination:** Inline keyboard with page:index pattern
3. **Automation Modes:** INTERACTIVE (default), PLAN, AUTO
4. **Config Command:** on=AUTO, off=INTERACTIVE
5. **API Schema:** Numeric enums (1,2,3) for automation_mode

---

### Unresolved Questions

1. Why does Jules API reject the request even without automation_mode?
2. Is the source format correct? `sources/github/user/repo` or `github/user/repo`?
3. What is the exact minimum required fields for createSession?
4. Does Jules API require any specific field ordering?
5. Are there any hidden required fields we're missing?

---

### Continuation Instructions

When starting new conversation, reference this file and:

1. Start from "Next Debugging Steps" section
2. Try Step 1 (minimal request) first
3. Add debug logging to see actual request body
4. Verify Jules API documentation for correct schema
5. Check KV values to see what user has configured

---

## üìö Additional Resources

### External Documentation Links

- [Grammy Documentation](https://grammy.dev)
- [Cloudflare Workers Documentation](https://developers.cloudflare.com/workers/)
- [Jules API Documentation](https://developers.google.com/jules/api)
- [Telegram Bot API](https://core.telegram.org/bots/api)
- [Vitest Documentation](https://vitest.dev)

### Project-Specific Resources

- [GitHub Repository](https://github.com/your-org/jot)
- [Issue Tracker](https://github.com/your-org/jot/issues)
- [Cloudflare Workers Dashboard](https://dash.cloudflare.com/)
- [Jules Console](https://jules.google)

---

**Last Updated:** 2025-11-17
**Document Version:** 1.0.0
**License:** AGPL-3.0-or-later

</instruction>
